<html>
<title>Racemi in 2D</title>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            color-scheme: dark;
            --canvas-bg-color: rgba(0, 0, 0, 0); /* transparent */
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #mycanvas {
            border: hsl(0 0% 30%);/*  #999999; #504e52 */
            border-style: solid; /* ridge, dashed */
            border-width: 5;
            outline: none;  /* because of the 'tabindex' focus trick */
            background-color: var(--canvas-bg-color);  
        }
    </style>

    <!-- lilgui -->
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script>
    <!--script src="lilgui.js"></script-->
    
    <!-- Plotly -->
    <!--script src="https://cdn.plot.ly/plotly-2.20.0.min.js" charset="utf-8"></script-->
    <script src="plotly-2.20.0.min.js" charset="utf-8"></script>

</head>

<body>
    <!-- 'tabindex' is a trick to make the canvas capture key events -->
    <canvas id="mycanvas" tabindex="1"></canvas>
    
    <div id="fig01" style="width:600px;height:600px;"></div>

    <script>
	console.log(document.getElementById("mycanvas"));

	// Parameter initialization
	const nd = 2;
        const numAtomTypes = 4;
        const numAtoms = 60;
        const atomRadius = 4;
	const interactionRange = 80;
        const minClustMembCount = 2;
	const maxNumLiveClusters = numAtoms * (1/(1 - 1/5) - 1); // 2->1, 4->1/3, 5->1/4,
        const maxRadius = [2000, 1000];
        const irrdisn = 1 - nd;                     // attraction force irradiance to distance power law: I ~ d^(irrdisn)
        const maxRange = Math.max(...maxRadius);
        const palette = ['red', 'green', 'cyan', 'teal', 'lavender', 'yellow', 'blue', 'magenta'];
        const wallElasticity = .5; //0.1;
	const dampCoef = .07; //0.7;

        const settings = {
            seed: 91651088029,
            fps: 0,
            atoms: {
                count: numAtoms / numAtomTypes,  // per color
                radius: atomRadius,
            },
            drawings: {  // drawing options can be expensive on performance
                forcelines: false,    // central force lines between interacting atoms 
                round: false,         // draw round atoms 
                clusters: false,
                background_color: '#00000000', 
            },
            explore: false,
            explorationPeriod: 100,
            logTimeStep: 0,
            interactionForces: {},
            range: {},
            colors: [],
            numColors: numAtomTypes,
            maxNumLiveClusters: maxNumLiveClusters,
            interaction_law: irrdisn, 
            damping: Math.log10(dampCoef),  // speed-dampening (can be >1 !)
            gravity: 0.0,  // pulling downward
            prodStrengthAndDuration: 10,
	    wraparound: false,
            wallThickness: 40,
            wallElasticity: wallElasticity,
	    reset: () => restartAtoms(settings.atoms.count, true),
            randomInteractions: () => {
                settings.seed += 0x6D2B79F5;  // change seed
                resetWorld();
            },
            symmetrizeInteractions: () => {
                symmetrizeInteractions();
                restartAtoms(settings.atoms.count, true);
                updateGuiDisplay();
            },
            gui: null,
            export: {     
                image: () => {   // screenshot image
                    const imageDataURL = canv.toDataURL({format: 'png', quality: 1});
                    dataUrlDownloader(imageDataURL);
                },
                video: () => mediaRecorder.state == 'recording' ? mediaRecorder.stop() : mediaRecorder.start(), // video recording
            },
        }


        /*** SET UP GUI ***/

        const setupProd = () => {
            canv.addEventListener('click', (me) => {prod_st = settings.prodStrengthAndDuration;   // MouseEvent
                                                    if (me.shiftKey) prod_st = -prod_st;        // if shiftKey then attract
                                                    prod_x = me.clientX; prod_y = me.clientY;
				                    console.log(`coordinates: ${prod_x}, ${prod_y}`);
            })
        }

        function setupHotkeys() {
	    canv.addEventListener('keydown', (ke) => {  // KeyboardEvent
                console.log(ke.key);
                switch (ke.key) {
                    case 'r': settings.randomInteractions();                            break;
                    case 'c': settings.drawings.clusters = !settings.drawings.clusters; break;
                    case ' ': settings.reset();                                         break;
                    case 's': settings.symmetrizeInteractions();                        break;
                    default: ;
                };
            })
            let titl = document.getElementsByClassName("title")[0]; // document..querySelector('div.title[tabindex="0"]')
            canv.addEventListener("keydown", (ke) => {
                const aeb = JSON.parse(titl.getAttribute("aria-expanded")); 		
		if (ke.key=="t") {
		    titl.setAttribute("aria-expanded", (!aeb).toString()); 
		    if (gui._closed) gui.open(); else gui.close();
		}
 	    }); 
        }

        const updateGuiDisplay = () => {
            console.log('gui', gui);
            gui.destroy();
            setupGui();
        }

        Object.defineProperty(String.prototype, 'capitalize', {
	    value: function() {return this.charAt(0).toUpperCase() + this.slice(1)},
            enumerable: false
        })

        const setupGui = () => {
            gui = new lil.GUI()
	    gui.title("Controls (t)");		    

            // Physics
            const configFolder = gui.addFolder('Physics')
            configFolder.add(settings, 'reset').name('Reset ( )')
            configFolder.add(settings, 'randomInteractions').name('Random interactions (r)')
            configFolder.add(settings, 'symmetrizeInteractions').name('Symmetrize interactions (s)')
	    configFolder.add(settings, 'numColors', 1, 7, 1).name('Number of colors').listen().onFinishChange(v => {setColors(); resetWorld();})
            configFolder.add(settings.atoms, 'count', 1, numAtomsNow()/numAtomTypes*2, 1).name('Atoms per color').listen().onFinishChange(v => restartAtoms(v, true))
            configFolder.add(settings, 'maxNumLiveClusters', 1, numAtomsNow(), 1).name('Max. num. of clusters').listen()
            configFolder.add(settings, 'interaction_law', -3, 3, 0.001).name('Interaction law').listen()
            configFolder.add(settings, 'damping', -9, 2, .1).name('Log10 damping').listen()
            configFolder.add(settings, 'gravity', 0., 1., 0.05).name('Gravity').listen()
            configFolder.add(settings, 'prodStrengthAndDuration', 1, 100, 1).name('Prod strength and duration').listen()
            configFolder.add(settings, 'wraparound').name('Wrap around').listen()
            configFolder.add(settings, 'wallThickness', 0, 500, 1).name('Wall thickness').listen()
            configFolder.add(settings, 'wallElasticity', 0, 10, .01).name('Wall elasticity').listen()
            configFolder.add(settings, 'fps').name('fps').listen().disable()
            configFolder.add(settings, 'logTimeStep', -2, 1, .1).name('Log10 time step').listen()
            configFolder.add(settings, 'explore').name('Parameter exploration').listen()
            configFolder.add(settings, 'seed').name('Seed').listen().onFinishChange(v => resetWorld())

            // Drawings
            const drawingsFolder = gui.addFolder('Drawings')
            drawingsFolder.add(settings.atoms, 'radius', 1, 10, 0.5).name('Atom radius').listen()
            drawingsFolder.add(settings.drawings, 'round').name('Round atoms').listen()
            drawingsFolder.add(settings.drawings, 'clusters').name('Track clusters (c)').listen()
            drawingsFolder.add(settings.drawings, 'forcelines').name('Central force lines').listen()
            drawingsFolder.addColor(settings.drawings, 'background_color').name('Background color').listen()

            // Color interactions
            for (const atomColor of settings.colors) {
                const colorFolder =
                    gui.addFolder(`Rules: <font color=\'${atomColor}\'>${atomColor.capitalize()}</font>`)
                for (const ruleColor of settings.colors) {
                    colorFolder.add(settings.interactionForces[atomColor], ruleColor, -1, 1, 0.001)
                         .name(`<-> <font color=\'${ruleColor}\'>${ruleColor.capitalize()}</font>`).listen()
                }
                colorFolder.add(settings.range, atomColor, 1, maxRange, 5).name('Radius').listen()
            }

            // Export
            const exportFolder = gui.addFolder('Export')
            exportFolder.add(settings.export, 'image').name('Image')
            exportFolder.add(settings.export, 'video').name('Video: Start / Stop')

        }


        /*** PRNG ***/

        // Pseudorandom number generator
        // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
        function mulberry32prng(seed) {
            return function() {
	        var t = seed += 0x6D2B79F5;
		t = Math.imul(t ^ t >>> 15, t | 1);
	        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
	        return ((t ^ t >>> 14) >>> 0) / 4294967296;
	    }
	}

        function getSeedFromUrlFragment() { 
            let hash = window.location.hash;  // fragment identifier of the URL
            if (hash != undefined && hash[0] == '#') {
                let urlfi = Number(hash.substr(1)); // remove the leading '#'
                if (isFinite(urlfi)) {
                    settings.seed = urlfi;
                    console.log("Using from the URL fragment the seed " + settings.seed);
                }
            }
        }

        // Random integer: the maximum and minimum are inclusive
	const randint = (min, max) => Math.floor(Math.random() * (max + 1 - min) + min);


	/*** ATOMS AND FORCES ***/    

        // atom = [x, y, vx, vy, hsl, id]

        // Initiate random locations for atoms 
        function randomX() {return mb32closure() * (canv.width - 100) + 50;}
        function randomY() {return mb32closure() * (canv.height - 100) + 50;}
        function createAtoms(n) {
            for (let i = 0; i < settings.colors.length; i++) 
	        for (let j = 0; j < n; j++) 
	            atoms.push([randomX(), randomY(), 0, 0, rgb2hsl(...colstr2rgb(settings.colors[i])), i]);
        };

        function restartAtoms(numPerColor, erase_past = true) {
	    if (erase_past) {
		atoms.length = 0;
                clusters.length = 0;  entities.length = 0; 
	        starttime = Date.now();
	    }
            createAtoms(numPerColor);
            clusters[0] = atoms;	    
	    clusters.push([spawnCluster()]); // initialize top/universe cluster
	    nsplits = nmerges = 0;
        }

        function randomInteractions() {
            for (const i of settings.colors) {
                settings.interactionForces[i] = {};
                for (const j of settings.colors) settings.interactionForces[i][j] = mb32closure() * 2 - 1; // range [-1 1]
                settings.range[i] = interactionRange;
            }
            if (!isFinite(settings.seed)) settings.seed = 0xcafecafe;
            window.location.hash = "#" + settings.seed;
            document.title = "Racemi2D #" + settings.seed;
            console.log("Seed=" + settings.seed);
            console.log(JSON.stringify(settings.interactionForces));
        }

        function symmetrizeInteractions() {
            for (const i of settings.colors) 
                for (const j of settings.colors) 
                    if (j < i) {
                        let v = 0.5 * (settings.interactionForces[i][j] + settings.interactionForces[j][i]);
                        settings.interactionForces[i][j] = settings.interactionForces[j][i] = v;
                    }
            console.log(JSON.stringify(settings.interactionForces));
        }

        function resetWorld() {
            randomInteractions();
            restartAtoms(settings.atoms.count, true);
            updateGuiDisplay();
        }

        function setColors() {
            settings.colors = [];
            for (let i = 0; i < settings.numColors; ++i) settings.colors.push(palette[i]);
        }

        function roamParamspace() {
            if (exploration_timer <= 0) {
                let c1 = settings.colors[Math.floor(mb32closure() * settings.numColors)]; //random color 1
                if (mb32closure() >= 0.2) {  // 80% chance of changing the strength
                    let c2 = settings.colors[Math.floor(mb32closure() * settings.numColors)];
                    let new_strength = mb32closure();
                    if (settings.interactionForces[c1][c2] > 0) new_strength *= -1; // enforce anti-signed interactions for appeal
                    settings.interactionForces[c1][c2] = new_strength;
                } else {                     // 20% for the range
                    settings.range[c1] = 1 + Math.floor(mb32closure() * maxRange);
                }
                exploration_timer = settings.explorationPeriod; // in frames, so in seconds it's EP/FPS ~ 100/20 = 5
            } else exploration_timer -= 1;
        }


	 /*** DISPLAY AND DRAWING ***/   

        function updateCanvas() {
            canv.width = window.innerWidth * 0.8;
            canv.height = window.innerHeight * 0.95;
            crc.fillStyle = settings.drawings.background_color;  
            crc.fillRect(0, 0, canv.width, canv.height); // bg color
        }

        function colstr2rgb(str) {
            var a = document.createElement('div');
            a.style.color = str;
            var colors = window.getComputedStyle( document.body.appendChild(a) ).color.match(/\d+/g).map(function(a){ return parseInt(a,10); });
            document.body.removeChild(a);
	    return (colors.length>=3) ? colors : false;
        };
	function rgb2hsl(r, g, b) {
	    r /= 255; g /= 255; b /= 255;
	    let cmin = Math.min(r,g,b), cmax = Math.max(r,g,b), delta = cmax - cmin, h = 0, s = 0, l = 0;
	    // hue
	    if (delta == 0) h = 0;
            else if (cmax == r) h = ((g - b) / delta) % 6;
	    else if (cmax == g) h = (b - r) / delta + 2;
	    else                h = (r - g) / delta + 4;
	    h = Math.round(h * 60);
	    if (h < 0) h += 360;
            // lightness
	    const l1 = (cmax + cmin) / 2;  
	    l = +(l1 * 100).toFixed(1);
            // saturation
	    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l1 - 1)); 
	    s = +(s * 100).toFixed(1);
	    return [h, s, l] 
	}	
        hsl2str = (h,s,l) => "hsl(" + h + "," + s + "%," + l + "%)";

	hslColor = (h, s, l, a = 1) => {`hsl(${h},${s}%,${l}%,${a})`};

        // Draw a square
        const drawSquare = (x, y, color, radius) => {
            crc.fillStyle = color;
            crc.fillRect(x - radius, y - radius, 2 * radius, 2 * radius);
        }

        // Draw a circle
        function drawCircle(x, y, color, radius, fill = true, lw = 1, dash = [false, 10, 10]) {
	    crc.lineWidth = lw;	    
	    if (dash[0]) crc.setLineDash(dash.slice(1,3)); 
            crc.beginPath();
            crc.arc(x, y, radius, 0 * Math.PI, 2 * Math.PI);  // x, y, radius, ArcStart, ArcEnd
            crc.closePath();
            crc.strokeStyle = color;
	    crc.fillStyle = color;
            fill ? crc.fill() : crc.stroke()
        };

        // Draw line between atoms
        function drawInteraction(ax, ay, bx, by, color) {
            crc.beginPath();
            crc.moveTo(ax, ay);
            crc.lineTo(bx, by);
            crc.closePath();
            crc.strokeStyle = color;
            crc.stroke();
        };


	/*** CLUSTERS ***/    

        // clusters:     [position-x, position-y, sma1, sma2, hslcolor, members, member_sqdis, entid]
        // Voronoi cell: [count, accum-x, accum-y, accum-d^2, accum-hslcolor, members, member_sqdis]

	function spawnCluster(x = randomX(), y = randomY(), sma1 = maxRadius[0], sma2, hslcolor, M = [], Msd = [], ei) {
            if (sma2 === undefined) sma2 = sma1;
            if (hslcolor === undefined) hslcolor = rgb2hsl(...colstr2rgb('white')); 
            return [x, y, sma1, sma2, hslcolor, M, Msd, ei];
        }
	function computeSumdis(l, C, d = 2) {
	    const bl = clusters[l-1];
            let barycenter = [0, 0];
	    let sd = 0;
	    for (let m of C) {barycenter[0] += bl[m][0]; barycenter[1] += bl[m][1];} barycenter[0] /= C.length; barycenter[1] /= C.length;
	    for (let m of C) {
		switch (d) {
		    case d % 2 == 1: sd += Math.abs(bl[m][0] - barycenter[0])**d + Math.abs(bl[m][1] - barycenter[1])**d;
		    case d % 2 == 0: sd += (bl[m][0] - barycenter[0])**d + (bl[m][1] - barycenter[1])**d;
		}
	    }
	    return [sd, barycenter];
	}
	function breedCluster(l, x, y, M) {
            const C = spawnCluster(x, y, maxRadius[0], maxRadius[0], undefined, M); 
	    clusters[l].push(C);		
	    if (entities.length > 0) [ei, isnew] = findCompoundEntities(clusters[l].length-1, l).slice(1,3);
	}
        function killCluster(l, ci) {
	    if (entities.length > 0) {
                const E = entities[l][clusters[l][ci][7]];
                // entity: register lifespan
	        E[3][E[1].lastIndexOf(ci)] = Date.now() - E[2][E[1].lastIndexOf(ci)];   
	    }
	    // cluster: kill and make tomb
	    clusters[l][ci] = ["tomb"]; 
            const pi = findParentClusterId(l, ci);
	    if (pi !== false) {
	        let P = clusters[l+1][pi];
		P[5].splice(P[5].lastIndexOf(ci),1);
		P[6].splice(P[6].lastIndexOf(ci),1);
	    }
        }
        function findParentClusterId(l, ci) {
	    if (l+1 < clusters.length && clusters[l+1].length > 0) {
	        for (let i = 0; i < clusters[l+1].length; i++)
		    if (clusters[l+1][i].length > 1 && clusters[l+1][i][5].includes(ci)) return i;
	        return false;
	    } else return false;
	}
        function trySplitting1ClusterGreedily(l) { // Similar to bisecting k-means
	    const Cl = clusters[l];
	    let ci, C;
	    do {ci = randint(0, Cl.length-1); C = Cl[ci];} while (C.length == 1); 
	    const bl = clusters[l-1];
	    let ssd0 = C[6].reduce((a,b)=>a+b,0);
            const nm = C[5].length; 
	    if (nm < 4) return undefined;

            // randomly partition C: n-subset of C, with 2 <= n <= Csize-2
            const n = randint(2, nm-2);  // disallow clusters of size less than 2
	    let mi = [];
	    let H1 = [], H2 = []
	    for (let i = 0; i < n; i++) {
	       const ri = randint(0, nm-1);
	       for (var j = 0; j < mi.length; j++) if (mi[j] == ri) break;
	       if (j == mi.length) {mi.push(ri); H1.push(C[5][ri]);}
	    }
            H2 = subtractSets(C[5], H1);

            // compute sum of intercluster squared distances
	    let [ssd1, bc1] = computeSumdis(l, H1, 2);
	    let [ssd2, bc2] = computeSumdis(l, H2, 2); 

	    if (l < clusters.length-1) {       
	        const pi = findParentClusterId(l, ci);          // find parent cluster		    
	        if (pi === false)  return undefined;
		else               var P = clusters[l+1][pi]; 
	    } else if (clusters.length-1 == l && clusters[l].length == 1)  
		var P = spawnCluster(x = C[0], y = C[1]); // potential new top cluster 

            // compute sum of inter-centroid squared distances
            ssd0 += (C[0] - P[0])**2 + (C[1] - P[1])**2; // 0 if new top cluster 
            ssd1 += (bc1[0] - P[0])**2 + (bc1[1] - P[1])**2; 
            ssd2 += (bc2[0] - P[0])**2 + (bc2[1] - P[1])**2; 

	    if (ssd0 > ssd1 + ssd2) {                    
		// kill formerly united cluster
	        killCluster(l, ci); 	  

		// create 2 new clusters
	//	const C1 = spawnCluster(x = bc1[0], y = bc1[1], M = H1); 
	//	const C2 = spawnCluster(x = bc2[0], y = bc2[1], M = H2); 
          //      clusters[l].push(C1);
	//	clusters[l].push(C2);
                // add to entities array
	//	let [ei1, isnew1] = findCompoundEntities(clusters[l].length-2, l).slice(1,3);
	//	let [ei2, isnew2] = findCompoundEntities(clusters[l].length-1, l).slice(1,3);
		breedCluster(l, bc1[0], bc1[1], H1);
		breedCluster(l, bc2[0], bc2[1], H2);

                // stack a new top cluster after splitting old topclus
		if (l == clusters.length-1) {
		    P[5] = [clusters[l].length-2, clusters[l].length-1];
		    P[6] = [(bc1[0] - P[0])**2 + (bc1[1] - P[1])**2, (bc2[0] - P[0])**2 + (bc2[1] - P[1])**2];
		    P[7] = 0;
		    clusters.push([P]); 
		    if (entities.length > l+1) findCompoundEntities(0, l+1);
		}

                console.log(`split ${++nsplits}`);
		return [[H1, H2], [ssd1, ssd2]]; 
	    } else 
	        return [[C[5]], [ssd0]];
	}
        
	function tryMerging2ClustersGreedily(l) {
	    if (clusters[l].length == 1) return undefined;

	    const Cl = clusters[l]; 
	    const nc = Cl.length;
	    // pick two arbitrary distinct clusters
            let i1, pi1, i2, pi2;
            do {
		i1 = randint(0, nc-1);            i2 = randint(0, nc-1); 
	        pi1 = findParentClusterId(l, i1); pi2 = findParentClusterId(l, i2);
	    } while (i2 == i1 || Cl[i1].length == 1 || Cl[i2].length == 1) 

	    // find the common parent, else return
	    if (!pi1 || !clusters[l+1][pi1].includes(i2)) return undefined;
	    else                                          var P = clusters[l+1][pi1];   

            // define subclusters
	    const c1 = Cl[i1][5];
	    const c2 = Cl[i2][5];
	    const c3 = filterOutRepeats([...c1, ...c2])
             
            // compute sum of squared distances
	    let [ssd1, bc1] = computeSumdis(l, c1);
	    let [ssd2, bc2] = computeSumdis(l, c2);
	    let [ssd3, bc3] = computeSumdis(l, c3); 

            // compute sum of inter-centroid squared distances
            ssd1 += (bc1[0] - P[0])**2 + (bc1[1] - P[1])**2; 
            ssd2 += (bc2[0] - P[0])**2 + (bc2[1] - P[1])**2; 
            ssd3 += (bc3[0] - P[0])**2 + (bc3[1] - P[1])**2; 

	    if (ssd3 > ssd1 + ssd2) return [[c1, c2], [ssd1, ssd2]]; 
	    else {                                   
		// kill former halves
	        killCluster(l, i1); killCluster(l, i2);	       
		// create new union
                //const C3 = spawnCluster(x = bc[0], y = bc[1], M = c3, Msd = ssd3); 
		//clusters[l].push(C3);		
                //let ei;                                                   // add to entities array
		//[ei, isnew] = findCompoundEntities(clusters[l].length-1, l).slice(1,3);
		breedCluster(l, bc3[0], bc3[1], c3);
                console.log(`merge ${++nmerges}`);
	        return [[c3], [ssd3]];
	    }
	}
        function splitMergeClusters() {
	    const N = settings.maxNumLiveClusters;
            for (let l = 1; l < clusters.length; l++) {
		if (numClus()[0][l] == 0) continue;
                if (numClus()[2] < N)     var sc = trySplitting1ClusterGreedily(l);
	        if (numClus()[0][l] > 1)  var mc = tryMerging2ClustersGreedily(l);
            }
        }
        
	function Mstep(l) {
            for (let i = 0; i < clusters[l].length; ++i) {
		const C = clusters[l][i];
		if (C.length == 1) continue;
                const nm = C[5].length;
                if (nm < minClustMembCount) continue;
	        let bcx = bcy = sdx = sdy = 0;
		for (let ci of C[5]) {
                    bcx += clusters[l-1][ci][0]; bcy += clusters[l-1][ci][1];
                } bcx /= nm; bcy /= nm; 
		for (let ci of C[5]) {
                    sdx += (clusters[l-1][ci][0] - bcx)**2; sdy += (clusters[l-1][ci][1] - bcy)**2;
                } sdx /= nm; sdy /= nm;
                C[0] = bcx; C[1] = bcy;
		C[2] = Math.sqrt(sdx + sdy);
            }
	}

        function sprinkleClusters() {
	    const N = settings.maxNumLiveClusters;

	    //if (clusters.length > 1 && clusters.slice(-1)[0].length == 0) clusters.pop();
            if (clusters.slice(-1)[0].length > 1) clusters.push([spawnCluster()]);

            if (numClus()[2] < N * .8) {
		do for (l of clusters.slice(1)) { 
	            for (c of l) if (c.length == 0) c = spawnCluster();
		    l.push(spawnCluster());
		} while (numClus()[2] < N);
            }
        }

        function kmFindNearestCluster(x, y, clus) {
            let nrstClus = -1;
            let nrstClus_d2 = 1.e38;
            for (let i = 0; i < clus.length; ++i) {
		if (clus[i][2] == 0.) continue;
                const dx = clus[i][0] - x, dy = clus[i][1] - y;
                const d2 = dx ** 2 + dy ** 2;
                if (d2 < nrstClus_d2) {
                    nrstClus = i;
                    nrstClus_d2 = d2;
                }
            }
            return [nrstClus, nrstClus_d2];
        }
        function kmTranslocateClusters(vc, clus) {
            let msd = 0.;   // maximum squared displacement
            for (let i = 0; i < clus.length; ++i) {
		if (clus[i].length == 1) continue;
                if (vc[i][0] >= minClustMembCount) {
                    const new_x = vc[i][1] / vc[i][0], new_y = vc[i][2] / vc[i][0];
                    msd = Math.max(msd, (clus[i][0] - new_x)**2, (clus[i][1] - new_y)**2);
                    clus[i][0] = new_x;                clus[i][1] = new_y;
                }
            }
            return msd;
        }
        function reshapeOrKill(vc, clus, l) {
            for (let i = 0; i < clus.length; ++i) {
                let c = clus[i], s = vc[i];
	        if (c.length == 1 || entities.length <= l) continue;
                if (c[5].length >= minClustMembCount) {
                    // reshape cluster
                    const new_r = Math.sqrt(s[3] / s[0]) + atomRadius;  // plus atom radius
                    c[2] = 0.95 * c[2] + 0.05 * new_r;  // reshape: exponential smoothing
		    let saturation = s[4][1] / s[0];
                    c[4] = [s[4][0] % 360, saturation, s[4][2] / s[0]];   // repaint
                    //const new_r = 1.10 * Math.sqrt(s[3] / s[0]);  // extra 10%
                    //c[4] = settings.colors[Math.floor(s[4] / s[0] + .5)]; // 'average' color

		    // kill orphaned ent objects
                    mulset = transcribeClusToEntMultiset(i, l);
                    let eis = findLiveClusterEntityIds(i, l);		   
	            if (eis === undefined || eis.length == 0) continue;
		    for (let ei of eis) {
		        let e = entities[l][ei];
                        if (mulset === undefined) {                 // no entity multiset match: members may have transformed 
                            e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];  // kill orphaned ent object and compute lifespan
		        } else if (!equalMultisets(e[0], mulset))   // if cluster c doesnt pertain anymore to e[0] but registered as alive ent object
                            e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];  // kill orphaned ent object and compute lifespan
			else {      // the entity multiset currently corresponding to c 
                            saturation = 100*(Date.now()-e[2][e[1].lastIndexOf(i)])/(Date.now()-starttime); 
                            c[4] = [s[4][0] % 360, saturation, s[4][2] / s[0]];   // repaint
			}
		    }

                } else {   // kill or recreate degenerate cluster
	            if (entities.length <= l) {          // not in census: abort and replace with last cluster
		        const last = clus.pop(); if (i < clus.length) clus[i] = last; 
			i--;
		    } else {                                    
			let iinent = false, linent = false;   // check if they are registered as ents
		        for (var e of entities[l]) {   
                            if (e[1].includes(i))             {iinent = true; break;} 
			    if (e[1].includes(clus.length-1)) linent = true; 
			}
			if (iinent) {  // in census                  
			    if (e[3][e[1].lastIndexOf(i)]==0) {     // if ALIVE
			        clus[i] = ["tomb"];                               // kill and make tomb
			        e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // lifespan
			    }                                 // if dead, do nothing                               
			} else {   //  not in census
			    if (linent) clus[i] = spawnCluster();         // abort cluster and create new cluster
			    else        {const last = clus.pop(); if (i < clus.length) clus[i] = last; --i} // abort and replace with last
                        }					    
                    }
                }
            }
        }
	function reallocateClusters(vc, clus, l) {
            for (let i = 0; i < clus.length; i++) {
		if (clus[i].length > 1 && !equalMultisets(clus[i][5], vc[i][5])) {  // if cluster members transform
		    clus[i][5] = vc[i][5];
 		    clus[i][6] = vc[i][6];
                
		    if (entities.length > l && entities[l].length > 0) {			    
		        for (let j = 0; j < entities[l].length; j++) {  
		            var e = entities[l][j];
                            if (e[1].includes(i) && e[3][e[1].lastIndexOf(i)]==0) break; // if registered and alive
		        }
                        e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)]; // remove ent record and write lifespan

					// maybe add here to new entity
		    }
		}
            }	
        }

	function findLiveClusterEntityIds(ci, l, ents = entities) { // find all level l entities with cluster ci
	    let ei = [];		    
	    if (ents.length <= l) return undefined;
	    for (let i = 0; i < ents[l].length; i++) 
	        if (ents[l][i][1].includes(ci) && ents[l][i][3][ents[l][i][1].lastIndexOf(ci)]==0) ei.push(i);
            return ei;
        }
        function reallocateReshapeKill(vc, clus, l) {
            for (let i = 0; i < clus.length; i++) {
                let c = clus[i], s = vc[i];
	        if (c.length == 1) continue;  // if cluster dead

		if (s[0] >= minClustMembCount) {  // reshape cluster, update parEnts
                    // reshape cluster
                    const new_r = Math.sqrt(s[3] / s[0]) + atomRadius;  // plus atom radius
                    c[2] = 0.95 * c[2] + 0.05 * new_r;  // reshape: exponential smoothing
		    let saturation = s[4][1] / s[0];
                    c[4] = [s[4][0] % 360, saturation, s[4][2] / s[0]];   // repaint
                    //const new_r = 1.10 * Math.sqrt(s[3] / s[0]);  // extra 10%
                    //c[4] = settings.colors[Math.floor(s[4] / s[0] + .5)]; // 'average' color

		    c[6] = s[6];
		    if (equalMultisets(c[5], s[5])) continue; // if cluster is unchanged
	            c[5] = s[5];		                 

		    // entity bookkeeping
		    if (entities.length <= l || entities[l].length == 0) continue;  // if ent is not up to date 
                    const eis = findLiveClusterEntityIds(i, l);

		    // kill orphaned parEnt objects
		    if (eis !== undefined && eis.length > 0) 
		        for (const ei of eis) { const e = entities[l][ei];   // ideally there should be one and only one
                            e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // kill orphaned ent object and compute lifespan
		        }

		    // find new matching parent
                    let ei = findCompoundEntities(i, l)[1]; // finds parent, registers it in clus[7], updates parent children
                        
		    if (ei !== undefined) { const e = entities[l][ei];
                        saturation = 100*(Date.now()-e[2][e[1].lastIndexOf(i)])/(Date.now()-starttime); 
                        c[4] = [s[4][0] % 360, saturation, s[4][2] / s[0]];   // repaint
		    }

                } else {   // kill or recreate degenerate cluster
	            if (entities.length <= l) {          // not in census: abort and replace with last cluster
		        const last = clus.pop(); if (i < clus.length) clus[i] = last; i--;
		    } else {                                    
			let iinent = false, linent = false;   // check if they are registered as ents
		        for (var e of entities[l]) {   
                            if (e[1].includes(i))             {iinent = true; break;} 
			    if (e[1].includes(clus.length-1)) linent = true; 
			}
			if (iinent) {  // in census                  
			    if (e[3][e[1].lastIndexOf(i)]==0) {     // if ALIVE
			        clus[i] = ["tomb"];                               // kill and make tomb
			        e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // lifespan
			    }                                 // if dead, do nothing                               
			} else {   //  not in census
			    if (linent) clus[i] = spawnCluster();         // abort cluster and create new cluster
			    else        {const last = clus.pop(); if (i < clus.length) clus[i] = last; --i} // abort and replace with last
                        }					    
                    }
                }
            }  
        }
	function kmeans(memb, clus, l) {
	    Mstep(l);
            const maxNumPasses = 10;
	    const vc = new Array(clusters.length).fill([]); // k-means' Voronoi cells
            for (let pass = maxNumPasses; pass >= 0; --pass) {
                for (let i=0; i < clus.length; ++i) vc[i] = [0, 0., 0., 0., [0, 0, 0], [], []];
                for (let i=0; i < memb.length; i++) {
                    let m = memb[i];
		    let [nrstClus, nrstClus_d2] = kmFindNearestCluster(m[0], m[1], clus);
                    if (nrstClus >= 0 && nrstClus_d2 < maxRadius[0] ** 2) {
                        vc[nrstClus][0] += 1;
                        vc[nrstClus][1] += m[0]; vc[nrstClus][2] += m[1];
                        vc[nrstClus][3] += nrstClus_d2;
 	                for (let v=0; v<3; v++) vc[nrstClus][4][v] += m[4][v];
 	                vc[nrstClus][5].push(i);
                        vc[nrstClus][6].push(nrstClus_d2);
                    }
		}
                const msd = kmTranslocateClusters(vc, clus);
		if (msd < 1.) break;
            }
	    //reallocateClusters(vc, clus, l); reshapeOrKill(vc, clus, l);
	    reallocateReshapeKill(vc, clus, l);
	}

	function ellipticalKmeans(memb, clus, l) {

	}    

        function trackClusters() {
	   // sprinkleClusters();

	    // allocate atoms to clusters[1]: kmeans(atoms, clusters[1]);
	    // allocate clusters[i] to clusters[i+1]
	    for (let l = 0; l < clusters.length - 1; l++) {
		kmeans(clusters[l], clusters[l+1], l+1);
	    }

	    splitMergeClusters();
        }

        function drawClusters(clus, l) {
            let i = 0;
            while (i < clus.length) { // clus.length is evaluated only once, at the start of the loop 
                let c = clus[i];
		if (c.length > 1 && c[2] > 0.) {
                    color = hsl2str(...c[4]);
		    lg = Math.PI * c[2] / c[5].length;
                    drawCircle(c[0], c[1], color, c[2], false, 2*l, [true, lg, lg]);
                } 
	        ++i; 
            }
        }


	/*** ENTITIES ***/

        // entities[l][i]: member ids, live cluster ids, birthtime, lifespan 	
   
	const equalSets = (x, y) => {
	    xs = new Set(x); ys = new Set(y);
	    return xs.size === ys.size && [...xs].every((xs) => ys.has(xs));
        }
        const subtractSets = (a, b) => {
	    bs = new Set(b);
	    return a.filter(item => !bs.has(item));
        }
	const equalArrays = (x, y) => x.length === y.length && x.every((val, ind) => val === y[ind]);
	const equalMultisets = (x, y) => {
	    x.sort((a, b) => a - b); y.sort((a, b) => a - b);
	    return equalArrays(x, y);
        }

        function filterOutRepeats(C) {
	    const onlyUnique = (value, index, array) => array.indexOf(value) === index;
            for (let i=0; i < C.length; i++) C = C.filter(onlyUnique);
	    return C;
        }

        function transcribeClusToEntMultiset(ci, l, ents = entities) {
	    // does not check for cluster id uniqueness 
	    let mulset = [];
	    for (let c of clusters[l][ci][5])
                for (let k = 0; k < ents[l-1].length; k++)
	            if (ents[l-1][k][1].includes(c) && ents[l-1][k][3][ents[l-1][k][1].lastIndexOf(c)]==0) 
		        mulset.push(k); 
             if (mulset.length != clusters[l][ci][5].length) return undefined;
	     else                                            return mulset;
	}
	function findAtomicEntities(ents) { 
	    if (ents.length == 0) ents[0] = [];
	    for (let j = 0; j < settings.numColors; j++) {
		if (ents[0].length-1 < j) ents[0].push([j, [], [], []]); 
                for (let i = 0; i < clusters[0].length; i++) 
		    if (clusters[0][i][5] == j && !ents[0][j][1].includes(i)) {
		        ents[0][j][1].push(i);
		        ents[0][j][2].push(Date.now());
		        ents[0][j][3].push(0);
			clusters[0][i][7] = j;
		    }
	    }
	    return ents;
	}
	function findCompoundEntities(ci, l, ents = entities) { 
	    // find entity with id ei in level l corresponding to cluster id ci; if absent, create entity and append
	    mulset = transcribeClusToEntMultiset(ci, l, ents);
            if (mulset === undefined) return [ents, undefined, false]; // bad for catching bugs
	    for (var ei = 0; ei < ents[l].length; ei++) { // loop2:
	        if (equalMultisets(mulset, ents[l][ei][0])) {      // if the multiset is already registered
	            if (!ents[l][ei][1].includes(ci) ||                                                  // cluster object not registered
	                (ents[l][ei][1].includes(ci) && ents[l][ei][3][ents[l][ei][1].lastIndexOf(ci)] > 0)) {    // cluster object registered but dead
	                ents[l][ei][1].push(ci);
	                ents[l][ei][2].push(Date.now());
	                ents[l][ei][3].push(0);
	                clusters[l][ci][7] = ei;
	            }   
	            return [ents, ei, false]; //ei=0; break; // continue loop2;   // cluster object registered and alive
	        }
	    }
	    if (ei == ents[l].length) {   // multiset not registered
	        ents[l].push([mulset, [ci], [Date.now()], [0]]);
	        clusters[l][ci][7] = ei;
	    } 
	    return [ents, ei, true];  // new entity created: true
	}
	function findEntitiesNow(ents = [[]]) { 
	    if (clusters.length == 0) return ents;

	    ents = findAtomicEntities(ents);

	    for (l = 1; l < clusters.length; l++) {	    
		if (ents.length == l && clusters[l].length > 0) ents.push([]);
	        for (let i = 0; i < clusters[l].length; i++) {   //loop2:
	            if (clusters[l][i].length < 2 || clusters[l][i][5].length < 2) continue; 
	            ents = findCompoundEntities(i, l, ents)[0];
		}
	    }
	    return ents;
        }

	function numEnts() {
	    let nl = [numAtomTypes], nd = [0];
	    for (l = 1; l < entities.length; l++) {	   
		nl[l] = 0; nd[l] = 0;
		for (let i = 0; i < entities[l].length; i++) {
		    if (!entities[l][i][3].includes(0)) nd[l]++;
		    else                                nl[l]++;
		}
	    }
	    return [nl, nd];
        }	

	    

	/*** PHYSICS ***/

        // Enact atomic interactions
        const stepForward = () => {
            const c = 10 ** settings.damping;
            const dt = 10 ** settings.logTimeStep;
            const n = settings.interaction_law;
            mav = 0.; msv = 0.;

            // update velocity 
            for (const a of atoms) {
                let Fx = 0, Fy = 0;
                const idx = a[5] * settings.numColors;
                const rang2 = settings.range[settings.colors[a[5]]]**2;
                for (const b of atoms) {
		    const g = settings.interactionForces[settings.colors[a[5]]][settings.colors[b[5]]];
		    let dx = a[0] - b[0], dy = a[1] - b[1];
	            if (settings.wraparound) {
		   	const dxpm = [dx-canv.width, dx, dx+canv.width], dypm = [dy-canv.height, dy, dy+canv.height];
                        const dxa = dxpm.map(Math.abs),                  dya = dypm.map(Math.abs);
			const dxi = dxpm.indexOf(Math.min(...dxa)),      dyi = dypm.indexOf(Math.min(...dya));
			dx = dxpm[dxi];			                 dy = dypm[dyi];							
 		    }
                    if (dx !== 0 || dy !== 0) {
                        const dr2 = dx ** 2 + dy ** 2;
                        if (dr2 < rang2) {
                            //const F = g / Math.sqrt(dr2);   // inverse law: n = -1
                            const F = g * Math.sqrt(dr2) ** n;    // inverse-square law: n = -2
                            Fx += F * dx; Fy += F * dy;

                            // draw lines between interacting atoms 
                            if (settings.drawings.forcelines) drawInteraction(a[0], a[1], b[0], b[1], settings.colors[b[5]]);                            
                        }
                    }
                }
                if (prod_st != 0) {
                    const dx = a[0] - prod_x, dy = a[1] - prod_y;
                    const dr2 = dx ** 2 + dy ** 2;
		    if (dr2 > 0 && dt > 0) {
                        const prodForce = 100. * prod_st / (dr2 * dt);  // inverse square law
                        Fx += prodForce * dx; Fy += prodForce * dy;
                    }
                }
                if (settings.wallThickness > 0) {
                  const wt = settings.wallThickness, we = settings.wallElasticity;
                  if (a[0] < wt)               Fx += (wt - a[0]) * we;
                  if (a[0] > canv.width - wt)  Fx += (canv.width - wt - a[0]) * we;
                  if (a[1] < wt)               Fy += (wt - a[1]) * we;
                  if (a[1] > canv.height - wt) Fy += (canv.height - wt - a[1]) * we;
                }

                Fy += settings.gravity;

		// dynamic equation with damping coefficient: dv/dt = -c*v  =>  v = exp(-c*t) ~ -c*t => v1-v0 ~ -c*(t1-t0) ~ -c*dt
                //a[2] -= c * a[2] * dt; a[3] -= c * a[3] * dt;  // the damping coefficient multiplies velocity
		// dynamic equation with drag coefficient: dv/dt = -c*v^2  => v = 1/(c*t) => v1-v0 ~ 1/c*(1/t1-1/t0) = (t0-t1)/(c*t0*t1) = -dt*c*v1*v0 ~ -dt*c*v1^2
		// drag coefficient (skin friction and form drag) depends on the Reynolds number for fluids
		if (Math.abs(c*a[2]*dt) >= 1) a[2] = 0; else a[2] -= c * a[2]**2 * dt * Math.sign(a[2]);
		if (Math.abs(c*a[3]*dt) >= 1) a[3] = 0; else a[3] -= c * a[3]**2 * dt * Math.sign(a[3]);
		
		// dp/dt = F
		a[2] += Fx * dt; a[3] += Fy * dt;

                // record typical activity, to later update logTimeStep accordingly
                mav += Math.abs(a[2]) + Math.abs(a[3]);
                msv += a[2]**2 + a[3]**2;
            }
            mav /= atoms.length;
            msv /= atoms.length;
	    cvNkT.push(msv);

            // update positions 
            for (const a of atoms) {
                // dr/dt = v 
                a[0] += a[2] * dt; a[1] += a[3] * dt;

                // upon reaching the canvas fringes
		if (!settings.wraparound) { // hard wall		
                    if (a[0] < 0)            {a[0] = -a[0] % canv.width;                     a[2] *= -1;} // x wraps around if ricochet exceeds width
                    if (a[0] >= canv.width)  {a[0] = (2 * canv.width - a[0]) % canv.width;   a[2] *= -1;} // x<0 and idem if ricochet exceeds width
                    if (a[1] < 0)            {a[1] = -a[1] % canv.height;                    a[3] *= -1;} // idem
                    if (a[1] >= canv.height) {a[1] = (2 * canv.height - a[1]) % canv.height; a[3] *= -1;} // idem
                } else {                            // wrap around with toroidal topology
		    settings.wallThickness = 0;
		    if (a[0] > canv.width)  a[0] %= canv.width;
		    else if (a[0] < 0)      a[0] = canv.width + a[0] % canv.width; //a[0] += canv.width;
		    if (a[1] > canv.height) a[1] %= canv.height;
		    else if (a[1] < 0)      a[1] = canv.height + a[1] % canv.height;
		}
            }
        };



	/*** LET THERE BE LIGHT ***/

	let starttime = Date.now();

        // Initialize PRNG seed 
        var mb32closure = mulberry32prng(settings.seed);  // closure PRNG initialized with seed
        getSeedFromUrlFragment();

	// Draw canvas
        const canv = document.getElementById("mycanvas");
        const crc = canv.getContext("2d");
        updateCanvas();      // stretch canvas to cover window and paint it

        // Set interaction forces
        setColors();
        randomInteractions();

        // Create atoms, initialize clusters and entities
        const atoms = new Array();
        const clusters = [], entities = [];
	let nsplits, nmerges;
        restartAtoms(settings.atoms.count, true);

	// Set up sundry functionalities  
        var prod_st = 0, prod_x = 0, prod_y = 0; // click-induced pulse-shaped in time and strength prod 
        var exploration_timer = 0;
        var mav, msv;  // mean absolute velocity as an estimate of on-screen activity, mean sq velocity
	const cvNkT = []; // energy
        setupGui();
        setupHotkeys();
        setupProd();
	// Plotting
        const plt = document.getElementById("fig01");
	plt.style.height = canv.height * 0.9;
        let layout = {grid: {rows:6, columns:1, roworder: "top to bottom"}, barmode: "overlay", 
	              title: "plotly", showlegend: true, margin: {l: 30, r: 10, b: 20, t: 20, pad: 5},
		      xaxis1: {anchor: "y1"}, xaxis2: {anchor: "y5"},  
		      xaxis6: {anchor: "y6", type: "linear", autorange: true}, yaxis6: {type: "log"}};


        /*** MOVE ONWARD: REFRESH AND READJUST ***/

        let oldnow = performance.now(); //Date.now();
        repaint();

	function repaint(timeStamp) {
            updateCanvas();
			
            stepForward();

            // draw atoms
            for (const a of atoms) {
                if (settings.drawings.round) drawCircle(a[0], a[1], hsl2str(...a[4]), settings.atoms.radius);
                else                         drawSquare(a[0], a[1], hsl2str(...a[4]), settings.atoms.radius);                
            }
            if (settings.drawings.clusters) {
	        trackClusters();

	        // draw clusters
                for (let i = 1; i < clusters.length; i++) drawClusters(clusters[i], i);

	        // discover entities
	        if (entities.length < clusters.length) findEntitiesNow(entities);
		else for (const e of entities) if (e.length==0) {findEntitiesNow(entities); break;}
            }

            readjust(timeStamp);

	    plots();

	    // Tally atoms within canvas
            //const inSight = (a) => 0 <= a[0] && a[0] < canv.width && 0 <= a[1] && a[1] < canv.height;
            //console.log('atoms in sight', atoms.filter(inSight).length);  

            window.requestAnimationFrame(repaint);
        };

        // post-frame stats and readjustments
        function readjust(timeStamp) {
            // record fps
            if (timeStamp > oldnow) {
                const new_fps = 1000. / (timeStamp - oldnow);
                settings.fps = Math.round(settings.fps * 0.8 + new_fps * 0.2)
                oldnow = timeStamp;
            }

            // adapt logTimeStep based on activity
	    let dt = 10 ** settings.logTimeStep;
            if (mav > 30. && dt > 5.) dt /= 1.1;
            if (dt < 0.9) dt *= 1.01; else if (dt > 1.1) dt /= 1.01;
	    settings.logTimeStep = Math.log10(dt);

	    // decrease prod duration if positive 
            if (prod_st != 0) prod_st -= (prod_st > 0) ? 1 : -1;

            if (settings.explore) roamParamspace();
        }


	/*** PRINT STATS ***/ 

        function numAtomsNow() {return settings.atoms.count * settings.colors.length;}    
        function numClus() {
	    let nl = [], nd = [], sl = 0, sd = 0;
	    if (clusters.length>1) for (l = 1; l < clusters.length; l++) {
		nl[l] = 0; nd[l] = 0;
	        for (c of clusters[l]) (c.length > 1) ? nl[l]++ : nd[l]++;
		sl += nl[l]; sd += nd[l];
	    }
	    return [nl, nd, sl, sd];
	}
	function sumSqdisNow() { 
	    let ssd = new Array(clusters.length).fill(0);
	    for (let l=1; l < clusters.length; l++)
	        for (const c of clusters[l]) if (c.length > 1 && c[6].length!=0)
	            for (const d of c[6]) ssd[l] += d;
            return ssd;			    
	}
	function topbotSqdistsNow() { 
	    let sumsqdis = 0;
	    if (clusters.length == 0) return sumsqdis;
	    topclus = clusters.slice(-1)[0][0];
	    if (clusters.slice(-1)[0].length==1 && topclus != undefined) {
	        for (let a of atoms){
		    let d2 = (a[0] - topclus[0])**2 + (a[1] - topclus[1])**2;
	            sumsqdis += d2;
	        }
	    }
            return sumsqdis;			    
	}
        
        function biggestClus() {
            let c = [], numemb = [];  	    
	    for (let l = 1; l < clusters.length; l++) {
		[c[l], numemb[l]] = [0, 0];
	        for (let j = 0; j < clusters[l].length; j++) 
		    if (clusters[l][j].length > 1  && clusters[l][j][5].length > numemb[l]) 
		        {c[l] = j; numemb[l] = clusters[l][j][5].length;}
	    }
	    return numemb // [...c, ...numemb]
        }

        function lifespans() {
	    let s = [];
	    for (l = 1; l < entities.length; l++) {
		s[l] = [];
	        for (e of entities[l]) 
		    for (i=0; i< e[1].length; i++) 
			if (e[3][i] > 0) s[l].push(e[3][i]/10**3); else s[l].push((Date.now() - e[2][i])/10**3);
	    }
            return s; 
	}
	
        console.log("settings", settings)

	let numclus = 0; 
        window.setInterval(() => {
            if (numClus()[2] != numclus) {
		console.log(clusters);
		console.log('Number of atoms, maxClus, clusters:', numAtomsNow(), settings.maxNumLiveClusters, numClus())
	        let ssd = sumSqdisNow().map((x) => Math.round(x));
	        let totdis = Math.round(ssd.reduce((a,b)=>a+b,0));
		console.log("SSDs: ", ssd, totdis, totdis/numAtomsNow(), Math.round(100*totdis/topbotSqdistsNow()))
		console.log("Biggest clusters: ",biggestClus())
		numclus = numClus()[2];
	    }
	    //if (numDeadClusNow()>0) alert(`${numDeadClusNow()} cluster(s) died`);
	}, 1000);


        /*** PLOTTING ***/

	function vlog10(x) {return x.map((el) => Math.log10(el))};
	function vllog10(x) {return x.map((el) => Math.log10(el.length))};
	function plots() {
	    let cl = Array(clusters.length).fill().map((elm, ind) => ind);
	    let ts = Array(cvNkT.length).fill().map((elm, ind) => ind);
	    let trace0 = {name: "MSV", x: ts, y: vlog10(cvNkT), xaxis: "x1", yaxis: "y1"};
	    let trace1 = {name: "SSD", x: cl, y: vlog10(sumSqdisNow()), xaxis: "x2", yaxis: "y2", type: "scatter"};
	    let trace2 = {name: "bigclus",x: cl, y: vlog10(biggestClus()), xaxis: "x2", yaxis: "y3"};
	    let trace3 = {name: "live ents", x: cl, y: vlog10(numEnts()[0]), xaxis: "x2", yaxis: "y4"};
	    let trace4 = {name: "dead ents", x: cl, y: vlog10(numEnts()[1]), xaxis: "x2", yaxis: "y4"};
	    let trace5 = {name: "all ents now", x: cl, y: vllog10(findEntitiesNow()), xaxis: "x2", yaxis: "y4"};
	    let trace6 = {name: "live clus", x: cl, y: vlog10(numClus()[0]), xaxis: "x2", yaxis: "y5"};
	    let trace7 = {name: "dead clus", x: cl, y: vlog10(numClus()[1]), xaxis: "x2", yaxis: "y5"};

	    let tracehist = [];
	    for (let i=1; i < entities.length; i++) 
	    tracehist[i-1] = {name: `count L${i}`, x: lifespans()[i], type: 'histogram', histfunc: "count", opacity: .4, xaxis: "x6", yaxis: "y6"};
	    Plotly.newPlot(plt, [trace0, trace1, trace2, trace3, trace4, trace5, trace6, trace7, ...tracehist], layout); 
        }


        /*** RECORD VIDEO ***/ 

        function dataUrlDownloader(dataURL, name = `Racemi_${settings.seed}`) {
            const hyperlink = document.createElement("a");
            // document.body.appendChild(hyperlink);
            hyperlink.download = name; // the target will be downloaded on clicking on the hyperlink
            //hyperlink.target = '_blank';
            hyperlink.href = dataURL;
            hyperlink.click();  // HTMLElement.click() method simulates a mouse click on an element
            hyperlink.remove();
        };

        const videoStream = canv.captureStream(); // stream 
        const mediaRecorder = new MediaRecorder(videoStream); // video recorder
        let chunks = []; // temporal chunks

        mediaRecorder.ondataavailable = (e) => chunks.push(e.data); // store chunks
        mediaRecorder.onstop = function (e) {
            const blob = new Blob(chunks, { 'type': 'video/mp4' }); // chunks --> blob
            const videoDataURL = URL.createObjectURL(blob); // blob --> dataURL
            dataUrlDownloader(videoDataURL); // download video
            chunks = []; // reset chunks
        };
        // mediaRecorder.start(); // start recording
        // mediaRecorder.stop(); // stop recording


    </script>

</body>

</html>
