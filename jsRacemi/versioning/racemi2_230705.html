<html>
<title>Racemi in 2D</title>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            color-scheme: dark;
            --canvas-bg-color: rgba(0, 0, 0, 0); /* transparent */
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #mycanvas {
            border: hsl(0 0% 30%);/*  #999999; #504e52 */
            border-style: solid; /* ridge, dashed */
            border-width: 5;
            outline: none;  /* because of the 'tabindex' focus trick */
            background-color: var(--canvas-bg-color);  
        }
    </style>

    <!-- lilgui -->
    <!--script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script-->
    <script src="lilgui.js"></script>
    
    <!-- Plotly -->
    <!--script src="https://cdn.plot.ly/plotly-2.20.0.min.js" charset="utf-8"></script-->
    <script src="plotly-2.20.0.min.js" charset="utf-8"></script>

    <!-- SVD-JS -->
    <!--script src="https://unpkg.com/svd-js" type="application/javascript"></script-->
    <script src="svd-js.js" ></script>
    <!--script src="svd.js" type="module"></script-->

    <!-- math.js -->
    <script src="math.js" type="text/javascript"></script>

</head>

<body>
    <!-- 'tabindex' is a trick to make the canvas capture key events -->
    <canvas id="mycanvas" tabindex="1"></canvas>
    
    <div id="fig01" style="width:600px;height:600px;"></div>

    <script>
	console.log(document.getElementById("mycanvas"));

	// Parameter initialization
	const nd = 2;
        const numAtomTypes = 4;
        const numAtoms = 60;
        const atomRadius = 4;
	const interactionRange = 80;
        const minClusMembCount = 2;
	const maxNumLiveClusters = numAtoms * (1/(1 - 1/5) - 1); // 2->1, 4->1/3, 5->1/4,
        const irrdisn = 1 - nd;                     // attraction force irradiance to distance power law: I ~ d^(irrdisn)
        const maxRange = 2000;
        const palette = ['red', 'green', 'cyan', 'teal', 'lavender', 'yellow', 'blue', 'magenta'];
        const wallElasticity = .5; //0.1;
	const dampCoef = .07; //0.7;

        const settings = {
            seed: 91651088029,
            fps: 0,
            atoms: {
                count: numAtoms / numAtomTypes,  // per color
                radius: atomRadius,
            },
            drawings: {  // drawing options can be expensive on performance
                forcelines: false,    // central force lines between interacting atoms 
                round: false,         // draw round atoms 
                clusters: false,
                background_color: '#00000000', 
            },
            explore: false,
            explorationPeriod: 100,
            logTimeStep: 0,
            interactionForces: {},
            range: {},
            colors: [],
            numColors: numAtomTypes,
            maxNumLiveClusters: maxNumLiveClusters,
            interaction_law: irrdisn, 
            damping: Math.log10(dampCoef),  // speed-dampening (can be >1 !)
            gravity: 0.0,  // pulling downward
            prodStrengthAndDuration: 10,
	    wraparound: false,
            wallThickness: 40,
            wallElasticity: wallElasticity,
	    reset: () => restartAtoms(settings.atoms.count, true),
            randomInteractions: () => {
                settings.seed += 0x6D2B79F5;  // change seed
                resetWorld();
            },
            symmetrizeInteractions: () => {
                symmetrizeInteractions();
                restartAtoms(settings.atoms.count, true);
                updateGuiDisplay();
            },
            gui: null,
            export: {     
                image: () => {   // screenshot image
                    const imageDataURL = canv.toDataURL({format: 'png', quality: 1});
                    dataUrlDownloader(imageDataURL);
                },
                video: () => mediaRecorder.state == 'recording' ? mediaRecorder.stop() : mediaRecorder.start(), // video recording
            },
        }


        /*** SET UP GUI ***/

        const setupProd = () => {
            canv.addEventListener('click', (me) => {prod_st = settings.prodStrengthAndDuration;   // MouseEvent
                                                    if (me.shiftKey) prod_st = -prod_st;        // if shiftKey then attract
                                                    prod_x = me.clientX; prod_y = me.clientY;
				                    console.log(`coordinates: ${prod_x}, ${prod_y}`);
            })
        }

        function setupHotkeys() {
	    canv.addEventListener('keydown', (ke) => {  // KeyboardEvent
                console.log(ke.key);
                switch (ke.key) {
                    case 'r': settings.randomInteractions();                            break;
                    case 'c': settings.drawings.clusters = !settings.drawings.clusters; break;
                    case ' ': settings.reset();                                         break;
                    case 's': settings.symmetrizeInteractions();                        break;
                    default: ;
                };
            })
            let titl = document.getElementsByClassName("title")[0]; // document..querySelector('div.title[tabindex="0"]')
            canv.addEventListener("keydown", (ke) => {
                const aeb = JSON.parse(titl.getAttribute("aria-expanded")); 		
		if (ke.key=="t") {
		    titl.setAttribute("aria-expanded", (!aeb).toString()); 
		    if (gui._closed) gui.open(); else gui.close();
		}
 	    }); 
        }

        const updateGuiDisplay = () => {
            console.log('gui', gui);
            gui.destroy();
            setupGui();
        }

        Object.defineProperty(String.prototype, 'capitalize', {
	    value: function() {return this.charAt(0).toUpperCase() + this.slice(1)},
            enumerable: false
        })

        const setupGui = () => {
            gui = new lil.GUI()
	    gui.title("Controls (t)");		    

            // Physics
            const configFolder = gui.addFolder('Physics')
            configFolder.add(settings, 'reset').name('Reset ( )')
            configFolder.add(settings, 'randomInteractions').name('Random interactions (r)')
            configFolder.add(settings, 'symmetrizeInteractions').name('Symmetrize interactions (s)')
	    configFolder.add(settings, 'numColors', 1, 7, 1).name('Number of colors').listen().onFinishChange(v => {setColors(); resetWorld();})
            configFolder.add(settings.atoms, 'count', 1, numAtomsNow()/numAtomTypes*2, 1).name('Atoms per color').listen().onFinishChange(v => restartAtoms(v, true))
            configFolder.add(settings, 'maxNumLiveClusters', 1, numAtomsNow(), 1).name('Max. num. of clusters').listen()
            configFolder.add(settings, 'interaction_law', -3, 3, 0.001).name('Interaction law').listen()
            configFolder.add(settings, 'damping', -9, 2, .1).name('Log10 damping').listen()
            configFolder.add(settings, 'gravity', 0., 1., 0.05).name('Gravity').listen()
            configFolder.add(settings, 'prodStrengthAndDuration', 1, 100, 1).name('Prod strength and duration').listen()
            configFolder.add(settings, 'wraparound').name('Wrap around').listen()
            configFolder.add(settings, 'wallThickness', 0, 500, 1).name('Wall thickness').listen()
            configFolder.add(settings, 'wallElasticity', 0, 10, .01).name('Wall elasticity').listen()
            configFolder.add(settings, 'fps').name('fps').listen().disable()
            configFolder.add(settings, 'logTimeStep', -2, 1, .1).name('Log10 time step').listen()
            configFolder.add(settings, 'explore').name('Parameter exploration').listen()
            configFolder.add(settings, 'seed').name('Seed').listen().onFinishChange(v => resetWorld())

            // Drawings
            const drawingsFolder = gui.addFolder('Drawings')
            drawingsFolder.add(settings.atoms, 'radius', 1, 10, 0.5).name('Atom radius').listen()
            drawingsFolder.add(settings.drawings, 'round').name('Round atoms').listen()
            drawingsFolder.add(settings.drawings, 'clusters').name('Track clusters (c)').listen()
            drawingsFolder.add(settings.drawings, 'forcelines').name('Central force lines').listen()
            drawingsFolder.addColor(settings.drawings, 'background_color').name('Background color').listen()

            // Color interactions
            for (const atomColor of settings.colors) {
                const colorFolder =
                    gui.addFolder(`Rules: <font color=\'${atomColor}\'>${atomColor.capitalize()}</font>`)
                for (const ruleColor of settings.colors) {
                    colorFolder.add(settings.interactionForces[atomColor], ruleColor, -1, 1, 0.001)
                         .name(`<-> <font color=\'${ruleColor}\'>${ruleColor.capitalize()}</font>`).listen()
                }
                colorFolder.add(settings.range, atomColor, 1, maxRange, 5).name('Radius').listen()
            }

            // Export
            const exportFolder = gui.addFolder('Export')
            exportFolder.add(settings.export, 'image').name('Image')
            exportFolder.add(settings.export, 'video').name('Video: Start / Stop')

        }


        /*** PRNG ***/

        // Pseudorandom number generator
        // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
        function mulberry32prng(seed) {
            return function() {
	        var t = seed += 0x6D2B79F5;
		t = Math.imul(t ^ t >>> 15, t | 1);
	        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
	        return ((t ^ t >>> 14) >>> 0) / 4294967296;
	    }
	}

        function getSeedFromUrlFragment() { 
            let hash = window.location.hash;  // fragment identifier of the URL
            if (hash != undefined && hash[0] == '#') {
                let urlfi = Number(hash.substr(1)); // remove the leading '#'
                if (isFinite(urlfi)) {
                    settings.seed = urlfi;
                    console.log("Using from the URL fragment the seed " + settings.seed);
                }
            }
        }

        // Random integer: the maximum and minimum are inclusive
	const randint = (min, max) => Math.floor(Math.random() * (max + 1 - min) + min);


	/*** UTILS ***/

	const equalSets = (x, y) => {
	    xs = new Set(x); ys = new Set(y);
	    return xs.size === ys.size && [...xs].every((xs) => ys.has(xs));
        }
        const subtractSets = (a, b) => {
	    bs = new Set(b);
	    return a.filter(item => !bs.has(item));
        }
        const intersectSets = (a, b) => {
	    as = new Set(b);
	    bs = new Set(a);
	    return [...as].filter(item => bs.has(item));
        }
	const equalArrays = (x, y) => x.length === y.length && x.every((val, ind) => val === y[ind]);
	const equalMultisets = (x, y) => {
	    x.sort((a, b) => a - b); y.sort((a, b) => a - b);
	    return equalArrays(x, y);
        }

        function filterOutRepeats(C) {
	    const onlyUnique = (value, index, array) => array.indexOf(value) === index;
            for (let i=0; i < C.length; i++) C = C.filter(onlyUnique);
	    return C;
        }

	const argmax = a => a.reduce((accum, val, ind, arr) => val > arr[accum] ? ind : accum, 0);
        const argmax12 = (a) => {
            let first = -Infinity, second = -Infinity, i1, i2;
	    for (let i = 0; i < a.length; i++) {
                if (a[i] > first) {
                    [second, first] = [first, a[i]];     // save previous max
		    [i2, i1] = [i1, i];		    
                } else if (a[i] < first && a[i] > second) {
                    second = a[i];                  // new second biggest
		    i2 = i;
                }
            }
            return [[first, second], [i1, i2]];
        }
	const sumArray = a => {return a.length > 1 ? a.reduce((acc, val) => acc + val, 0) : a};
	const zipTwoArrays = (a, b) => a.map((val, ind) => [val, b[ind]]);
	const zipSumTwoArrays = (a, b) => a.map((val, ind) => val + b[ind]);

	function matMult(a, b) {
	    var aNumRows = a.length, aNumCols = a[0].length, bNumRows = b.length, bNumCols = b[0].length, m = new Array(aNumRows);  // initialize array of rows
	    for (var r = 0; r < aNumRows; ++r) {
	        m[r] = new Array(bNumCols); // initialize the current row
	        for (var c = 0; c < bNumCols; ++c) {
	            m[r][c] = 0;             // initialize the current cell
	            for (var i = 0; i < aNumCols; ++i) 
		        m[r][c] += a[r][i] * b[i][c];
	        }
	    }
	    return m;
	}
	function matDisp(m) {
	    for (var r = 0; r < m.length; ++r) 
	        document.write('&nbsp;&nbsp;'+m[r].join(' ')+'<br />');
	}
	function mahalanobisInnerProd(x, C, y) {
	    if (y === undefined) y = x; //math.transpose(x);
	    const P = math.inv(C);
	    return math.multiply(y, P, x); // math.dot(y, math.multiply(P, x)); 
        }

        function nlgc(C) { // negative log-Gaussian function constant term, like variational Laplace mode prior
	    // C: Gaussian covariance
	    return 1/2 * math.log(math.det(math.multiply(2*math.pi, C)));

        }

	/*** ATOMS AND FORCES ***/    

        // atom = [x, y, vx, vy, hsl, id]

        // Initiate random locations for atoms 
        function randomX() {return mb32closure() * (canv.width - 100) + 50;}
        function randomY() {return mb32closure() * (canv.height - 100) + 50;}
        function createAtoms(n) {
            for (let i = 0; i < settings.colors.length; i++) 
	        for (let j = 0; j < n; j++) 
	            atoms.push([randomX(), randomY(), 0, 0, rgb2hsl(...colstr2rgb(settings.colors[i])), i]);
        };

        function restartAtoms(numPerColor, erase_past = true) {
	    if (erase_past) {
		atoms.length = 0;
                clusters.length = 0;  entities.length = 0; 
	        starttime = Date.now();
	    }
            createAtoms(numPerColor);
            clusters[0] = atoms;	    
	    clusters.push([spawnCluster()]); // initialize top/universe cluster
	    nsplits = nmerges = 0;
        }

        function randomInteractions() {
            for (const i of settings.colors) {
                settings.interactionForces[i] = {};
                for (const j of settings.colors) settings.interactionForces[i][j] = mb32closure() * 2 - 1; // range [-1 1]
                settings.range[i] = interactionRange;
            }
            if (!isFinite(settings.seed)) settings.seed = 0xcafecafe;
            window.location.hash = "#" + settings.seed;
            document.title = "Racemi2D #" + settings.seed;
            console.log("Seed=" + settings.seed);
            console.log(JSON.stringify(settings.interactionForces));
        }

        function symmetrizeInteractions() {
            for (const i of settings.colors) 
                for (const j of settings.colors) 
                    if (j < i) {
                        let v = 0.5 * (settings.interactionForces[i][j] + settings.interactionForces[j][i]);
                        settings.interactionForces[i][j] = settings.interactionForces[j][i] = v;
                    }
            console.log(JSON.stringify(settings.interactionForces));
        }

        function resetWorld() {
            randomInteractions();
            restartAtoms(settings.atoms.count, true);
            updateGuiDisplay();
        }

        function setColors() {
            settings.colors = [];
            for (let i = 0; i < settings.numColors; ++i) settings.colors.push(palette[i]);
        }

        function roamParamspace() {
            if (exploration_timer <= 0) {
                let c1 = settings.colors[Math.floor(mb32closure() * settings.numColors)]; //random color 1
                if (mb32closure() >= 0.2) {  // 80% chance of changing the strength
                    let c2 = settings.colors[Math.floor(mb32closure() * settings.numColors)];
                    let new_strength = mb32closure();
                    if (settings.interactionForces[c1][c2] > 0) new_strength *= -1; // enforce anti-signed interactions for appeal
                    settings.interactionForces[c1][c2] = new_strength;
                } else {                     // 20% for the range
                    settings.range[c1] = 1 + Math.floor(mb32closure() * maxRange);
                }
                exploration_timer = settings.explorationPeriod; // in frames, so in seconds it's EP/FPS ~ 100/20 = 5
            } else exploration_timer -= 1;
        }


	 /*** DISPLAY AND DRAWING ***/   

        function updateCanvas() {
            canv.width = window.innerWidth * 0.8;
            canv.height = window.innerHeight * 0.95;
            crc.fillStyle = settings.drawings.background_color;  
            crc.fillRect(0, 0, canv.width, canv.height); // bg color
        }

        function colstr2rgb(str) {
            const a = document.createElement('div');
            a.style.color = str;
            const colors = window.getComputedStyle( document.body.appendChild(a) ).color.match(/\d+/g).map(function(a){ return parseInt(a,10); });
            document.body.removeChild(a);
	    return (colors.length>=3) ? colors : false;
        };
	function rgb2hsl(r, g, b) {
	    r /= 255; g /= 255; b /= 255;
	    let cmin = Math.min(r,g,b), cmax = Math.max(r,g,b), delta = cmax - cmin, h = 0, s = 0, l = 0;
	    // hue
	    if (delta == 0) h = 0;
            else if (cmax == r) h = ((g - b) / delta) % 6;
	    else if (cmax == g) h = (b - r) / delta + 2;
	    else                h = (r - g) / delta + 4;
	    h = Math.round(h * 60);
	    if (h < 0) h += 360;
            // lightness
	    const l1 = (cmax + cmin) / 2;  
	    l = +(l1 * 100).toFixed(1);
            // saturation
	    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l1 - 1)); 
	    s = +(s * 100).toFixed(1);
	    return [h, s, l] 
	}	
        hsl2str = (h,s,l) => "hsl(" + h + "," + s + "%," + l + "%)";

	hslColor = (h, s, l, a = 1) => {`hsl(${h},${s}%,${l}%,${a})`};

        // Draw a square
        const drawSquare = (x, y, radius, color) => {
            crc.fillStyle = color;
            crc.fillRect(x - radius, y - radius, 2 * radius, 2 * radius);
        }

        // Draw an ellipse
        function drawEllipse(x, y, r, color, fill = true, lw = 1, dash = [false, 10, 10]) {
	    crc.lineWidth = lw;	    
	    if (dash[0]) crc.setLineDash(dash.slice(1,3)); 
            crc.beginPath();
	    if (typeof r == "number" || r.length < 3) 
	        crc.arc(x, y, r, 0 * Math.PI, 2 * Math.PI);  // x, y, radius, ArcStart, ArcEnd
	    else if (r.constructor === Array) {
		[sma1, sma2, tanphi] = r;
		crc.ellipse(x, y, sma1, sma2, Math.atan(tanphi), 0, 2*Math.PI); 
	    }
            crc.closePath();
            crc.strokeStyle = color;
	    crc.fillStyle = color;
            fill ? crc.fill() : crc.stroke()
        };

        // Draw line between atoms
        function drawInteraction(ax, ay, bx, by, color) {
            crc.beginPath();
            crc.moveTo(ax, ay);
            crc.lineTo(bx, by);
            crc.closePath();
            crc.strokeStyle = color;
            crc.stroke();
        };


	/*** CLUSTERS ***/    

        // clusters:     [position-x, position-y, sma1, sma2, hslcolor, members, memb2cntr_sqdis, entid]
        // Voronoi cell: [count, accum-x, accum-y, accum-d^2, accum-hslcolor, members, member_sqdis]

	function spawnCluster(x = randomX(), y = randomY(), sma1 = maxRange, sma2, tanphi = 0, hslcolor, M = [], Msd = [], ei) {
            if (sma2 === undefined) sma2 = sma1;
            if (hslcolor === undefined) hslcolor = rgb2hsl(...colstr2rgb('white')); 
            return [x, y, sma1, [sma2, tanphi], hslcolor, M, Msd, ei];
        }
	function breedCluster(l, x, y, M, sma1 = settings.atoms.radius, sma2 = settings.atoms.radius, tanphi = 0) {
            const C = spawnCluster(x, y, sma1, sma2, tanphi, undefined, M); 
	    clusters[l].push(C);		
   //if (entities.length > 0) [ei, isnew] = findCompoundEntities(clusters[l].length-1, l);
   // [ei, isnew] = findCompoundEntities(clusters[l].length-1, l);
//	    clusters[l][clusters[l].length-1][7] = ei;
	    return clusters[l].length - 1;
	}
        function killCluster(l, ci) {
  //if (entities.length > 0) {
//	        const ei = findLiveClusterEntityIds(ci, l);
//if (ei.length != 1 || ei[0] != clusters[l][ci][7]) debugger;
//                const E = entities[l][clusters[l][ci][7]];
                // entity: register lifespan
//	        E[3][E[1].lastIndexOf(ci)] = Date.now() - E[2][E[1].lastIndexOf(ci)];   
  //  }
	    // cluster: kill and make tomb
	    clusters[l][ci] = ["tomb"]; 
        }
	function graftIntoParentCluster(l, ci, pi, mip) {
	    let P = clusters[l+1][pi];
if (P[5].includes(ci)) debugger
	    P[5].push(ci);
	    P[6].push(mip);
        }
        function pruneParentCluster(l, ci, pi) {		    
  if (pi === undefined) pi = findParentClusterId(l, ci);
  else if (pi !== findParentClusterId(l, ci)) debugger;

	    if (pi !== false) {
	        let P = clusters[l+1][pi];
		const pci = P[5].indexOf(ci);

if (pci == -1) debugger 

		P[5].splice(pci, 1);
		P[6].splice(pci, 1);
	    } else debugger;
	    return pi;
	}
        function findParentClusterId(l, ci) {
	    if (l+1 < clusters.length && clusters[l+1].length > 0) {
	        for (let i = 0; i < clusters[l+1].length; i++)
		    if (isClusLive(l+1, i) && clusters[l+1][i][5].includes(ci)) return i;
	        return false;
	    } else return false;
	}
	function isClusLive(l, ci) {
	    return clusters[l][ci].length > 1;
	}
	function findLiveClusterEntityIds(ci, l, ents = entities) { // find all level l entities with cluster ci
	    let ei = [];		    
//	    if (ents.length <= l) return undefined;
	    for (let i = 0; i < ents[l].length; i++) 
	        if (ents[l][i][1].includes(ci) && ents[l][i][3][ents[l][i][1].lastIndexOf(ci)]==0) 
		    ei.push(i);
            return ei;
        }
	function getMemberCoordinates(l, C) {
	    const nm = C.length;
	    const Bl = clusters[l-1]; // cluster level below
            let X = [], Y = [], barycenter = [0, 0];
	    for (let m of C) {
		X.push(Bl[m][0]); Y.push(Bl[m][1]);
		barycenter[0] += Bl[m][0]; barycenter[1] += Bl[m][1];
	    } barycenter[0] /= nm; barycenter[1] /= nm;
	    return [[X, Y], barycenter]; 
	}
	function computeSumSqdis(l, C, V, d = 2) {
	    const Bl = clusters[l-1];
	    const nm = C.length;
            let barycenter = [0, 0], ssd = 0;;
	    for (let m of C) {
		barycenter[0] += Bl[m][0]; barycenter[1] += Bl[m][1];
	    } barycenter[0] /= nm; barycenter[1] /= nm;
	    for (let m of C) {
		switch (d) {
		    case false:
			// skip ssd computation
		    case 2:
			if (V === undefined)
			    ssd += (Bl[m][0] - barycenter[0])**2 + (Bl[m][1] - barycenter[1])**2;
			else
			    ssd += mahalanobisInnerProd([Bl[m][0] - barycenter[0], Bl[m][1] - barycenter[1]], V);
		    default: 
		        ssd += Math.abs(Bl[m][0] - barycenter[0])**d + Math.abs(Bl[m][1] - barycenter[1])**d;
		}
	    }
	    return [ssd, barycenter];
	}

        function trySplitting1ClusterGreedily(l) { // Similar to bisecting k-means
	    const Cl = clusters[l];
	    let ci0, C, pi, P;
	    
	    // randomly pick ci0
	    do {ci0 = randint(0, Cl.length-1); C = Cl[ci0];} while (C.length == 1); 
	    const nm = C[5].length; 
	    if (nm < 2 * minClusMembCount) return false;

            // randomly partition C: n-subset of C, with 2 <= n <= Csize-2
            const n = randint(2, nm-2);  // disallow clusters of size less than 2
	    let mi = [];
	    let H1 = [], H2 = []
	    while (H1.length != n) {
	       const ri = randint(0, nm-1);
	       for (var j = 0; j < mi.length; j++) if (mi[j] == ri) break;
	       if (j == mi.length) {mi.push(ri); H1.push(C[5][ri]);}
	    }
            H2 = subtractSets(C[5], H1);


// perhaps orphans are not well computed
for (let m of H1) if (H2.includes(m)) debugger;

            // compute sum of intercluster squared/mahalanobis distances
            const V0 = rebuildCovmat(C);  // V0 = [[1, 0], [0, 1]];
	    const [X1, bc1] = getMemberCoordinates(l, H1); 
	    const [X2, bc2] = getMemberCoordinates(l, H2); 
            const [majsv1, minsv1, tanphi1, D1] = svd(X1, bc1).slice(0, 4);
            const [majsv2, minsv2, tanphi2, D2] = svd(X2, bc2).slice(0, 4);
	    //   M = U * S * Vt,  (V is transposed);    Mt * M = V * St*S * Vt
	    const V1 = math.multiply(D1.v, math.diag([majsv1**2, minsv1**2]), math.transpose(D1.v)); // var-cov matrices hold squared distances
	    const V2 = math.multiply(D2.v, math.diag([majsv2**2, minsv2**2]), math.transpose(D2.v));
	    let [ssd0, bc0] = computeSumSqdis(l, C[5], V0); // C[6].reduce((a,b)=>a+b,0);
	    let ssd1 = computeSumSqdis(l, H1, V1, d=2)[0];
	    let ssd2 = computeSumSqdis(l, H2, V2, 2)[0]; 

	    // add neglog of normalization constant
	    ssd0 += nlgc(V0);
	    ssd1 += nlgc(V1);
	    ssd2 += nlgc(V2);

	    if (l < clusters.length-1) {       
	        pi = findParentClusterId(l, ci0);          // find parent cluster, use its coordinates 
//       if (pi === false)  return undefined;
//	else                P = clusters[l+1][pi]; 
if (pi === false) debugger;
   P = clusters[l+1][pi]; 
            } else if (l == topLiveClusLev()) { // there should be only one top cluster:   && (clusters[l].length == 1)  
                // potential new top cluster for l+1
	        const XP = math.transpose([bc1, bc2]); 
	        const bcP = math.mean([bc1, bc2], 0);
                const [majsvP, minsvP, tanphiP, DP] = svd(XP, bcP).slice(0, 4);
               	P = spawnCluster(x = bcP[0], y = bcP[1], sma1 = majsvP, sma2 = minsvP, tanphi = tanphiP); 
	    }

            // compute sum of inter-centroid Mahalanobis squared distances
            const VP = rebuildCovmat(P);  
            ssd0 += mahalanobisInnerProd([C[0] - P[0], C[1] - P[1]], VP);  // 0 if new top cluster 
            const mip1 = mahalanobisInnerProd([bc1[0] - P[0], bc1[1] - P[1]], VP); 
            const mip2 = mahalanobisInnerProd([bc2[0] - P[0], bc2[1] - P[1]], VP); 
            ssd1 += mip1; 
            ssd2 += mip2;
	    // add neglog of normalization constant
	    ssd0 += nlgc(VP); 
	    ssd1 += nlgc(VP); ssd2 += nlgc(VP);


if (bc1[0] == bc2[0]) debugger

	    if (ssd1 + ssd2 < ssd0) {                    
		// kill formerly united cluster and prune its parent
	        killCluster(l, ci0); 	  

                // add to entities array and create 2 new clusters
		const ci1 = breedCluster(l, bc1[0], bc1[1], H1, majsv1, minsv1, tanphi1);
		const ci2 = breedCluster(l, bc2[0], bc2[1], H2, majsv2, minsv2, tanphi2);

	        // prune 1 and graft 2 members
	        if (l < topLiveClusLev()) {       
	            pruneParentCluster(l, ci0, pi);
	            graftIntoParentCluster(l, ci1, pi, mip1);
	            graftIntoParentCluster(l, ci2, pi, mip2);

		} else if (l == topLiveClusLev()) {         // it should be clusters[l].length == 2
                    // stack a new l+1-topcluster after splitting old l-topclus
		    P[5] = [ci1, ci2];  // graft splits into new parent cluster
		    P[6] = [mip1, mip2];
		    // create new top layer
		    clusters.push([P]); 
//		    if (entities.length > l+1) findCompoundEntities(0, l+1);
		}

                console.log(`split ${++nsplits}`);
		return [[H1, H2], [ssd1, ssd2]]; 
	    } else 
	        return [[C[5]], [ssd0]];
	}
        
	function tryMerging2ClustersGreedily(l) {
	    if (clusters[l].length <= minClusMembCount || l == topLiveClusLev())  // numclus<=2 or top layer
	        return false;     

	    const Cl = clusters[l]; 
	    const nc = Cl.length;
	    const Al = clusters[l+1]; // cluster layer above

	    // pick two arbitrary distinct clusters with common cluster parent
            let ci1, pi1, ci2, pi2;
	    if (l == topLiveClusLev()-1) { // last to top cluster layer: only one cluster parent 
                do {
		    ci1 = randint(0, nc-1);           ci2 = randint(0, nc-1); 
	            pi1 = findParentClusterId(l, ci1); pi2 = findParentClusterId(l, ci2);
	        } while (ci2 == ci1 || Cl[ci1].length == 1 || Cl[ci2].length == 1); 
		if (pi1 != pi2) debugger;
	    } else {
                // pick one cluster parent from the supraordinate layer
		do pi1 = randint(0, Al.length-1); while (Al[pi1].length < 2);
	        const P = Al[pi1];   
		const nm = P[5].length;

//if (nm == 1) debugger; 

	// do not merge if there are 2 or less siblings
	// this prevents a level 1 universal gigacluster
	if (nm <= minClusMembCount) return false;


	        do {
	            ci1 = P[5][randint(0, nm-1)];     ci2 = P[5][randint(0, nm-1)]; 
	        } while (ci2 == ci1 || Cl[ci1].length == 1 || Cl[ci2].length == 1); 
	    }


	    // common parent
	    const P = Al[pi1];   

            // define subclusters
	    const C1 = Cl[ci1][5];
	    const C2 = Cl[ci2][5];
	    const C3 = filterOutRepeats([...C1, ...C2])
             
for (let m of C1) if (C2.includes(m)) debugger;

            // compute sum of squared/mahalanobis distances
            const V1 = rebuildCovmat(Cl[ci1]);  // V1 = [[1, 0], [0, 1]];
            const V2 = rebuildCovmat(Cl[ci2]); 
	    const [X3, bc3] = getMemberCoordinates(l, C3); 
	    const [sv1, sv2, tanphi, D3] = svd(X3, bc3).slice(0, 4);
	    const V3 = math.multiply(D3.v, math.diag([sv1**2, sv2**2]), math.transpose(D3.v));
	    let [ssd1, bc1] = computeSumSqdis(l, C1, V1);
	    let [ssd2, bc2] = computeSumSqdis(l, C2, V2);
	    let ssd3        = computeSumSqdis(l, C3, V3)[0]; 
	    // add neglog of normalization constant
	    ssd1 += nlgc(V1);
	    ssd2 += nlgc(V2);
	    ssd3 += nlgc(V3);

            // compute sum of inter-centroid squared/mahalanobis distances
            const VP = rebuildCovmat(P);  
            ssd1 += mahalanobisInnerProd([bc1[0] - P[0], bc1[1] - P[1]], VP); 
            ssd2 += mahalanobisInnerProd([bc2[0] - P[0], bc2[1] - P[1]], VP); 
            const mip3 = mahalanobisInnerProd([bc3[0] - P[0], bc3[1] - P[1]], VP); 
            ssd3 += mip3;
	    // add neglog of normalization constant
	    ssd1 += nlgc(VP); ssd2 += nlgc(VP); 
	    ssd3 += nlgc(VP);

	    if (ssd3 < ssd1 + ssd2) {
		// kill former halves and prune parents
	        killCluster(l, ci1); 
		killCluster(l, ci2);	       
		pruneParentCluster(l, ci1, pi1); 
		pruneParentCluster(l, ci2, pi1);

		// create new union and graft it 
		const ci3 = breedCluster(l, bc3[0], bc3[1], C3, sv1, sv2, tanphi);
	        graftIntoParentCluster(l, ci3, pi1, mip3);

                // kill parent cluster if it's the top cluster and it has no other children
	        if (l == topLiveClusLev()-1 && numClus()[0][l] == 1) { 
		    killCluster(l+1, pi1); 
		    //clusters.pop(); // maybe simply pop
		}

                console.log(`merge ${++nmerges}`);
	        return [[C3], [ssd3]];
	    } else                                    
	        return [[C1, C2], [ssd1, ssd2]]; 
	}
        function splitMergeClusters() {
	    const N = settings.maxNumLiveClusters;
	    let lsl = clusters.length; // lowest split level
	    let lml = clusters.length; // lowest merge level
            for (let l = 1; l < clusters.length; l++) {
//	if (numClus()[0][l] == 0) debugger;
		let sc, mc;

ri1 = randint(0, clusters[l].length-1), ri2 = randint(0, clusters[l].length-1);
if (ri1 != ri2 && clusters[l][ri1].length>1 && clusters[l][ri2].length>1 && intersectSets(clusters[l][ri1][5], clusters[l][ri2][5]).length > 0 ) debugger;

		if (numClus()[2] < N) {    
		    sc = trySplitting1ClusterGreedily(l);
		    if (sc != false && sc[0].length == 2 && l < lsl) lsl = l; 
		}
		if (numClus()[0][l] > 1) {
		    mc = tryMerging2ClustersGreedily(l);
		    if (mc != false && mc[0].length == 1 && l < lml) lml = l; 
	            if (l == topLiveClusLev() && clusters[l].length == 1) break; 
		}
            }
	    const isSplitMerge = (lsl < clusters.length || lml < clusters.length) ? true : false;		    
            return [isSplitMerge, lsl, lml]
        }
        
	function MstepTranslocation(l) {
            for (let i = 0; i < clusters[l].length; ++i) {
		const C = clusters[l][i];
		if (C.length == 1) continue;
                const nm = C[5].length;
                if (nm < minClusMembCount) continue;

		const bc = computeSumSqdis(l, C[5], d = false)[1];
                C[0] = bc[0]; C[1] = bc[1];
		//C[2] = Math.sqrt(ssd / nm);
            }
	}

        function ekmMstepVoronoiTranslocation(VC, l) {
            let msd = 0.;   // maximum squared displacement
	    const cl = clusters[l];
            for (let i = 0; i < cl.length; ++i) {
		if (cl[i].length == 1) continue;
		const nnc = VC[i][0].length;
                if (nnc >= minClusMembCount) {
		    // translocate
	            const new_x = sumArray(VC[i][0]) / nnc, new_y = sumArray(VC[i][1]) / nnc;
                    msd = Math.max(msd, (cl[i][0] - new_x)**2, (cl[i][1] - new_y)**2);
                    cl[i][0] = new_x;                cl[i][1] = new_y;
                }
            }
            return msd;
        }
	function svd(X, bc) {
	    // the non-zero elements of S (singular values) are the square roots of the non-zero eigenvalues of M⁎M or MM⁎
	    //   M = U * S * Vt,  (V is transposed);    Mt * M = V * St*S * Vt
	    const M = zipTwoArrays(X[0].map(v => v - bc[0]), X[1].map(v => v - bc[1])); //m children, n dim: mx 2
	    const D = SVDJS.SVD(M);  // https://github.com/danilosalvati/svd-js               // also math.eigs
	    let [[majorsv, minorsv], [i1, i2]] = argmax12(D.q);			    
	    const new_tanphi = D.v[1][i1]/D.v[0][i1]; // first rightsingvec: the right singular vectors are in V's columns

	    // two-point clusters yield singular covariance matrices: eschew by setting a positive minimum sma
	    if (X[0].length == 2) {
		if (D.q.includes(NaN)) {
		    i1 = 0; i2 = 1; 
		    majorsv = D.q[i1] = sumArray(math.diag(M).map(v => math.abs(v))); 
                    minorsv = D.q[i2] = 0;
	        }
		minorsv = D.q[i2] = Math.max(settings.atoms.radius, D.q[i2]);
	    }
if (!isFinite(majorsv) || !isFinite(minorsv)) debugger

	    return [majorsv, minorsv, new_tanphi, D, [i1, i2]];
	}

        function ekmEstepReallocateMstepReshapeKill(VC, l) {
	    const cl = clusters[l];
	    let isRealloc = false;
            for (let i = 0; i < cl.length; i++) {
	        if (!isClusLive(l, i)) continue;  // if cluster dead
				
                if (VC[i][2].length >= minClusMembCount) {  //  the cluster remains non-degenerate 

		    // reshape
  		    const [new_sma1, new_sma2, new_tanphi, D, ind] = svd(VC[i], cl[i]);
				    
		    // exponential smoothing
	            cl[i][2]    = .95 * cl[i][2]    + .05 * new_sma1;           
	            cl[i][3][0] = .95 * cl[i][3][0] + .05 * new_sma2;          
	            cl[i][3][1] = .95 * cl[i][3][1] + .05 * new_tanphi;           

		    // drawing parameters
		    let hue; 
		    const pi = findParentClusterId(l, i);
		    if (l == topLiveClusLev() || pi === false) hue = 360 * mb32closure();
                    else                                       hue = clusters[l+1][pi][4][0];
		    let saturation, oldestEntObjLifespan, e, ei, newreg;
		    if (cl[i][7] !== undefined && entities[l].length > 0 && entities[l][cl[i][7]][1].includes(i)) { // if cluster points to its parentity 
                        e = entities[l][cl[i][7]];  // parent entity
                        oldestEntObjLifespan = e[2][e[1].indexOf(i)]; // instead of lastIndexOf
                        saturation = 100 * (Date.now() - oldestEntObjLifespan) / (Date.now() - starttime); 
		    } else saturation = 100 * mb32closure();
                    const lightness = 100 * 1/2;
	            cl[i][4][0] = .95 * cl[i][4][0] + .05 * hue;          
	            cl[i][4][1] = .95 * cl[i][4][1] + .05 * saturation;          
	            cl[i][4][2] = .95 * cl[i][4][2] + .05 * lightness;          
				    
		    // reallocate
		    if (equalMultisets(cl[i][5], VC[i][2])) continue; // if cluster members are unchanged
		    isRealloc = true;
		    cl[i][5] = VC[i][2];
		    cl[i][6] = VC[i][3];
                    
		    // entity bookkeeping
//		    if (entities.length <= l || entities[l].length == 0) continue;  // if ent is not up to date or unused

/*				    
                    // kill orphaned parEnt objects (above: since cluster members have changed)
		    if (cl[i][7] !== undefined && entities[l][cl[i][7]][1].includes(i)) { // if cluster points to its parentity 
                        e = entities[l][cl[i][7]];  // parent entity
                        e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // kill orphaned ent object and compute lifespan
		    } else {
                        const eis = findLiveClusterEntityIds(i, l);
                        if (eis.length == 1)    
//		            for (const ei of eis) { 
//       e = entities[l][ei];   // in theory there should be one and only one old parEnt

    {  e = entities[l][eis[0]];   // in theory there should be one and only one old parEnt
                                e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // kill orphaned ent object and compute lifespan
		}
//		            }
		        if (eis.length > 1) debugger;
		    }

		    // find new matching parent
                    [ei, newreg] = findCompoundEntities(i, l); // finds parentity, registers it in clus[7], updates parentity children

    if (ei === undefined) debugger; //continue;
		    e = entities[l][ei];
		    oldestEntObjLifespan = e[2][e[1].indexOf(i)]; // instead of lastIndexOf
                    saturation = 100 * (Date.now() - oldestEntObjLifespan) / (Date.now() - starttime); 
	            cl[i][4][2] = .95 * cl[i][4][2] + .05 * saturation;          
*/				   
                } else {   // if degenerate: kill or recreate degenerate cluster
	            // this avoids singularities when a clusters contains only one point
/*
	            if (entities.length <= l) {          // not in census: abort and replace with last cluster
debugger
		        const last = cl.pop(); if (i < cl.length) cl[i] = last; i--;
		    } else {                                    
			let iinent = false, linent = false;   // check if they are registered as ents
		        for (var e of entities[l]) {   
                            if (e[1].includes(i))           {iinent = true; break;} 
			    if (e[1].includes(cl.length-1)) linent = true;       // ent includes last clus id
			}
			if (iinent) {  // in census                  
			    if (e[3][e[1].lastIndexOf(i)]==0) {     // if ALIVE
			        cl[i] = ["tomb"];                               // kill and make tomb
			        e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // lifespan
			    }                                 // if dead, do nothing                               
			} else {   //  not in census
debugger
			    if (linent) cl[i] = spawnCluster();         // abort cluster and create new (orphan) cluster
			    else        {const last = cl.pop(); if (i < cl.length) cl[i] = last; --i} // abort and replace with last
                        }					    
                    }  */

                // Perhaps we should not kill degenerate clusters: if you kill them, the only child becomes an orphan
//		if (l == clusters.length-1 || numClus()[0][l] < 2) debugger; 


                if (VC[i][2].length == 1) {  //  the cluster has a single child
	            cl[i][2]    = .95 * cl[i][2]    + .05 * settings.atoms.radius;           
	            cl[i][3][0] = .95 * cl[i][3][0] + .05 * settings.atoms.radius;          
	            cl[i][3][1] = .95 * cl[i][3][1] + .05 * 0;           
		    cl[i][5] = VC[i][2];
		    cl[i][6] = VC[i][3];
	        } else if (VC[i][2].length == 0) {
    killCluster(l, i);   // kill and make tomb only if cluster is not top and there are at least two live clusters in level l
//    cl[i] = spawnCluster();         // alternative: abort cluster and create new random (orphan) cluster
		    pruneParentCluster(l, i);

		}
		isRealloc = true;

                }
            }  
            return isRealloc;
        }
	function rebuildCovmat(C) {
            const phi = math.atan(C[3][1]);		// in radians
            // rotation matrix: from zero to major axis orientation		
	    const R = [[math.cos(phi), -math.sin(phi)], [math.sin(phi), math.cos(phi)]]; 

	    //   M = U * S * Vt,  (V is transposed);    Mt * M = V * St*S * Vt
            const V = R;  // this is the rotation from sv space to covmatrix space
            const S = math.diag([C[2], C[3][0]]);

            return math.multiply(V, S, S, math.transpose(V)); // ellipse axes length is square root of covariance 
	}
        function findNearestCentroid(x, y, l) {
            let ncid = -1, ncsu = 1e38;
            for (let i = 0; i < clusters[l].length; ++i) {
		if (clusters[l][i].length == 1) continue;
                const dx = x - clusters[l][i][0], dy = y - clusters[l][i][1];
                const V = rebuildCovmat(clusters[l][i]);  
                let su = mahalanobisInnerProd([dx, dy], V); // surprisal or Shannon information
		su += nlgc(V); 

                if (su < ncsu) {
                    ncid = i;
                    ncsu = su;
                }
            }
            return [ncid, ncsu];
        }

	function sprinkleClusters() {
	    const N = settings.maxNumLiveClusters;

	    //if (clusters.length > 1 && clusters.slice(-1)[0].length == 0) clusters.pop();
            if (clusters.slice(-1)[0].length > 1) clusters.push([spawnCluster()]);

            if (numClus()[2] < N * .8) {
		do for (l of clusters.slice(1)) { 
	            for (c of l) if (c.length == 0) c = spawnCluster();
		    l.push(spawnCluster());
		} while (numClus()[2] < N);
            }
        }

        function findEuclideanNearestCentroid(x, y, l) {
	    const cl = clusters[l];
            let ncid = -1, ncsd = 1.e38;
            for (let i = 0; i < cl.length; ++i) {
		if (cl[i].length == 1) continue;
                const dx = cl[i][0] - x, dy = cl[i][1] - y;
                const sd = dx ** 2 + dy ** 2;
                if (sd < ncsd) {
                    ncid = i;
                    ncsd = sd;
                }
            }
            return [ncid, ncsd];
        }
        function kmMstepVoronoiTranslocation(V, l) {
	    const cl = clusters[l];
            let msd = 0.;   // maximum squared displacement
            for (let i = 0; i < cl.length; ++i) {
		if (cl[i].length == 1) continue;
                if (V[i][0] >= minClusMembCount) {
                    const new_x = V[i][1] / V[i][0], new_y = V[i][2] / V[i][0];
                    msd = Math.max(msd, (cl[i][0] - new_x)**2, (cl[i][1] - new_y)**2);
                    cl[i][0] = new_x;                cl[i][1] = new_y;
                }
            }
            return msd;
        }

        function kmEstepReallocateMstepReshapeKill(V, l) {
	    const cl = clusters[l];
            for (let i = 0; i < cl.length; i++) {
                let c = cl[i], s = V[i];
	        if (c.length == 1) continue;  // if cluster dead

		if (s[0] >= minClusMembCount) {  // reshape cluster, update parEnts

                    // reshape cluster
                    const new_r = Math.sqrt(s[3] / s[0]) + atomRadius;  // plus atom radius
                    c[2] = 0.95 * c[2] + 0.05 * new_r;  // reshape: exponential smoothing
		    let saturation = s[4][1] / s[0];
                    c[4] = [s[4][0] % 360, saturation, s[4][2] / s[0]];   // repaint

		    // reallocate
		    c[6] = s[6];
		    if (equalMultisets(c[5], s[5])) continue; // if cluster is unchanged
	            c[5] = s[5];		                 

		    // entity bookkeeping
		    if (entities.length <= l || entities[l].length == 0) continue;  // if ent is not up to date 
                    const eis = findLiveClusterEntityIds(i, l);

		    // kill orphaned parEnt objects
		    if (eis !== undefined && eis.length > 0) 
		        for (const ei of eis) { const e = entities[l][ei];   // ideally there should be one and only one
                            e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // kill orphaned ent object and compute lifespan
		        }

		    // find new matching parent
                    let ei = findCompoundEntities(i, l)[0]; // finds parent, registers it in clus[7], updates parent children
                        
		    if (ei !== undefined) { const e = entities[l][ei];
                        saturation = 100*(Date.now()-e[2][e[1].lastIndexOf(i)])/(Date.now()-starttime); 
                        c[4] = [s[4][0] % 360, saturation, s[4][2] / s[0]];   // repaint
		    }

                } else {   // kill or recreate degenerate cluster
	            if (entities.length <= l) {          // not in census: abort and replace with last cluster
		        const last = cl.pop(); if (i < cl.length) cl[i] = last; i--;
		    } else {                                    
			let iinent = false, linent = false;   // check if they are registered as ents
		        for (var e of entities[l]) {   
                            if (e[1].includes(i))           {iinent = true; break;} 
			    if (e[1].includes(cl.length-1)) linent = true; 
			}
			if (iinent) {  // in census                  
			    if (e[3][e[1].lastIndexOf(i)]==0) {     // if ALIVE
			        cl[i] = ["tomb"];                               // kill and make tomb
			        e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // lifespan
			    }                                 // if dead, do nothing                               
			} else {   //  not in census
			    if (linent) cl[i] = spawnCluster();         // abort cluster and create new cluster
			    else        {const last = cl.pop(); if (i < cl.length) cl[i] = last; --i} // abort and replace with last
                        }					    
                    }
                }
            }  
        }
	function kmeans(l) {
	    MstepTranslocation(l);
            const maxNumPasses = 10;
	    const cl = clusters[l];
	    const V = new Array(clusters.length).fill([]); // k-means' Voronoi cells
            for (let pass = maxNumPasses; pass >= 0; --pass) {
                for (let j=0; j < cl.length; ++j) V[j] = [0, 0., 0., 0., [0, 0, 0], [], []];
                for (let i=0; i < clusters[l-1].length; i++) {
                    let c = clusters[l-1][i];
		    let [nci, ncsd] = findEuclideanNearestCentroid(c[0], c[1], l);
                    if (nci >= 0 && ncsd < maxRange**2) {
                        V[nci][0] += 1;
                        V[nci][1] += c[0]; V[nci][2] += c[1];
                        V[nci][3] += ncsd;
 	                for (let v=0; v<3; v++) V[nci][4][v] += c[4][v];
 	                V[nci][5].push(i);
                        V[nci][6].push(ncsd);
                    }
		}
                const msd = kmMstepVoronoiTranslocation(V, l);
		if (msd < 1.) break;
            }
	    kmEstepReallocateMstepReshapeKill(V, l);
	}

	function ellipticalKmeans(l) {
            MstepTranslocation(l);
	    const maxnit = 10;
	    const VC = new Array(clusters[l].length).fill([[], [], [], []]); // Voronoi cells
	    // E-step
            for (let it = maxnit; it >= 0; --it) {
                for (let j=0; j < clusters[l].length; ++j) VC[j] = [[], [], [], []];
                for (let i=0; i < clusters[l-1].length; i++) {
                    let c = clusters[l-1][i];
		    let [nci, ncsu] = findNearestCentroid(c[0], c[1], l);
                    if (nci >= 0 && ncsu < maxRange**2) {
                        VC[nci][0].push(c[0]); VC[nci][1].push(c[1]);
                        VC[nci][2].push(i);
			VC[nci][3].push(ncsu);
                    }
	        }
                const msd = ekmMstepVoronoiTranslocation(VC, l);
		if (msd < 1.) break;
            }

ri1 = randint(0, clusters[l].length-1), ri2 = randint(0, clusters[l].length-1);
if (ri1 != ri2 && VC[ri1].length>1 && VC[ri2].length>1 && intersectSets(VC[ri1][2], VC[ri2][2]).length > 0 ) debugger;

            const isRealloc = ekmEstepReallocateMstepReshapeKill(VC, l);
	    return isRealloc;
	}    

        function trackClusters() {
	   // sprinkleClusters();

	    let lrl = clusters.length, isRealloc = false, isSplitMerge = false;
	    // allocate atoms to clusters[1]: kmeans(atoms, clusters[1]);
	    // allocate clusters[i] to clusters[i+1]
	    for (let l = 1; l < clusters.length; l++) {
		//kmeans(l);
		const isrl = ellipticalKmeans(l);
		if (isrl && l < lrl) lrl = l;
		isRealloc = isRealloc || isrl;
	    }

	    [isSplitMerge, lsl, lml] = splitMergeClusters();

	    return [(isRealloc || isSplitMerge), Math.min(lrl, lsl, lml)]; 		    
        }

        function drawClusters(l) {
            let i = 0;
            while (i < clusters[l].length) { // clus.length is evaluated only once, at the start of the loop 
                let c = clusters[l][i];
		if (c.length > 1 && c[2] > 0.) {
                    color = hsl2str(...c[4]);
		    if (c[3][1] == 0.) lg = Math.PI * c[2] / c[5].length;
		    else               lg = Math.PI * Math.sqrt(c[2]**2+c[3][0]**2) / c[5].length;
                    drawEllipse(c[0], c[1], [c[2], ...c[3]], color, false, 2*l, [true, lg, lg]);
                } 
	        ++i; 
            }
        }


	/*** ENTITIES ***/

        // entities[l][i]: member ids, live cluster ids, birthtime, lifespan 	
   
        function transcribeClusToEntMultiset(ci, l, ents = entities) {
	    // does NOT check for cluster id uniqueness 
	    let mulset = [];
	    for (let mi of clusters[l][ci][5])
 // mulset.push(clusters[l-1][mi][7])
                for (let k = 0; k < ents[l-1].length; k++)
   	            if (ents[l-1][k][1].includes(mi) && ents[l-1][k][3][ents[l-1][k][1].lastIndexOf(mi)]==0) 
		        mulset.push(k); 
            if (mulset.length != clusters[l][ci][5].length) { // the matching entities have not been added yet
		console.log(mulset, clusters[l][ci][5]);  //debugger
		return false; 
	    } else return mulset;
	}
	function findAtomicEntities(ents = entities) { 
	    if (ents.length == 0) ents[0] = [];
	    for (let j = 0; j < settings.numColors; j++) {
		if (ents[0].length-1 < j) ents[0].push([j, [], [], []]); 
                for (let ci = 0; ci < clusters[0].length; ci++) 
		    if (clusters[0][ci][5] == j && !ents[0][j][1].includes(ci)) {
		        ents[0][j][1].push(ci);
		        ents[0][j][2].push(Date.now());
		        ents[0][j][3].push(0);
			clusters[0][ci][7] = j;
		    }
	    }
	    return ents;
	}
	function findCompoundEntities(ci, l, ents = entities) { 
	    // find entity with id ei in level l corresponding to cluster id ci; if absent, create entity and append
	    mulset = transcribeClusToEntMultiset(ci, l);
            if (mulset === false) return [undefined, false]; // the matching entities have not been added yet

	    let newreg = false;  // new ent registered ?
	    for (var ei = 0; ei < ents[l].length; ei++) { // loop2:
	        if (equalMultisets(mulset, ents[l][ei][0])) {      // if the multiset is already registered
	            if (!ents[l][ei][1].includes(ci) ||                                                  // cluster object not registered
	                (ents[l][ei][1].includes(ci) && ents[l][ei][3][ents[l][ei][1].lastIndexOf(ci)] > 0)) {    // cluster object registered but dead
	                ents[l][ei][1].push(ci);
	                ents[l][ei][2].push(Date.now());
	                ents[l][ei][3].push(0);
	                clusters[l][ci][7] = ei;
			newreg = true;
	            }   
	            return [ei, newreg]; //ei=0; break; // continue loop2;   // cluster object registered and alive
	        }
	    }
	    if (ei == ents[l].length) {   // multiset not registered
	        ents[l].push([mulset, [ci], [Date.now()], [0]]);
	        clusters[l][ci][7] = ei;
		newreg = true; // new entity created: true
	    } 
	    return [ei, newreg]; 
	}
	function scanRegisterEnts(ents = entities) {  // [[]]
	    if (clusters.length == 0) return ents;

	    findAtomicEntities();

	    for (l = 1; l < clusters.length; l++) {	    
//if (ents.length == l && clusters[l].length > 0) ents.push([]);
		if (ents.length == l) ents.push([]);
	        for (let i = 0; i < clusters[l].length; i++) {   //loop2:
	            if (clusters[l][i].length < 2 || clusters[l][i][5].length < 2) continue; 
	            findCompoundEntities(i, l);
		}
	    }
//    return ents;
        }

	function numEnts() {
	    let nl = [numAtomTypes], nd = [0];
	    for (l = 1; l < entities.length; l++) {	   
		nl[l] = 0; nd[l] = 0;
		for (let i = 0; i < entities[l].length; i++) {
		    if (!entities[l][i][3].includes(0)) nd[l]++;
		    else                                nl[l]++;
		}
	    }
	    return [nl, nd];
        }	

	    

	/*** PHYSICS ***/

        // Enact atomic interactions
        const stepForward = () => {
            const c = 10 ** settings.damping;
            const dt = 10 ** settings.logTimeStep;
            const n = settings.interaction_law;
            mav = 0.; msv = 0.;

            // update velocity 
            for (const a of atoms) {
                let Fx = 0, Fy = 0;
                const idx = a[5] * settings.numColors;
                const rang2 = settings.range[settings.colors[a[5]]]**2;
                for (const b of atoms) {
		    const g = settings.interactionForces[settings.colors[a[5]]][settings.colors[b[5]]];
		    let dx = a[0] - b[0], dy = a[1] - b[1];
	            if (settings.wraparound) {
		   	const dxpm = [dx-canv.width, dx, dx+canv.width], dypm = [dy-canv.height, dy, dy+canv.height];
                        const dxa = dxpm.map(Math.abs),                  dya = dypm.map(Math.abs);
			const dxi = dxpm.indexOf(Math.min(...dxa)),      dyi = dypm.indexOf(Math.min(...dya));
			dx = dxpm[dxi];			                 dy = dypm[dyi];							
 		    }
                    if (dx !== 0 || dy !== 0) {
                        const dr2 = dx ** 2 + dy ** 2;
                        if (dr2 < rang2) {
                            //const F = g / Math.sqrt(dr2);   // inverse law: n = -1
                            const F = g * Math.sqrt(dr2) ** n;    // inverse-square law: n = -2
                            Fx += F * dx; Fy += F * dy;

                            // draw lines between interacting atoms 
                            if (settings.drawings.forcelines) drawInteraction(a[0], a[1], b[0], b[1], settings.colors[b[5]]);                            
                        }
                    }
                }
                if (prod_st != 0) {
                    const dx = a[0] - prod_x, dy = a[1] - prod_y;
                    const dr2 = dx ** 2 + dy ** 2;
		    if (dr2 > 0 && dt > 0) {
                        const prodForce = 100. * prod_st / (dr2 * dt);  // inverse square law
                        Fx += prodForce * dx; Fy += prodForce * dy;
                    }
                }
                if (settings.wallThickness > 0) {
                  const wt = settings.wallThickness, we = settings.wallElasticity;
                  if (a[0] < wt)               Fx += (wt - a[0]) * we;
                  if (a[0] > canv.width - wt)  Fx += (canv.width - wt - a[0]) * we;
                  if (a[1] < wt)               Fy += (wt - a[1]) * we;
                  if (a[1] > canv.height - wt) Fy += (canv.height - wt - a[1]) * we;
                }

                Fy += settings.gravity;

		// dynamic equation with damping coefficient: dv/dt = -c*v  =>  v = exp(-c*t) ~ -c*t => v1-v0 ~ -c*(t1-t0) ~ -c*dt
                //a[2] -= c * a[2] * dt; a[3] -= c * a[3] * dt;  // the damping coefficient multiplies velocity
		// dynamic equation with drag coefficient: dv/dt = -c*v^2  => v = 1/(c*t) => v1-v0 ~ 1/c*(1/t1-1/t0) = (t0-t1)/(c*t0*t1) = -dt*c*v1*v0 ~ -dt*c*v1^2
		// drag coefficient (skin friction and form drag) depends on the Reynolds number for fluids
		if (Math.abs(c*a[2]*dt) >= 1) a[2] = 0; else a[2] -= c * a[2]**2 * dt * Math.sign(a[2]);
		if (Math.abs(c*a[3]*dt) >= 1) a[3] = 0; else a[3] -= c * a[3]**2 * dt * Math.sign(a[3]);
		
		// dp/dt = F
		a[2] += Fx * dt; a[3] += Fy * dt;

                // record typical activity, to later update logTimeStep accordingly
                mav += Math.abs(a[2]) + Math.abs(a[3]);
                msv += a[2]**2 + a[3]**2;
            }
            mav /= atoms.length; msv /= atoms.length;
	    cvNkT.push(msv);
	    const ssd = sumArray(sumSqdis()); 
	    if (Date.now() - starttime > 9000) mssd.push(ssd/numAtomsNow());

            // update positions 
            for (const a of atoms) {
                // dr/dt = v 
                a[0] += a[2] * dt; a[1] += a[3] * dt;

                // upon reaching the canvas fringes
		if (!settings.wraparound) { // hard wall		
                    if (a[0] < 0)            {a[0] = -a[0] % canv.width;                     a[2] *= -1;} // x wraps around if ricochet exceeds width
                    if (a[0] >= canv.width)  {a[0] = (2 * canv.width - a[0]) % canv.width;   a[2] *= -1;} // x<0 and idem if ricochet exceeds width
                    if (a[1] < 0)            {a[1] = -a[1] % canv.height;                    a[3] *= -1;} // idem
                    if (a[1] >= canv.height) {a[1] = (2 * canv.height - a[1]) % canv.height; a[3] *= -1;} // idem
                } else {                            // wrap around with toroidal topology
		    settings.wallThickness = 0;
		    if (a[0] > canv.width)  a[0] %= canv.width;
		    else if (a[0] < 0)      a[0] = canv.width + a[0] % canv.width; //a[0] += canv.width;
		    if (a[1] > canv.height) a[1] %= canv.height;
		    else if (a[1] < 0)      a[1] = canv.height + a[1] % canv.height;
		}
            }
        };



	/*** LET THERE BE LIGHT ***/

	let starttime = Date.now();

        // Initialize PRNG seed 
        var mb32closure = mulberry32prng(settings.seed);  // closure PRNG initialized with seed
        getSeedFromUrlFragment();

	// Draw canvas
        const canv = document.getElementById("mycanvas");
        const crc = canv.getContext("2d");
        updateCanvas();      // stretch canvas to cover window and paint it

        // Set interaction forces
        setColors();
        randomInteractions();

        // Create atoms, initialize clusters and entities
        const atoms = new Array();
        const clusters = [], entities = [];
	let nsplits, nmerges;
        restartAtoms(settings.atoms.count, true);
	findAtomicEntities();

	// Set up sundry functionalities  
        var prod_st = 0, prod_x = 0, prod_y = 0; // click-induced pulse-shaped in time and strength prod 
        var exploration_timer = 0;
        var mav, msv;  // mean absolute velocity as an estimate of on-screen activity, mean sq velocity
	const cvNkT = []; // specific internal energy: U/N = v^2/N
	const mssd = []; // mean ssd, or specific free energy time series
        setupGui();
        setupHotkeys();
        setupProd();
	// Plotting
        const plt = document.getElementById("fig01");
	plt.style.height = canv.height * 0.9;
        let layout = {grid: {rows:6, columns:1, roworder: "top to bottom"}, barmode: "overlay", 
	              title: "plotly", showlegend: true, margin: {l: 30, r: 10, b: 20, t: 20, pad: 5},
		      xaxis1: {anchor: "y1"}, xaxis2: {anchor: "y5"},  
		      xaxis6: {anchor: "y6", type: "linear", autorange: true}, yaxis6: {type: "log"}};


        /*** MOVE ONWARD: REFRESH AND READJUST ***/

        let oldnow = performance.now(); //Date.now();
        repaint();

	function repaint(timeStamp) {
            updateCanvas();
			
            stepForward();

            // draw atoms
            for (const a of atoms) {
                if (settings.drawings.round) drawEllipse(a[0], a[1], settings.atoms.radius, hsl2str(...a[4]));
                else                         drawSquare(a[0], a[1], settings.atoms.radius, hsl2str(...a[4]));                
            }
            if (settings.drawings.clusters) {
                // recompute clusters
	        // scan from lesl level upward, lesl is the lowest level with cluster changes 
	        let [doEntscan, lesl] = trackClusters();

	        // draw clusters
                for (let l = 1; l < clusters.length; l++) drawClusters(l);

	        // discover entities
	        if (entities.length < clusters.length)     scanRegisterEnts(entities);
		else for (let l = lesl; l < entities.length; l++) 
			for (ei = 0; ei < entities[l].length; ei++)
			    if (entities[l][ei].length==0) findCompoundEntities(l, ei);
            }

            readjust(timeStamp);

	    plots();

	    // Tally atoms within canvas
            //const inSight = (a) => 0 <= a[0] && a[0] < canv.width && 0 <= a[1] && a[1] < canv.height;
            //console.log('atoms in sight', atoms.filter(inSight).length);  

            window.requestAnimationFrame(repaint);
        };

        // post-frame stats and readjustments
        function readjust(timeStamp) {
            // record fps
            if (timeStamp > oldnow) {
                const new_fps = 1000. / (timeStamp - oldnow);
                settings.fps = Math.round(settings.fps * 0.8 + new_fps * 0.2)
                oldnow = timeStamp;
            }

            // adapt logTimeStep based on activity
	    let dt = 10 ** settings.logTimeStep;
            if (mav > 30. && dt > 5.) dt /= 1.1;
            if (dt < 0.9) dt *= 1.01; else if (dt > 1.1) dt /= 1.01;
	    settings.logTimeStep = Math.log10(dt);

	    // decrease prod duration if positive 
            if (prod_st != 0) prod_st -= (prod_st > 0) ? 1 : -1;

            if (settings.explore) roamParamspace();
        }


	/*** PRINT STATS ***/ 

        function numAtomsNow() {return settings.atoms.count * settings.colors.length;}    
        function numClus() {
	    let nl = [], nd = [], sl = 0, sd = 0;
	    if (clusters.length < 2) return undefined; 
	    for (l = 1; l < clusters.length; l++) {
	        nl[l] = 0; nd[l] = 0;
	        for (c of clusters[l]) (c.length > 1) ? nl[l]++ : nd[l]++;
	        sl += nl[l]; sd += nd[l];
	    }
	    return [nl, nd, sl, sd];
	}
	function topLiveClusLev() {
	    for (l = 1; l < numClus()[0].length; l++)
	        if (numClus()[0][l] == 0) return l - 1;
	    return l - 1;
	}
	function liveClus() {
	    let lc = [];
	    lc.push(clusters[0]);
	    for (l = 1; l < clusters.length; l++) {
		lc[l] = [];
		for (ci = 0; ci < clusters[l].length; ci++)
		    if (isClusLive(l, ci)) lc[l].push(clusters[l][ci]);
	    }
	    return lc;
	}
	function sumSqdis() { 
	    let ssd = new Array(clusters.length).fill(0);
	    for (let l=1; l < clusters.length; l++)
		for (const c of clusters[l]) if (c.length > 1 && c[6].length > 0)
	            for (let sd of c[6]) ssd[l] += sd;
            return ssd;			    
	}
	function topbotSqdistsNow() { 
	    let sumsqdis = 0;
	    if (clusters.length == 0) return sumsqdis;
	    topclus = clusters.slice(-1)[0][0];
	    if (clusters.slice(-1)[0].length==1 && topclus != undefined) {
	        for (let a of atoms){
		    let d2 = (a[0] - topclus[0])**2 + (a[1] - topclus[1])**2;
	            sumsqdis += d2;
	        }
	    }
            return sumsqdis;			    
	}
        
        function biggestClus() {
            let c = [], numemb = [];  	    
	    for (let l = 1; l < clusters.length; l++) {
		[c[l], numemb[l]] = [0, 0];
	        for (let j = 0; j < clusters[l].length; j++) 
		    if (isClusLive(l, j) && clusters[l][j][5].length > numemb[l]) 
		        {c[l] = j; numemb[l] = clusters[l][j][5].length;}
	    }
	    return numemb // [...c, ...numemb]
        }

        function lifespans() {
	    let s = [];
	    for (l = 1; l < entities.length; l++) {
		s[l] = [];
	        for (e of entities[l]) 
		    for (i=0; i< e[1].length; i++) 
			if (e[3][i] > 0) s[l].push(e[3][i]/10**3); else s[l].push((Date.now() - e[2][i])/10**3);
	    }
            return s; 
	}
	
        console.log("settings", settings)

	let numclus = 0; 
        window.setInterval(() => {
            if (numClus()[2] != numclus) {
		console.log(clusters);
		console.log('Number of atoms, maxClus, clusters:', numAtomsNow(), settings.maxNumLiveClusters, numClus())
	        let ssd = sumSqdis().map((x) => Math.round(x));
	        let totdis = Math.round(ssd.reduce((a,b)=>a+b,0));
		console.log("SSDs: ", ssd, totdis, totdis/numAtomsNow(), Math.round(100*totdis/topbotSqdistsNow()))
		console.log("Biggest clusters: ",biggestClus())
		numclus = numClus()[2];
	    }
	    //if (numDeadClusNow()>0) alert(`${numDeadClusNow()} cluster(s) died`);
	}, 1000);


        /*** PLOTTING ***/

	function vsqrt(x) {return x.map(el => Math.sqrt(el))};
	function vlog10(x) {return x.map(el => Math.log10(el))};
	function vllog10(x) {return x.map(el => Math.log10(el.length))};
	function plots() {
	    let cl = Array(clusters.length).fill().map((elm, ind) => ind);
	    let ts = Array(cvNkT.length).fill().map((elm, ind) => ind);
	    let trace0 = {name: "MSV", x: ts, y: vlog10(cvNkT), xaxis: "x1", yaxis: "y1"};
	    let trace1 = {name: "RMSD", x: ts, y: vlog10(mssd), xaxis: "x1", yaxis: "y2"};
	    let trace2 = {name: "bigclus",x: cl, y: vlog10(biggestClus()), xaxis: "x2", yaxis: "y3", type: "scatter"};
	    let trace3 = {name: "live ents", x: cl, y: vlog10(numEnts()[0]), xaxis: "x2", yaxis: "y4"};
	    let trace4 = {name: "dead ents", x: cl, y: vlog10(numEnts()[1]), xaxis: "x2", yaxis: "y4"};
	    let trace5 = {name: "all ents now", x: cl, y: vllog10(entities), xaxis: "x2", yaxis: "y4"};
	    let trace6 = {name: "live clus", x: cl, y: vlog10(numClus()[0]), xaxis: "x2", yaxis: "y5"};
	    let trace7 = {name: "dead clus", x: cl, y: vlog10(numClus()[1]), xaxis: "x2", yaxis: "y5"};

	    let tracehist = [];
	    for (let i=1; i < entities.length; i++) 
	    tracehist[i-1] = {name: `count L${i}`, x: lifespans()[i], type: 'histogram', histfunc: "count", opacity: .4, xaxis: "x6", yaxis: "y6"};
	    Plotly.newPlot(plt, [trace0, trace1, trace2, trace3, trace4, trace5, trace6, trace7, ...tracehist], layout); 
        }


        /*** RECORD VIDEO ***/ 

        function dataUrlDownloader(dataURL, name = `Racemi_${settings.seed}`) {
            const hyperlink = document.createElement("a");
            // document.body.appendChild(hyperlink);
            hyperlink.download = name; // the target will be downloaded on clicking on the hyperlink
            //hyperlink.target = '_blank';
            hyperlink.href = dataURL;
            hyperlink.click();  // HTMLElement.click() method simulates a mouse click on an element
            hyperlink.remove();
        };

        const videoStream = canv.captureStream(); // stream 
        const mediaRecorder = new MediaRecorder(videoStream); // video recorder
        let chunks = []; // temporal chunks

        mediaRecorder.ondataavailable = (e) => chunks.push(e.data); // store chunks
        mediaRecorder.onstop = function (e) {
            const blob = new Blob(chunks, { 'type': 'video/mp4' }); // chunks --> blob
            const videoDataURL = URL.createObjectURL(blob); // blob --> dataURL
            dataUrlDownloader(videoDataURL); // download video
            chunks = []; // reset chunks
        };
        // mediaRecorder.start(); // start recording
        // mediaRecorder.stop(); // stop recording


    </script>

</body>

</html>
