<html>
<title>Racemi in 2D</title>

<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        :root {
            color-scheme: dark;
            --canvas-bg-color: rgba(0, 0, 0, 0); /* transparent */
        }
        body {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #mycanvas {
            border: hsl(0 0% 30%);/*  #999999; #504e52 */
            border-style: solid; /* ridge, dashed */
            border-width: 5;
            outline: none;  /* because of the 'tabindex' focus trick */
            background-color: var(--canvas-bg-color);  
        }
    </style>

    <!-- lilgui -->
    <!--script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17"></script-->
    <script src="lilgui.js"></script>
    
    <!-- Plotly -->
    <!--script src="https://cdn.plot.ly/plotly-2.20.0.min.js" charset="utf-8"></script-->
    <script src="plotly-2.20.0.min.js" charset="utf-8"></script>

    <!-- SVD-JS -->
    <!--script src="https://unpkg.com/svd-js" type="application/javascript"></script-->
    <script src="svd-js.js" ></script>
    <!--script src="svd.js" type="module"></script-->

    <!-- math.js -->
    <script src="math.js" type="text/javascript"></script>

</head>

<body>
    <!-- 'tabindex' is a trick to make the canvas capture key events -->
    <canvas id="mycanvas" tabindex="1"></canvas>
    
    <div id="fig01" style="width:600px;height:600px;"></div>

    <script>
	console.log(document.getElementById("mycanvas"));

	// Parameter initialization
	const nd = 2;
        const numAtomTypes = 4;
        const numAtoms = 60;
        const atomRadius = 4;
	const interactionRange = 80;
        const minClustMembCount = 2;
	const maxNumLiveClusters = numAtoms * (1/(1 - 1/5) - 1); // 2->1, 4->1/3, 5->1/4,
        const irrdisn = 1 - nd;                     // attraction force irradiance to distance power law: I ~ d^(irrdisn)
        const maxRange = 2000;
        const palette = ['red', 'green', 'cyan', 'teal', 'lavender', 'yellow', 'blue', 'magenta'];
        const wallElasticity = .5; //0.1;
	const dampCoef = .07; //0.7;

        const settings = {
            seed: 91651088029,
            fps: 0,
            atoms: {
                count: numAtoms / numAtomTypes,  // per color
                radius: atomRadius,
            },
            drawings: {  // drawing options can be expensive on performance
                forcelines: false,    // central force lines between interacting atoms 
                round: false,         // draw round atoms 
                clusters: false,
                background_color: '#00000000', 
            },
            explore: false,
            explorationPeriod: 100,
            logTimeStep: 0,
            interactionForces: {},
            range: {},
            colors: [],
            numColors: numAtomTypes,
            maxNumLiveClusters: maxNumLiveClusters,
            interaction_law: irrdisn, 
            damping: Math.log10(dampCoef),  // speed-dampening (can be >1 !)
            gravity: 0.0,  // pulling downward
            prodStrengthAndDuration: 10,
	    wraparound: false,
            wallThickness: 40,
            wallElasticity: wallElasticity,
	    reset: () => restartAtoms(settings.atoms.count, true),
            randomInteractions: () => {
                settings.seed += 0x6D2B79F5;  // change seed
                resetWorld();
            },
            symmetrizeInteractions: () => {
                symmetrizeInteractions();
                restartAtoms(settings.atoms.count, true);
                updateGuiDisplay();
            },
            gui: null,
            export: {     
                image: () => {   // screenshot image
                    const imageDataURL = canv.toDataURL({format: 'png', quality: 1});
                    dataUrlDownloader(imageDataURL);
                },
                video: () => mediaRecorder.state == 'recording' ? mediaRecorder.stop() : mediaRecorder.start(), // video recording
            },
        }


        /*** SET UP GUI ***/

        const setupProd = () => {
            canv.addEventListener('click', (me) => {prod_st = settings.prodStrengthAndDuration;   // MouseEvent
                                                    if (me.shiftKey) prod_st = -prod_st;        // if shiftKey then attract
                                                    prod_x = me.clientX; prod_y = me.clientY;
				                    console.log(`coordinates: ${prod_x}, ${prod_y}`);
            })
        }

        function setupHotkeys() {
	    canv.addEventListener('keydown', (ke) => {  // KeyboardEvent
                console.log(ke.key);
                switch (ke.key) {
                    case 'r': settings.randomInteractions();                            break;
                    case 'c': settings.drawings.clusters = !settings.drawings.clusters; break;
                    case ' ': settings.reset();                                         break;
                    case 's': settings.symmetrizeInteractions();                        break;
                    default: ;
                };
            })
            let titl = document.getElementsByClassName("title")[0]; // document..querySelector('div.title[tabindex="0"]')
            canv.addEventListener("keydown", (ke) => {
                const aeb = JSON.parse(titl.getAttribute("aria-expanded")); 		
		if (ke.key=="t") {
		    titl.setAttribute("aria-expanded", (!aeb).toString()); 
		    if (gui._closed) gui.open(); else gui.close();
		}
 	    }); 
        }

        const updateGuiDisplay = () => {
            console.log('gui', gui);
            gui.destroy();
            setupGui();
        }

        Object.defineProperty(String.prototype, 'capitalize', {
	    value: function() {return this.charAt(0).toUpperCase() + this.slice(1)},
            enumerable: false
        })

        const setupGui = () => {
            gui = new lil.GUI()
	    gui.title("Controls (t)");		    

            // Physics
            const configFolder = gui.addFolder('Physics')
            configFolder.add(settings, 'reset').name('Reset ( )')
            configFolder.add(settings, 'randomInteractions').name('Random interactions (r)')
            configFolder.add(settings, 'symmetrizeInteractions').name('Symmetrize interactions (s)')
	    configFolder.add(settings, 'numColors', 1, 7, 1).name('Number of colors').listen().onFinishChange(v => {setColors(); resetWorld();})
            configFolder.add(settings.atoms, 'count', 1, numAtomsNow()/numAtomTypes*2, 1).name('Atoms per color').listen().onFinishChange(v => restartAtoms(v, true))
            configFolder.add(settings, 'maxNumLiveClusters', 1, numAtomsNow(), 1).name('Max. num. of clusters').listen()
            configFolder.add(settings, 'interaction_law', -3, 3, 0.001).name('Interaction law').listen()
            configFolder.add(settings, 'damping', -9, 2, .1).name('Log10 damping').listen()
            configFolder.add(settings, 'gravity', 0., 1., 0.05).name('Gravity').listen()
            configFolder.add(settings, 'prodStrengthAndDuration', 1, 100, 1).name('Prod strength and duration').listen()
            configFolder.add(settings, 'wraparound').name('Wrap around').listen()
            configFolder.add(settings, 'wallThickness', 0, 500, 1).name('Wall thickness').listen()
            configFolder.add(settings, 'wallElasticity', 0, 10, .01).name('Wall elasticity').listen()
            configFolder.add(settings, 'fps').name('fps').listen().disable()
            configFolder.add(settings, 'logTimeStep', -2, 1, .1).name('Log10 time step').listen()
            configFolder.add(settings, 'explore').name('Parameter exploration').listen()
            configFolder.add(settings, 'seed').name('Seed').listen().onFinishChange(v => resetWorld())

            // Drawings
            const drawingsFolder = gui.addFolder('Drawings')
            drawingsFolder.add(settings.atoms, 'radius', 1, 10, 0.5).name('Atom radius').listen()
            drawingsFolder.add(settings.drawings, 'round').name('Round atoms').listen()
            drawingsFolder.add(settings.drawings, 'clusters').name('Track clusters (c)').listen()
            drawingsFolder.add(settings.drawings, 'forcelines').name('Central force lines').listen()
            drawingsFolder.addColor(settings.drawings, 'background_color').name('Background color').listen()

            // Color interactions
            for (const atomColor of settings.colors) {
                const colorFolder =
                    gui.addFolder(`Rules: <font color=\'${atomColor}\'>${atomColor.capitalize()}</font>`)
                for (const ruleColor of settings.colors) {
                    colorFolder.add(settings.interactionForces[atomColor], ruleColor, -1, 1, 0.001)
                         .name(`<-> <font color=\'${ruleColor}\'>${ruleColor.capitalize()}</font>`).listen()
                }
                colorFolder.add(settings.range, atomColor, 1, maxRange, 5).name('Radius').listen()
            }

            // Export
            const exportFolder = gui.addFolder('Export')
            exportFolder.add(settings.export, 'image').name('Image')
            exportFolder.add(settings.export, 'video').name('Video: Start / Stop')

        }


        /*** PRNG ***/

        // Pseudorandom number generator
        // https://stackoverflow.com/questions/521295/seeding-the-random-number-generator-in-javascript
        function mulberry32prng(seed) {
            return function() {
	        var t = seed += 0x6D2B79F5;
		t = Math.imul(t ^ t >>> 15, t | 1);
	        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
	        return ((t ^ t >>> 14) >>> 0) / 4294967296;
	    }
	}

        function getSeedFromUrlFragment() { 
            let hash = window.location.hash;  // fragment identifier of the URL
            if (hash != undefined && hash[0] == '#') {
                let urlfi = Number(hash.substr(1)); // remove the leading '#'
                if (isFinite(urlfi)) {
                    settings.seed = urlfi;
                    console.log("Using from the URL fragment the seed " + settings.seed);
                }
            }
        }

        // Random integer: the maximum and minimum are inclusive
	const randint = (min, max) => Math.floor(Math.random() * (max + 1 - min) + min);


	/*** UTILS ***/

	const equalSets = (x, y) => {
	    xs = new Set(x); ys = new Set(y);
	    return xs.size === ys.size && [...xs].every((xs) => ys.has(xs));
        }
        const subtractSets = (a, b) => {
	    bs = new Set(b);
	    return a.filter(item => !bs.has(item));
        }
	const equalArrays = (x, y) => x.length === y.length && x.every((val, ind) => val === y[ind]);
	const equalMultisets = (x, y) => {
	    x.sort((a, b) => a - b); y.sort((a, b) => a - b);
	    return equalArrays(x, y);
        }

        function filterOutRepeats(C) {
	    const onlyUnique = (value, index, array) => array.indexOf(value) === index;
            for (let i=0; i < C.length; i++) C = C.filter(onlyUnique);
	    return C;
        }

	const argmax = a => a.reduce((accum, val, ind, arr) => val > arr[accum] ? ind : accum, 0);
        const argmax12 = (a) => {
            let first = -Infinity, second = -Infinity, i1, i2;
	    for (let i = 0; i < a.length; i++) {
                if (a[i] > first) {
                    [second, first] = [first, a[i]];     // save previous max
		    [i2, i1] = [i1, i];		    
                } else if (a[i] < first && a[i] > second) {
                    second = a[i];                  // new second biggest
		    i2 = i;
                }
            }
            return [[first, second], [i1, i2]];
        }
	const sumArray = a => {return a.length > 1 ? a.reduce((acc, val) => acc + val, 0) : a};
	const zipTwoArrays = (a, b) => a.map((val, ind) => [val, b[ind]]);
	const zipSumTwoArrays = (a, b) => a.map((val, ind) => val + b[ind]);

	function matMult(a, b) {
	    var aNumRows = a.length, aNumCols = a[0].length, bNumRows = b.length, bNumCols = b[0].length, m = new Array(aNumRows);  // initialize array of rows
	    for (var r = 0; r < aNumRows; ++r) {
	        m[r] = new Array(bNumCols); // initialize the current row
	        for (var c = 0; c < bNumCols; ++c) {
	            m[r][c] = 0;             // initialize the current cell
	            for (var i = 0; i < aNumCols; ++i) 
		        m[r][c] += a[r][i] * b[i][c];
	        }
	    }
	    return m;
	}
	function matDisp(m) {
	    for (var r = 0; r < m.length; ++r) 
	        document.write('&nbsp;&nbsp;'+m[r].join(' ')+'<br />');
	}
	function mahalanobisSqDist(x, C, y) {
	    if (y === undefined) y = math.transpose(x);
	    const P = math.inv(C);
	    return math.dot(y, math.multiply(P, x)); 
        }


	/*** ATOMS AND FORCES ***/    

        // atom = [x, y, vx, vy, hsl, id]

        // Initiate random locations for atoms 
        function randomX() {return mb32closure() * (canv.width - 100) + 50;}
        function randomY() {return mb32closure() * (canv.height - 100) + 50;}
        function createAtoms(n) {
            for (let i = 0; i < settings.colors.length; i++) 
	        for (let j = 0; j < n; j++) 
	            atoms.push([randomX(), randomY(), 0, 0, rgb2hsl(...colstr2rgb(settings.colors[i])), i]);
        };

        function restartAtoms(numPerColor, erase_past = true) {
	    if (erase_past) {
		atoms.length = 0;
                clusters.length = 0;  entities.length = 0; 
	        starttime = Date.now();
	    }
            createAtoms(numPerColor);
            clusters[0] = atoms;	    
	    clusters.push([spawnCluster()]); // initialize top/universe cluster
	    nsplits = nmerges = 0;
        }

        function randomInteractions() {
            for (const i of settings.colors) {
                settings.interactionForces[i] = {};
                for (const j of settings.colors) settings.interactionForces[i][j] = mb32closure() * 2 - 1; // range [-1 1]
                settings.range[i] = interactionRange;
            }
            if (!isFinite(settings.seed)) settings.seed = 0xcafecafe;
            window.location.hash = "#" + settings.seed;
            document.title = "Racemi2D #" + settings.seed;
            console.log("Seed=" + settings.seed);
            console.log(JSON.stringify(settings.interactionForces));
        }

        function symmetrizeInteractions() {
            for (const i of settings.colors) 
                for (const j of settings.colors) 
                    if (j < i) {
                        let v = 0.5 * (settings.interactionForces[i][j] + settings.interactionForces[j][i]);
                        settings.interactionForces[i][j] = settings.interactionForces[j][i] = v;
                    }
            console.log(JSON.stringify(settings.interactionForces));
        }

        function resetWorld() {
            randomInteractions();
            restartAtoms(settings.atoms.count, true);
            updateGuiDisplay();
        }

        function setColors() {
            settings.colors = [];
            for (let i = 0; i < settings.numColors; ++i) settings.colors.push(palette[i]);
        }

        function roamParamspace() {
            if (exploration_timer <= 0) {
                let c1 = settings.colors[Math.floor(mb32closure() * settings.numColors)]; //random color 1
                if (mb32closure() >= 0.2) {  // 80% chance of changing the strength
                    let c2 = settings.colors[Math.floor(mb32closure() * settings.numColors)];
                    let new_strength = mb32closure();
                    if (settings.interactionForces[c1][c2] > 0) new_strength *= -1; // enforce anti-signed interactions for appeal
                    settings.interactionForces[c1][c2] = new_strength;
                } else {                     // 20% for the range
                    settings.range[c1] = 1 + Math.floor(mb32closure() * maxRange);
                }
                exploration_timer = settings.explorationPeriod; // in frames, so in seconds it's EP/FPS ~ 100/20 = 5
            } else exploration_timer -= 1;
        }


	 /*** DISPLAY AND DRAWING ***/   

        function updateCanvas() {
            canv.width = window.innerWidth * 0.8;
            canv.height = window.innerHeight * 0.95;
            crc.fillStyle = settings.drawings.background_color;  
            crc.fillRect(0, 0, canv.width, canv.height); // bg color
        }

        function colstr2rgb(str) {
            const a = document.createElement('div');
            a.style.color = str;
            const colors = window.getComputedStyle( document.body.appendChild(a) ).color.match(/\d+/g).map(function(a){ return parseInt(a,10); });
            document.body.removeChild(a);
	    return (colors.length>=3) ? colors : false;
        };
	function rgb2hsl(r, g, b) {
	    r /= 255; g /= 255; b /= 255;
	    let cmin = Math.min(r,g,b), cmax = Math.max(r,g,b), delta = cmax - cmin, h = 0, s = 0, l = 0;
	    // hue
	    if (delta == 0) h = 0;
            else if (cmax == r) h = ((g - b) / delta) % 6;
	    else if (cmax == g) h = (b - r) / delta + 2;
	    else                h = (r - g) / delta + 4;
	    h = Math.round(h * 60);
	    if (h < 0) h += 360;
            // lightness
	    const l1 = (cmax + cmin) / 2;  
	    l = +(l1 * 100).toFixed(1);
            // saturation
	    s = delta == 0 ? 0 : delta / (1 - Math.abs(2 * l1 - 1)); 
	    s = +(s * 100).toFixed(1);
	    return [h, s, l] 
	}	
        hsl2str = (h,s,l) => "hsl(" + h + "," + s + "%," + l + "%)";

	hslColor = (h, s, l, a = 1) => {`hsl(${h},${s}%,${l}%,${a})`};

        // Draw a square
        const drawSquare = (x, y, radius, color) => {
            crc.fillStyle = color;
            crc.fillRect(x - radius, y - radius, 2 * radius, 2 * radius);
        }

        // Draw an ellipse
        function drawEllipse(x, y, r, color, fill = true, lw = 1, dash = [false, 10, 10]) {
	    crc.lineWidth = lw;	    
	    if (dash[0]) crc.setLineDash(dash.slice(1,3)); 
            crc.beginPath();
	    if (typeof r == "number" || r.length < 3) 
	        crc.arc(x, y, r, 0 * Math.PI, 2 * Math.PI);  // x, y, radius, ArcStart, ArcEnd
	    else if (r.constructor === Array) {
		[sma1, sma2, tanphi] = r;
		crc.ellipse(x, y, sma1, sma2, Math.atan(tanphi), 0, 2*Math.PI);
	    }
            crc.closePath();
            crc.strokeStyle = color;
	    crc.fillStyle = color;
            fill ? crc.fill() : crc.stroke()
        };

        // Draw line between atoms
        function drawInteraction(ax, ay, bx, by, color) {
            crc.beginPath();
            crc.moveTo(ax, ay);
            crc.lineTo(bx, by);
            crc.closePath();
            crc.strokeStyle = color;
            crc.stroke();
        };


	/*** CLUSTERS ***/    

        // clusters:     [position-x, position-y, sma1, sma2, hslcolor, members, memb2cntr_sqdis, entid]
        // Voronoi cell: [count, accum-x, accum-y, accum-d^2, accum-hslcolor, members, member_sqdis]

	function spawnCluster(x = randomX(), y = randomY(), sma1 = maxRange, sma2, hslcolor, M = [], Msd = [], ei) {
            if (sma2 === undefined) sma2 = sma1;
            if (hslcolor === undefined) hslcolor = rgb2hsl(...colstr2rgb('white')); 
            return [x, y, sma1, [sma2, 0], hslcolor, M, Msd, ei];
        }
	function breedCluster(l, x, y, M) {
            const C = spawnCluster(x, y, maxRange, maxRange, undefined, M); 
	    clusters[l].push(C);		
	    if (entities.length > 0) [ei, isnew] = findCompoundEntities(clusters[l].length-1, l).slice(1,3);
	}
        function killCluster(l, ci) {
	    if (entities.length > 0) {
                const E = entities[l][clusters[l][ci][7]];
                // entity: register lifespan
	        E[3][E[1].lastIndexOf(ci)] = Date.now() - E[2][E[1].lastIndexOf(ci)];   
	    }
	    // cluster: kill and make tomb
	    clusters[l][ci] = ["tomb"]; 
            const pi = findParentClusterId(l, ci);
	    if (pi !== false) {
	        let P = clusters[l+1][pi];
		P[5].splice(P[5].lastIndexOf(ci),1);
		P[6].splice(P[6].lastIndexOf(ci),1);
	    }
        }
        function findParentClusterId(l, ci) {
	    if (l+1 < clusters.length && clusters[l+1].length > 0) {
	        for (let i = 0; i < clusters[l+1].length; i++)
		    if (clusters[l+1][i].length > 1 && clusters[l+1][i][5].includes(ci)) return i;
	        return false;
	    } else return false;
	}
	function findLiveClusterEntityIds(ci, l, ents = entities) { // find all level l entities with cluster ci
	    let ei = [];		    
//	    if (ents.length <= l) return undefined;
	    for (let i = 0; i < ents[l].length; i++) 
	        if (ents[l][i][1].includes(ci) && ents[l][i][3][ents[l][i][1].lastIndexOf(ci)]==0) 
		    ei.push(i);
            return ei;
        }
	function getMemberCoordinates(l, C) {
	    const nm = C.length;
	    const Bl = clusters[l-1];
            let X = [], Y = [], barycenter = [0, 0];
	    for (let m of C) {
		X.push(Bl[m][0]); Y.push(Bl[m][1]);
		barycenter[0] += Bl[m][0]; barycenter[1] += Bl[m][1];
	    } barycenter[0] /= nm; barycenter[1] /= nm;
	    return [[X, Y], barycenter]; 
	}
	function computeSumSqdis(l, C, M, d = 2) {
	    const Bl = clusters[l-1];
	    const nm = C.length;
            let barycenter = [0, 0], ssd = 0;;
	    for (let m of C) {
		barycenter[0] += Bl[m][0]; barycenter[1] += Bl[m][1];
	    } barycenter[0] /= nm; barycenter[1] /= nm;
	    for (let m of C) {
		switch (d) {
		    case false:
			// skip ssd computation
		    case 2:
			if (M === undefined)
			    ssd += (Bl[m][0] - barycenter[0])**2 + (Bl[m][1] - barycenter[1])**2;
			else
			    ssd += mahalanobisSqDist([Bl[m][0] - barycenter[0], Bl[m][1] - barycenter[1]], M);
		    default: 
		        ssd += Math.abs(Bl[m][0] - barycenter[0])**d + Math.abs(Bl[m][1] - barycenter[1])**d;
		}
	    }
	    return [ssd, barycenter];
	}

        function trySplitting1ClusterGreedily(l) { // Similar to bisecting k-means
	    const Cl = clusters[l];
	    
	    // randomly pick ci
	    let ci, C;
	    do {ci = randint(0, Cl.length-1); C = Cl[ci];} while (C.length == 1); 
	    const nm = C[5].length; 
	    if (nm < 4) return undefined;

            // randomly partition C: n-subset of C, with 2 <= n <= Csize-2
            const n = randint(2, nm-2);  // disallow clusters of size less than 2
	    let mi = [];
	    let H1 = [], H2 = []
	    while (H1.length != n) {
	       const ri = randint(0, nm-1);
	       for (var j = 0; j < mi.length; j++) if (mi[j] == ri) break;
	       if (j == mi.length) {mi.push(ri); H1.push(C[5][ri]);}
	    }
            H2 = subtractSets(C[5], H1);

            // compute sum of intercluster squared distances
	    const [X1, bc1] = getMemberCoordinates(l, H1); 
	    const [X2, bc2] = getMemberCoordinates(l, H2); 
            const D1 = svd(X1, bc1)[3];
            const D2 = svd(X2, bc2)[3];
            const V0 = reconstructCovmat(C);  // V0 = [[1, 0], [0, 1]];
	    const V1 = math.multiply(math.diag(D1.q), D1.v);
	    const V2 = math.multiply(math.diag(D2.q), D2.v);
	    let [ssd0, bc0] = computeSumSqdis(l, C[5], V0); // C[6].reduce((a,b)=>a+b,0);
	    let ssd1 = computeSumSqdis(l, H1, V1, d=2)[0];
	    let ssd2 = computeSumSqdis(l, H2, V2, 2)[0]; 

	    if (l < clusters.length-1) {       
	        const pi = findParentClusterId(l, ci);          // find parent cluster		    
	        if (pi === false)  return undefined;
		else               var P = clusters[l+1][pi]; 
	    } else if (clusters.length-1 == l && clusters[l].length == 1)  
		var P = spawnCluster(x = C[0], y = C[1]); // potential new top cluster 

            // compute sum of inter-centroid squared distances
/*
            ssd0 += (C[0] - P[0])**2 + (C[1] - P[1])**2; // 0 if new top cluster 
            ssd1 += (bc1[0] - P[0])**2 + (bc1[1] - P[1])**2; 
            ssd2 += (bc2[0] - P[0])**2 + (bc2[1] - P[1])**2; 
*/
            ssd0 += mahalanobisSqDist([C[0] - P[0], C[1] - P[1]], V0);  // 0 if new top cluster 
            ssd1 += mahalanobisSqDist([bc1[0] - P[0], bc1[1] - P[1]], V1); 
            ssd2 += mahalanobisSqDist([bc2[0] - P[0], bc2[1] - P[1]], V2); 

	    if (ssd0 > ssd1 + ssd2) {                    
		// kill formerly united cluster
	        killCluster(l, ci); 	  

                // add to entities array and create 2 new clusters
		breedCluster(l, bc1[0], bc1[1], H1);
		breedCluster(l, bc2[0], bc2[1], H2);

                // stack a new top cluster after splitting old topclus
		if (l == clusters.length-1) {
		    P[5] = [clusters[l].length-2, clusters[l].length-1];
		    P[6] = [(bc1[0] - P[0])**2 + (bc1[1] - P[1])**2, (bc2[0] - P[0])**2 + (bc2[1] - P[1])**2];
		    P[7] = 0;
		    clusters.push([P]); 
		    if (entities.length > l+1) findCompoundEntities(0, l+1);
		}

                console.log(`split ${++nsplits}`);
		return [[H1, H2], [ssd1, ssd2]]; 
	    } else 
	        return [[C[5]], [ssd0]];
	}
        
	function tryMerging2ClustersGreedily(l) {
	    if (clusters[l].length == 1) return undefined;

	    const Cl = clusters[l]; 
	    const nc = Cl.length;
	    // pick two arbitrary distinct clusters
            let i1, pi1, i2, pi2;
            do {
		i1 = randint(0, nc-1);            i2 = randint(0, nc-1); 
	        pi1 = findParentClusterId(l, i1); pi2 = findParentClusterId(l, i2);
	    } while (i2 == i1 || Cl[i1].length == 1 || Cl[i2].length == 1) 

	    // find the common parent, else return
	    if (!pi1 || !clusters[l+1][pi1].includes(i2)) return undefined;
	    else                                          var P = clusters[l+1][pi1];   

            // define subclusters
	    const c1 = Cl[i1][5];
	    const c2 = Cl[i2][5];
	    const c3 = filterOutRepeats([...c1, ...c2])
             
            // compute sum of squared distances
            const V1 = reconstructCovmat(Cl[i1]);  // V1 = [[1, 0], [0, 1]];
            const V2 = reconstructCovmat(Cl[i2]); 
	    const [X3, bc3] = getMemberCoordinates(l, c3); 
	    const D3 = svd(X3, bc3)[3];
	    const V3 = math.multiply(math.diag(D3.q), D3.v);
	    let [ssd1, bc1] = computeSumSqdis(l, c1, V1);
	    let [ssd2, bc2] = computeSumSqdis(l, c2, V2);
	    let ssd3        = computeSumSqdis(l, c3, V3)[0]; 

            // compute sum of inter-centroid squared distances
/*		    
            ssd1 += (bc1[0] - P[0])**2 + (bc1[1] - P[1])**2; 
            ssd2 += (bc2[0] - P[0])**2 + (bc2[1] - P[1])**2; 
            ssd3 += (bc3[0] - P[0])**2 + (bc3[1] - P[1])**2; 
*/ 
            ssd1 += mahalanobisSqDist([bc1[0] - P[0], bc1[1] - P[1]], V1); 
            ssd2 += mahalanobisSqDist([bc2[0] - P[0], bc2[1] - P[1]], V2); 
            ssd3 += mahalanobisSqDist([bc3[0] - P[0], bc3[1] - P[1]], V3); 

	    if (ssd3 > ssd1 + ssd2) return [[c1, c2], [ssd1, ssd2]]; 
	    else {                                   
		// kill former halves
	        killCluster(l, i1); killCluster(l, i2);	       
		// create new union
		breedCluster(l, bc3[0], bc3[1], c3);
                console.log(`merge ${++nmerges}`);
	        return [[c3], [ssd3]];
	    }
	}
        function splitMergeClusters() {
	    const N = settings.maxNumLiveClusters;
            for (let l = 1; l < clusters.length; l++) {
		if (numClus()[0][l] == 0) continue;
                if (numClus()[2] < N)     var sc = trySplitting1ClusterGreedily(l);
	        if (numClus()[0][l] > 1)  var mc = tryMerging2ClustersGreedily(l);
            }
        }
        
	function MstepTranslocation(l) {
            for (let i = 0; i < clusters[l].length; ++i) {
		const C = clusters[l][i];
		if (C.length == 1) continue;
                const nm = C[5].length;
                if (nm < minClustMembCount) continue;

		const bc = computeSumSqdis(l, C[5], d = false)[1];
                C[0] = bc[0]; C[1] = bc[1];
		//C[2] = Math.sqrt(ssd / nm);
            }
	}

        function ekmMstepVoronoiTranslocation(V, l) {
            let msd = 0.;   // maximum squared displacement
	    const cl = clusters[l];
            for (let i = 0; i < cl.length; ++i) {
		if (cl[i].length == 1) continue;
		const nnc = V[i][0].length;
                if (nnc >= minClustMembCount) {
		    // translocate
	            const new_x = sumArray(V[i][0]) / nnc, new_y = sumArray(V[i][1]) / nnc;
                    msd = Math.max(msd, (cl[i][0] - new_x)**2, (cl[i][1] - new_y)**2);
                    cl[i][0] = new_x;                cl[i][1] = new_y;
                }
            }
            return msd;
        }
	function svd(X, bc) {
	    const M = zipTwoArrays(X[0].map(v => v - bc[0]), X[1].map(v => v - bc[1])); //m children, n dim
	    const D = SVDJS.SVD(M);  // https://github.com/danilosalvati/svd-js
	    let [[new_sma1, new_sma2], [i1, i2]] = argmax12(D.q);			    
	    const new_tanphi = D.v[1][i1]/D.v[0][i1]; // right singular vectors

	    // two-point clusters yield singular covariance matrices: eschew by setting a positive minimum sma
	    if (X.length == 2) {
		if (D.q.includes(NaN)) {
		    i1 = 0; i2 = 1; 
		    D.q[0] = sumArray(math.diag(M).map(v => math.abs(v))); 
                    D.q[1] = 0;
	        }
		D.q[i2] = Math.max(settings.atoms.radius, D.q[i2]);
	    }

	    return [new_sma1, new_sma2, new_tanphi, D, [i1, i2]];
	}
        function ekmEstepReallocateMstepReshapeKill(V, l) {
	    const cl = clusters[l];
            for (let i = 0; i < cl.length; i++) {
	        if (cl[i].length == 1) continue;  // if cluster dead
				
		if (V[i][2].length >= minClustMembCount) {  //  the cluster remains non-degenerate 

		    // reshape
  		    const [new_sma1, new_sma2, new_tanphi, D, ind] = svd(V[i], cl[i]);
				    
		    // exponential smoothing
	            cl[i][2]    = .95 * cl[i][2]    + .05 * new_sma1;           
	            cl[i][3][0] = .95 * cl[i][3][0] + .05 * new_sma2;          
	            cl[i][3][1] = .95 * cl[i][3][1] + .05 * new_tanphi;           

		    // drawing parameters
		    let hue; 
		    const pi = findParentClusterId(l, i);
		    if (l == topLiveClusLev() || pi === false) hue = 360 * mb32closure();
                    else                                       hue = clusters[l+1][pi][4][0];
		    let saturation, oldestEntObjLifespan, e, ei, newreg;
		    if (cl[i][7] !== undefined && entities[l][cl[i][7]][1].includes(i)) { // if cluster points to its parentity 
                        e = entities[l][cl[i][7]];  // parent entity
                        oldestEntObjLifespan = e[2][e[1].indexOf(i)]; // instead of lastIndexOf
                        saturation = 100 * (Date.now() - oldestEntObjLifespan) / (Date.now() - starttime); 
		    } else saturation = 100 * mb32closure();
                    const lightness = 100 * 1/2;
	            cl[i][4][0] = .95 * cl[i][4][0] + .05 * hue;          
	            cl[i][4][1] = .95 * cl[i][4][1] + .05 * saturation;          
	            cl[i][4][2] = .95 * cl[i][4][2] + .05 * lightness;          
				    
		    // reallocate
		    if (equalMultisets(cl[i][5], V[i][2])) continue; // if cluster members are unchanged
		    cl[i][5] = V[i][2];
		    cl[i][6] = V[i][3];
                    

		    // entity bookkeeping
		    if (entities.length <= l || entities[l].length == 0) continue;  // if ent is not up to date or unused

                    // kill orphaned parEnt objects (above: since cluster members have changed)
		    if (cl[i][7] !== undefined && entities[l][cl[i][7]][1].includes(i)) { // if cluster points to its parentity 
                        e = entities[l][cl[i][7]];  // parent entity
                        e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // kill orphaned ent object and compute lifespan
		    } else {
                        const eis = findLiveClusterEntityIds(i, l);
                        if (eis.length > 0)    
		            for (const ei of eis) { 
			        e = entities[l][ei];   // in theory there should be one and only one old parEnt
                                e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // kill orphaned ent object and compute lifespan
		            }
		        if (eis.length > 1) debugger;
		    }

		    // find new matching parent
                    [ei, newreg] = findCompoundEntities(i, l).slice(1,3); // finds parentity, registers it in clus[7], updates parentity children

		    if (ei === undefined) continue;
		    e = entities[l][ei];
		    oldestEntObjLifespan = e[2][e[1].indexOf(i)]; // instead of lastIndexOf
                    saturation = 100 * (Date.now() - oldestEntObjLifespan) / (Date.now() - starttime); 
	            cl[i][4][2] = .95 * cl[i][4][2] + .05 * saturation;          
				   
                } else {   // if degenerate: kill or recreate degenerate cluster
	            // this avoids singularities when a clusters contains only one point

	            if (entities.length <= l) {          // not in census: abort and replace with last cluster
		        const last = cl.pop(); if (i < cl.length) cl[i] = last; i--;
		    } else {                                    
			let iinent = false, linent = false;   // check if they are registered as ents
		        for (var e of entities[l]) {   
                            if (e[1].includes(i))           {iinent = true; break;} 
			    if (e[1].includes(cl.length-1)) linent = true;       // ent includes last clus id
			}
			if (iinent) {  // in census                  
			    if (e[3][e[1].lastIndexOf(i)]==0) {     // if ALIVE
			        cl[i] = ["tomb"];                               // kill and make tomb
			        e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // lifespan
			    }                                 // if dead, do nothing                               
			} else {   //  not in census
			    if (linent) cl[i] = spawnCluster();         // abort cluster and create new (orphan) cluster
			    else        {const last = cl.pop(); if (i < cl.length) cl[i] = last; --i} // abort and replace with last
                        }					    
                    }
                }
            }  
        }
	function reconstructCovmat(C) {
            const phi = math.atan(C[3][1]);		
	    const R = [[math.cos(phi), -math.sin(phi)], [math.sin(phi), math.cos(phi)]];		
            return math.multiply(R, [[C[2], 0], [0, C[3][0]]]);  
	}
        function findMahalanobisNearestCentroid(x, y, l) {
	    const cl = clusters[l];
            let ncid = -1, ncsd = 1.e38;
            for (let i = 0; i < cl.length; ++i) {
		if (cl[i].length == 1) continue;
                const dx = cl[i][0] - x, dy = cl[i][1] - y;
                const V = reconstructCovmat(cl[i]);  
                const sd = mahalanobisSqDist([dx, dy], V);
                if (sd < ncsd) {
                    ncid = i;
                    ncsd = sd;
                }
            }
            return [ncid, ncsd];
        }

	function sprinkleClusters() {
	    const N = settings.maxNumLiveClusters;

	    //if (clusters.length > 1 && clusters.slice(-1)[0].length == 0) clusters.pop();
            if (clusters.slice(-1)[0].length > 1) clusters.push([spawnCluster()]);

            if (numClus()[2] < N * .8) {
		do for (l of clusters.slice(1)) { 
	            for (c of l) if (c.length == 0) c = spawnCluster();
		    l.push(spawnCluster());
		} while (numClus()[2] < N);
            }
        }

        function findNearestCentroid(x, y, l) {
	    const cl = clusters[l];
            let ncid = -1, ncsd = 1.e38;
            for (let i = 0; i < cl.length; ++i) {
		if (cl[i].length == 1) continue;
                const dx = cl[i][0] - x, dy = cl[i][1] - y;
                const sd = dx ** 2 + dy ** 2;
                if (sd < ncsd) {
                    ncid = i;
                    ncsd = sd;
                }
            }
            return [ncid, ncsd];
        }
        function kmMstepVoronoiTranslocation(V, l) {
	    const cl = clusters[l];
            let msd = 0.;   // maximum squared displacement
            for (let i = 0; i < cl.length; ++i) {
		if (cl[i].length == 1) continue;
                if (V[i][0] >= minClustMembCount) {
                    const new_x = V[i][1] / V[i][0], new_y = V[i][2] / V[i][0];
                    msd = Math.max(msd, (cl[i][0] - new_x)**2, (cl[i][1] - new_y)**2);
                    cl[i][0] = new_x;                cl[i][1] = new_y;
                }
            }
            return msd;
        }

        function kmEstepReallocateMstepReshapeKill(V, l) {
	    const cl = clusters[l];
            for (let i = 0; i < cl.length; i++) {
                let c = cl[i], s = V[i];
	        if (c.length == 1) continue;  // if cluster dead

		if (s[0] >= minClustMembCount) {  // reshape cluster, update parEnts

                    // reshape cluster
                    const new_r = Math.sqrt(s[3] / s[0]) + atomRadius;  // plus atom radius
                    c[2] = 0.95 * c[2] + 0.05 * new_r;  // reshape: exponential smoothing
		    let saturation = s[4][1] / s[0];
                    c[4] = [s[4][0] % 360, saturation, s[4][2] / s[0]];   // repaint

		    // reallocate
		    c[6] = s[6];
		    if (equalMultisets(c[5], s[5])) continue; // if cluster is unchanged
	            c[5] = s[5];		                 

		    // entity bookkeeping
		    if (entities.length <= l || entities[l].length == 0) continue;  // if ent is not up to date 
                    const eis = findLiveClusterEntityIds(i, l);

		    // kill orphaned parEnt objects
		    if (eis !== undefined && eis.length > 0) 
		        for (const ei of eis) { const e = entities[l][ei];   // ideally there should be one and only one
                            e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // kill orphaned ent object and compute lifespan
		        }

		    // find new matching parent
                    let ei = findCompoundEntities(i, l)[1]; // finds parent, registers it in clus[7], updates parent children
                        
		    if (ei !== undefined) { const e = entities[l][ei];
                        saturation = 100*(Date.now()-e[2][e[1].lastIndexOf(i)])/(Date.now()-starttime); 
                        c[4] = [s[4][0] % 360, saturation, s[4][2] / s[0]];   // repaint
		    }

                } else {   // kill or recreate degenerate cluster
	            if (entities.length <= l) {          // not in census: abort and replace with last cluster
		        const last = cl.pop(); if (i < cl.length) cl[i] = last; i--;
		    } else {                                    
			let iinent = false, linent = false;   // check if they are registered as ents
		        for (var e of entities[l]) {   
                            if (e[1].includes(i))           {iinent = true; break;} 
			    if (e[1].includes(cl.length-1)) linent = true; 
			}
			if (iinent) {  // in census                  
			    if (e[3][e[1].lastIndexOf(i)]==0) {     // if ALIVE
			        cl[i] = ["tomb"];                               // kill and make tomb
			        e[3][e[1].lastIndexOf(i)] = Date.now() - e[2][e[1].lastIndexOf(i)];   // lifespan
			    }                                 // if dead, do nothing                               
			} else {   //  not in census
			    if (linent) cl[i] = spawnCluster();         // abort cluster and create new cluster
			    else        {const last = cl.pop(); if (i < cl.length) cl[i] = last; --i} // abort and replace with last
                        }					    
                    }
                }
            }  
        }
	function kmeans(l) {
	    MstepTranslocation(l);
            const maxNumPasses = 10;
	    const cl = clusters[l];
	    const V = new Array(clusters.length).fill([]); // k-means' Voronoi cells
            for (let pass = maxNumPasses; pass >= 0; --pass) {
                for (let j=0; j < cl.length; ++j) V[j] = [0, 0., 0., 0., [0, 0, 0], [], []];
                for (let i=0; i < clusters[l-1].length; i++) {
                    let c = clusters[l-1][i];
		    let [nci, ncsd] = findNearestCentroid(c[0], c[1], l);
                    if (nci >= 0 && ncsd < maxRange**2) {
                        V[nci][0] += 1;
                        V[nci][1] += c[0]; V[nci][2] += c[1];
                        V[nci][3] += ncsd;
 	                for (let v=0; v<3; v++) V[nci][4][v] += c[4][v];
 	                V[nci][5].push(i);
                        V[nci][6].push(ncsd);
                    }
		}
                const msd = kmMstepVoronoiTranslocation(V, l);
		if (msd < 1.) break;
            }
	    kmEstepReallocateMstepReshapeKill(V, l);
	}

	function ellipticalKmeans(l) {
            MstepTranslocation(l);
	    const maxnit = 10;
	    const V = new Array(clusters.length).fill([]); // Voronoi cells
	    // E-step
            for (let it = maxnit; it >= 0; --it) {
                for (let j=0; j < clusters[l].length; ++j) V[j] = [[], [], [], []];
                for (let i=0; i < clusters[l-1].length; i++) {
                    let c = clusters[l-1][i];
		    let [nci, ncsd] = findMahalanobisNearestCentroid(c[0], c[1], l);
                    if (nci >= 0 && ncsd < maxRange**2) {
                        V[nci][0].push(c[0]); V[nci][1].push(c[1]);
                        V[nci][2].push(i);
			V[nci][3].push(ncsd);
                    }
	        }
                const msd = ekmMstepVoronoiTranslocation(V, l);
		if (msd < 1.) break;
            }
            ekmEstepReallocateMstepReshapeKill(V, l);
	}    

        function trackClusters() {
	   // sprinkleClusters();

	    // allocate atoms to clusters[1]: kmeans(atoms, clusters[1]);
	    // allocate clusters[i] to clusters[i+1]
	    for (let l = 1; l < clusters.length; l++) {
		//kmeans(l);
		ellipticalKmeans(l);
	    }

	    splitMergeClusters();
        }

        function drawClusters(l) {
            let i = 0;
            while (i < clusters[l].length) { // clus.length is evaluated only once, at the start of the loop 
                let c = clusters[l][i];
		if (c.length > 1 && c[2] > 0.) {
                    color = hsl2str(...c[4]);
		    if (c[3][1] == 0.) lg = Math.PI * c[2] / c[5].length;
		    else               lg = Math.PI * Math.sqrt(c[2]**2+c[3][0]**2) / c[5].length;
                    drawEllipse(c[0], c[1], [c[2], ...c[3]], color, false, 2*l, [true, lg, lg]);
                } 
	        ++i; 
            }
        }


	/*** ENTITIES ***/

        // entities[l][i]: member ids, live cluster ids, birthtime, lifespan 	
   
        function transcribeClusToEntMultiset(ci, l, ents = entities) {
	    // does NOT check for cluster id uniqueness 
	    let mulset = [];
	    for (let c of clusters[l][ci][5])
                for (let k = 0; k < ents[l-1].length; k++)
	            if (ents[l-1][k][1].includes(c) && ents[l-1][k][3][ents[l-1][k][1].lastIndexOf(c)]==0) 
		        mulset.push(k); 
             if (mulset.length != clusters[l][ci][5].length) debugger; //return undefined;
	     else                                            return mulset;
	}
	function findAtomicEntities(ents) { 
	    if (ents.length == 0) ents[0] = [];
	    for (let j = 0; j < settings.numColors; j++) {
		if (ents[0].length-1 < j) ents[0].push([j, [], [], []]); 
                for (let i = 0; i < clusters[0].length; i++) 
		    if (clusters[0][i][5] == j && !ents[0][j][1].includes(i)) {
		        ents[0][j][1].push(i);
		        ents[0][j][2].push(Date.now());
		        ents[0][j][3].push(0);
			clusters[0][i][7] = j;
		    }
	    }
	    return ents;
	}
	function findCompoundEntities(ci, l, ents = entities) { 
	    // find entity with id ei in level l corresponding to cluster id ci; if absent, create entity and append
	    mulset = transcribeClusToEntMultiset(ci, l);
            //if (mulset === undefined) return [ents, undefined, false]; // prevents catching bugs?

	    let newreg = false;  // new ent registered ?
	    for (var ei = 0; ei < ents[l].length; ei++) { // loop2:
	        if (equalMultisets(mulset, ents[l][ei][0])) {      // if the multiset is already registered
	            if (!ents[l][ei][1].includes(ci) ||                                                  // cluster object not registered
	                (ents[l][ei][1].includes(ci) && ents[l][ei][3][ents[l][ei][1].lastIndexOf(ci)] > 0)) {    // cluster object registered but dead
	                ents[l][ei][1].push(ci);
	                ents[l][ei][2].push(Date.now());
	                ents[l][ei][3].push(0);
	                clusters[l][ci][7] = ei;
			newreg = true;
	            }   
	            return [ents, ei, newreg]; //ei=0; break; // continue loop2;   // cluster object registered and alive
	        }
	    }
	    if (ei == ents[l].length) {   // multiset not registered
	        ents[l].push([mulset, [ci], [Date.now()], [0]]);
	        clusters[l][ci][7] = ei;
		newreg = true; // new entity created: true
	    } 
	    return [ents, ei, newreg]; 
	}
	function findEntitiesNow(ents = [[]]) { 
	    if (clusters.length == 0) return ents;

	    ents = findAtomicEntities(ents);

	    for (l = 1; l < clusters.length; l++) {	    
		if (ents.length == l && clusters[l].length > 0) ents.push([]);
	        for (let i = 0; i < clusters[l].length; i++) {   //loop2:
	            if (clusters[l][i].length < 2 || clusters[l][i][5].length < 2) continue; 
	            ents = findCompoundEntities(i, l, ents)[0];
		}
	    }
	    return ents;
        }

	function numEnts() {
	    let nl = [numAtomTypes], nd = [0];
	    for (l = 1; l < entities.length; l++) {	   
		nl[l] = 0; nd[l] = 0;
		for (let i = 0; i < entities[l].length; i++) {
		    if (!entities[l][i][3].includes(0)) nd[l]++;
		    else                                nl[l]++;
		}
	    }
	    return [nl, nd];
        }	

	    

	/*** PHYSICS ***/

        // Enact atomic interactions
        const stepForward = () => {
            const c = 10 ** settings.damping;
            const dt = 10 ** settings.logTimeStep;
            const n = settings.interaction_law;
            mav = 0.; msv = 0.;

            // update velocity 
            for (const a of atoms) {
                let Fx = 0, Fy = 0;
                const idx = a[5] * settings.numColors;
                const rang2 = settings.range[settings.colors[a[5]]]**2;
                for (const b of atoms) {
		    const g = settings.interactionForces[settings.colors[a[5]]][settings.colors[b[5]]];
		    let dx = a[0] - b[0], dy = a[1] - b[1];
	            if (settings.wraparound) {
		   	const dxpm = [dx-canv.width, dx, dx+canv.width], dypm = [dy-canv.height, dy, dy+canv.height];
                        const dxa = dxpm.map(Math.abs),                  dya = dypm.map(Math.abs);
			const dxi = dxpm.indexOf(Math.min(...dxa)),      dyi = dypm.indexOf(Math.min(...dya));
			dx = dxpm[dxi];			                 dy = dypm[dyi];							
 		    }
                    if (dx !== 0 || dy !== 0) {
                        const dr2 = dx ** 2 + dy ** 2;
                        if (dr2 < rang2) {
                            //const F = g / Math.sqrt(dr2);   // inverse law: n = -1
                            const F = g * Math.sqrt(dr2) ** n;    // inverse-square law: n = -2
                            Fx += F * dx; Fy += F * dy;

                            // draw lines between interacting atoms 
                            if (settings.drawings.forcelines) drawInteraction(a[0], a[1], b[0], b[1], settings.colors[b[5]]);                            
                        }
                    }
                }
                if (prod_st != 0) {
                    const dx = a[0] - prod_x, dy = a[1] - prod_y;
                    const dr2 = dx ** 2 + dy ** 2;
		    if (dr2 > 0 && dt > 0) {
                        const prodForce = 100. * prod_st / (dr2 * dt);  // inverse square law
                        Fx += prodForce * dx; Fy += prodForce * dy;
                    }
                }
                if (settings.wallThickness > 0) {
                  const wt = settings.wallThickness, we = settings.wallElasticity;
                  if (a[0] < wt)               Fx += (wt - a[0]) * we;
                  if (a[0] > canv.width - wt)  Fx += (canv.width - wt - a[0]) * we;
                  if (a[1] < wt)               Fy += (wt - a[1]) * we;
                  if (a[1] > canv.height - wt) Fy += (canv.height - wt - a[1]) * we;
                }

                Fy += settings.gravity;

		// dynamic equation with damping coefficient: dv/dt = -c*v  =>  v = exp(-c*t) ~ -c*t => v1-v0 ~ -c*(t1-t0) ~ -c*dt
                //a[2] -= c * a[2] * dt; a[3] -= c * a[3] * dt;  // the damping coefficient multiplies velocity
		// dynamic equation with drag coefficient: dv/dt = -c*v^2  => v = 1/(c*t) => v1-v0 ~ 1/c*(1/t1-1/t0) = (t0-t1)/(c*t0*t1) = -dt*c*v1*v0 ~ -dt*c*v1^2
		// drag coefficient (skin friction and form drag) depends on the Reynolds number for fluids
		if (Math.abs(c*a[2]*dt) >= 1) a[2] = 0; else a[2] -= c * a[2]**2 * dt * Math.sign(a[2]);
		if (Math.abs(c*a[3]*dt) >= 1) a[3] = 0; else a[3] -= c * a[3]**2 * dt * Math.sign(a[3]);
		
		// dp/dt = F
		a[2] += Fx * dt; a[3] += Fy * dt;

                // record typical activity, to later update logTimeStep accordingly
                mav += Math.abs(a[2]) + Math.abs(a[3]);
                msv += a[2]**2 + a[3]**2;
            }
            mav /= atoms.length; msv /= atoms.length;
	    cvNkT.push(msv);
	    const ssd = sumArray(sumSqdisNow()); if (ssd > innerHeight**2/4) mssd.push(ssd/numAtomsNow());

            // update positions 
            for (const a of atoms) {
                // dr/dt = v 
                a[0] += a[2] * dt; a[1] += a[3] * dt;

                // upon reaching the canvas fringes
		if (!settings.wraparound) { // hard wall		
                    if (a[0] < 0)            {a[0] = -a[0] % canv.width;                     a[2] *= -1;} // x wraps around if ricochet exceeds width
                    if (a[0] >= canv.width)  {a[0] = (2 * canv.width - a[0]) % canv.width;   a[2] *= -1;} // x<0 and idem if ricochet exceeds width
                    if (a[1] < 0)            {a[1] = -a[1] % canv.height;                    a[3] *= -1;} // idem
                    if (a[1] >= canv.height) {a[1] = (2 * canv.height - a[1]) % canv.height; a[3] *= -1;} // idem
                } else {                            // wrap around with toroidal topology
		    settings.wallThickness = 0;
		    if (a[0] > canv.width)  a[0] %= canv.width;
		    else if (a[0] < 0)      a[0] = canv.width + a[0] % canv.width; //a[0] += canv.width;
		    if (a[1] > canv.height) a[1] %= canv.height;
		    else if (a[1] < 0)      a[1] = canv.height + a[1] % canv.height;
		}
            }
        };



	/*** LET THERE BE LIGHT ***/

	let starttime = Date.now();

        // Initialize PRNG seed 
        var mb32closure = mulberry32prng(settings.seed);  // closure PRNG initialized with seed
        getSeedFromUrlFragment();

	// Draw canvas
        const canv = document.getElementById("mycanvas");
        const crc = canv.getContext("2d");
        updateCanvas();      // stretch canvas to cover window and paint it

        // Set interaction forces
        setColors();
        randomInteractions();

        // Create atoms, initialize clusters and entities
        const atoms = new Array();
        const clusters = [], entities = [];
	let nsplits, nmerges;
        restartAtoms(settings.atoms.count, true);

	// Set up sundry functionalities  
        var prod_st = 0, prod_x = 0, prod_y = 0; // click-induced pulse-shaped in time and strength prod 
        var exploration_timer = 0;
        var mav, msv;  // mean absolute velocity as an estimate of on-screen activity, mean sq velocity
	const cvNkT = []; // specific internal energy: U/N = v^2/N
	const mssd = []; // mean ssd, or specific free energy time series
        setupGui();
        setupHotkeys();
        setupProd();
	// Plotting
        const plt = document.getElementById("fig01");
	plt.style.height = canv.height * 0.9;
        let layout = {grid: {rows:6, columns:1, roworder: "top to bottom"}, barmode: "overlay", 
	              title: "plotly", showlegend: true, margin: {l: 30, r: 10, b: 20, t: 20, pad: 5},
		      xaxis1: {anchor: "y1"}, xaxis2: {anchor: "y5"},  
		      xaxis6: {anchor: "y6", type: "linear", autorange: true}, yaxis6: {type: "log"}};


        /*** MOVE ONWARD: REFRESH AND READJUST ***/

        let oldnow = performance.now(); //Date.now();
        repaint();

	function repaint(timeStamp) {
            updateCanvas();
			
            stepForward();

            // draw atoms
            for (const a of atoms) {
                if (settings.drawings.round) drawEllipse(a[0], a[1], settings.atoms.radius, hsl2str(...a[4]));
                else                         drawSquare(a[0], a[1], settings.atoms.radius, hsl2str(...a[4]));                
            }
            if (settings.drawings.clusters) {
	        trackClusters();

	        // draw clusters
                for (let l = 1; l < clusters.length; l++) drawClusters(l);

	        // discover entities
	        if (entities.length < clusters.length) findEntitiesNow(entities);
		else for (const e of entities) if (e.length==0) {findEntitiesNow(entities); break;}
            }

            readjust(timeStamp);

	    plots();

	    // Tally atoms within canvas
            //const inSight = (a) => 0 <= a[0] && a[0] < canv.width && 0 <= a[1] && a[1] < canv.height;
            //console.log('atoms in sight', atoms.filter(inSight).length);  

            window.requestAnimationFrame(repaint);
        };

        // post-frame stats and readjustments
        function readjust(timeStamp) {
            // record fps
            if (timeStamp > oldnow) {
                const new_fps = 1000. / (timeStamp - oldnow);
                settings.fps = Math.round(settings.fps * 0.8 + new_fps * 0.2)
                oldnow = timeStamp;
            }

            // adapt logTimeStep based on activity
	    let dt = 10 ** settings.logTimeStep;
            if (mav > 30. && dt > 5.) dt /= 1.1;
            if (dt < 0.9) dt *= 1.01; else if (dt > 1.1) dt /= 1.01;
	    settings.logTimeStep = Math.log10(dt);

	    // decrease prod duration if positive 
            if (prod_st != 0) prod_st -= (prod_st > 0) ? 1 : -1;

            if (settings.explore) roamParamspace();
        }


	/*** PRINT STATS ***/ 

        function numAtomsNow() {return settings.atoms.count * settings.colors.length;}    
        function numClus() {
	    let nl = [], nd = [], sl = 0, sd = 0;
	    if (clusters.length>1) for (l = 1; l < clusters.length; l++) {
		nl[l] = 0; nd[l] = 0;
	        for (c of clusters[l]) (c.length > 1) ? nl[l]++ : nd[l]++;
		sl += nl[l]; sd += nd[l];
	    }
	    return [nl, nd, sl, sd];
	}
	function topLiveClusLev() {
	    for (l = 1; l < numClus()[0].length; l++)
	        if (numClus()[0][l] == 0) return l -1;
	    return l;
	}
	function sumSqdisNow() { 
	    let ssd = new Array(clusters.length).fill(0);
	    for (let l=1; l < clusters.length; l++)
		for (const c of clusters[l]) if (c.length > 1 && c[6].length > 0)
	            for (const d of c[6]) ssd[l] += d;
            return ssd;			    
	}
	function topbotSqdistsNow() { 
	    let sumsqdis = 0;
	    if (clusters.length == 0) return sumsqdis;
	    topclus = clusters.slice(-1)[0][0];
	    if (clusters.slice(-1)[0].length==1 && topclus != undefined) {
	        for (let a of atoms){
		    let d2 = (a[0] - topclus[0])**2 + (a[1] - topclus[1])**2;
	            sumsqdis += d2;
	        }
	    }
            return sumsqdis;			    
	}
        
        function biggestClus() {
            let c = [], numemb = [];  	    
	    for (let l = 1; l < clusters.length; l++) {
		[c[l], numemb[l]] = [0, 0];
	        for (let j = 0; j < clusters[l].length; j++) 
		    if (clusters[l][j].length > 1  && clusters[l][j][5].length > numemb[l]) 
		        {c[l] = j; numemb[l] = clusters[l][j][5].length;}
	    }
	    return numemb // [...c, ...numemb]
        }

        function lifespans() {
	    let s = [];
	    for (l = 1; l < entities.length; l++) {
		s[l] = [];
	        for (e of entities[l]) 
		    for (i=0; i< e[1].length; i++) 
			if (e[3][i] > 0) s[l].push(e[3][i]/10**3); else s[l].push((Date.now() - e[2][i])/10**3);
	    }
            return s; 
	}
	
        console.log("settings", settings)

	let numclus = 0; 
        window.setInterval(() => {
            if (numClus()[2] != numclus) {
		console.log(clusters);
		console.log('Number of atoms, maxClus, clusters:', numAtomsNow(), settings.maxNumLiveClusters, numClus())
	        let ssd = sumSqdisNow().map((x) => Math.round(x));
	        let totdis = Math.round(ssd.reduce((a,b)=>a+b,0));
		console.log("SSDs: ", ssd, totdis, totdis/numAtomsNow(), Math.round(100*totdis/topbotSqdistsNow()))
		console.log("Biggest clusters: ",biggestClus())
		numclus = numClus()[2];
	    }
	    //if (numDeadClusNow()>0) alert(`${numDeadClusNow()} cluster(s) died`);
	}, 1000);


        /*** PLOTTING ***/

	function vsqrt(x) {return x.map(el => Math.sqrt(el))};
	function vlog10(x) {return x.map(el => Math.log10(el))};
	function vllog10(x) {return x.map(el => Math.log10(el.length))};
	function plots() {
	    let cl = Array(clusters.length).fill().map((elm, ind) => ind);
	    let ts = Array(cvNkT.length).fill().map((elm, ind) => ind);
	    let trace0 = {name: "MSV", x: ts, y: vlog10(cvNkT), xaxis: "x1", yaxis: "y1"};
	    let trace1 = {name: "RMSD", x: ts, y: vsqrt(mssd), xaxis: "x1", yaxis: "y2"};
	    let trace2 = {name: "bigclus",x: cl, y: vlog10(biggestClus()), xaxis: "x2", yaxis: "y3", type: "scatter"};
	    let trace3 = {name: "live ents", x: cl, y: vlog10(numEnts()[0]), xaxis: "x2", yaxis: "y4"};
	    let trace4 = {name: "dead ents", x: cl, y: vlog10(numEnts()[1]), xaxis: "x2", yaxis: "y4"};
	    let trace5 = {name: "all ents now", x: cl, y: vllog10(findEntitiesNow()), xaxis: "x2", yaxis: "y4"};
	    let trace6 = {name: "live clus", x: cl, y: vlog10(numClus()[0]), xaxis: "x2", yaxis: "y5"};
	    let trace7 = {name: "dead clus", x: cl, y: vlog10(numClus()[1]), xaxis: "x2", yaxis: "y5"};

	    let tracehist = [];
	    for (let i=1; i < entities.length; i++) 
	    tracehist[i-1] = {name: `count L${i}`, x: lifespans()[i], type: 'histogram', histfunc: "count", opacity: .4, xaxis: "x6", yaxis: "y6"};
	    Plotly.newPlot(plt, [trace0, trace1, trace2, trace3, trace4, trace5, trace6, trace7, ...tracehist], layout); 
        }


        /*** RECORD VIDEO ***/ 

        function dataUrlDownloader(dataURL, name = `Racemi_${settings.seed}`) {
            const hyperlink = document.createElement("a");
            // document.body.appendChild(hyperlink);
            hyperlink.download = name; // the target will be downloaded on clicking on the hyperlink
            //hyperlink.target = '_blank';
            hyperlink.href = dataURL;
            hyperlink.click();  // HTMLElement.click() method simulates a mouse click on an element
            hyperlink.remove();
        };

        const videoStream = canv.captureStream(); // stream 
        const mediaRecorder = new MediaRecorder(videoStream); // video recorder
        let chunks = []; // temporal chunks

        mediaRecorder.ondataavailable = (e) => chunks.push(e.data); // store chunks
        mediaRecorder.onstop = function (e) {
            const blob = new Blob(chunks, { 'type': 'video/mp4' }); // chunks --> blob
            const videoDataURL = URL.createObjectURL(blob); // blob --> dataURL
            dataUrlDownloader(videoDataURL); // download video
            chunks = []; // reset chunks
        };
        // mediaRecorder.start(); // start recording
        // mediaRecorder.stop(); // stop recording


    </script>

</body>

</html>
