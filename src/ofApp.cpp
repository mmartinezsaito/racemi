#include "ofApp.h"
#include "ofUtils.h"

#include <cmath> // cmath makes available the C math functions, and C doesn't have namespaces
#include <set>
#include <iterator>
#include <numeric>



// RANDOM NUMBERS

// brief Return a random float in range [a,b[
inline float randomFloat(float a, float b) { // same as ofRandom(a, b)
	const float diff = b - a;
	const float r = ofRandomuf() * diff;  //ofRandomuf() yields [0, 1[
	return a + r;
}
// overload to define default second argument
inline float randomFloat(const float a) {
	return randomFloat(-a, a);   // randomFloat(1) = ofRandomf() [-1, 1]
}
// simple standard library random float
inline float ranf01() {
       return static_cast<float>(rand()) / static_cast<float>(RAND_MAX);
}
// ofRandom functions from ofMath 
// github.com/openframeworks/openFrameworks/blob/master/libs/openFrameworks/math/ofMath.cpp#L46


// RNG
// en.cppreference.com/w/cpp/numeric/random/random_device
std::random_device rd;  // to obtain a seed for the random number engine
// en.cppreference.com/w/cpp/numeric/random/mersenne_twister_engine
std::mt19937 mterui(rd()); // standard mersenne_twister_engine seeded with rd()
std::uniform_int_distribution<unsigned int> uid(0, 99); // use uri to map the random unsigned int generated by mterui into [0, 99] 
						    // each call to uid(gen) generates a new random int in [0, 99]
std::uniform_real_distribution<> urd0(0.0, 1.0); // use urd to transform the random unsigned int generated by mterui 
std::uniform_real_distribution<> urd2(0.0, 100.0); 

 

// GRID
grid subdiv;


// ARRAYS

// sign function
//template functions have to be declared and defined in the same file
template <typename T> 
int sgn(T val) {
    return (T(0) < val) - (val < T(0));
}

// sum array elements
template <typename T>
T vectorSum(std::vector<T> v) {
	T sum = 0;
	//for (int i = 0; i < v.size(); i++)
	//	sum += v[i]; 
	sum = std::accumulate(v.begin(), v.end(), T(0));
	return sum; 
};
// multiply array elements
template <typename T>
T vectorProd(std::vector<T> v) {
	T prod = std::accumulate(v.begin(), v.end(), T(1), std::multiplies<T>());
	return prod; 
};
// return array elements' absolute value
template <typename T>
std::vector<T> vectorAbs(std::vector<T> v) {
	for (unsigned int i = 0; i < v.size(); i++)
		v[i] = std::abs(v[i]); 
	return v; 
};

// test equality
template <typename T>
bool equalArrays(std::vector<T> arr1, std::vector<T> arr2) {
	if (arr1.size() != arr2.size()) 
		return false;
	for (int i = 0; i < arr1.size(); i++) 
		if (arr1[i] != arr2[i]) 
			return false;
	return true;
};
// zip two arrays
std::array<std::vector<float>,2> zipTwoArrays(std::vector<float> arr1, std::vector<float> arr2) {
	std::array<std::vector<float>,2> za = {std::vector<float>(arr1.size()), std::vector<float>(arr2.size())};
	for (unsigned int i = 0; i < arr1.size(); i++) { 
		za[i][0] = arr1[i]; za[i][1] = arr2[i];	
	}
	return za;
};
std::array<std::vector<float>,2> zipTwoArrays(std::array<float,2> arr1, std::array<float,2> arr2) {
	std::vector<float> v1(std::begin(arr1), std::end(arr1));
	std::vector<float> v2(std::begin(arr2), std::end(arr2));
	return zipTwoArrays(v1, v2);
};
Eigen::ArrayX2f zipTwoArrays(Eigen::ArrayXf arr1, Eigen::ArrayXf arr2) {
	Eigen::ArrayX2f za(arr1.size(), 2); 
	za << arr1, arr2;	
	return za;
};
template <typename T>
std::vector<T> zipSumTwoArrays(std::vector<T> arr1, std::vector<T> arr2) {
	std::vector<T> sa(arr1.size(), 0);
	for (int i = 0; i < arr1.size(); i++) 
		sa[i] = arr1[i] + arr2[i];
	return sa;
};
// max and argmax, argmin
template <typename T>
T vectorMax(std::vector<T> v) {
	typename std::vector<T>::iterator it;
	it = std::max_element(v.begin(), v.end()); // algorithm library 
	return *it;
};
template <typename T>
unsigned int vectorArgmax(std::vector<T> v) {
	auto it = std::max_element(v.begin(), v.end());  // auto to not think anymore
	// distance works with any forward iterator type, not just random-access iterators like vector's
	unsigned int maxind = std::distance(v.begin(), it);  // it - v.begin()
	return maxind;
};
template <typename T>
unsigned int vectorArgmin(std::vector<T> v) {
	auto it = std::min_element(v.begin(), v.end());  // auto to not think anymore
	unsigned int minind = std::distance(v.begin(), it);  // it - v.begin()
	return minind;
};
// compute array stdev
float vectorSumsq(std::vector<float> v, float center) {
	float ssq = 0;
	for (float el : v)
		ssq += (el - center)*(el - center); 
	return ssq; 
}
float vectorSumsq(std::vector<float> v) {
	float mean = vectorSum(v) / v.size(); 
	return vectorSumsq(v, mean);
}
float vectorStdev(std::vector<float> v, float center) {
	return std::sqrt(vectorSumsq(v, center) / v.size());
}
float vectorStdev(std::vector<float> v) {
	return std::sqrt(vectorSumsq(v) / v.size());
}
template <typename T> 
bool vectorIncludes(const std::vector<T>& v, const T x) {
	return std::find(v.begin(), v.end(), x) != v.end(); 
}
template<typename T>
std::ostream& operator<<(std::ostream& os, std::vector<T> const& v) {
	os << '{';
	for (auto n{v.size()}; auto const& e : v)
		os << e << (--n ? ", " : "");
	return os << '}';
}


// SETS

template <typename T>
bool equalSets(std::vector<T> arr1, std::vector<T> arr2) {
        // cplusplus.com/reference/set/set/set/
	// geeksforgeeks.org/set-vs-unordered_set-c-stl/
	//std::set<T> s1(arr1), s2(arr2); 
	std::set<T> s1(arr1.begin(), arr1.end()), s2(arr2.begin(), arr2.end());
	return s1 == s2;
};
template <typename T>
std::vector<T> subtractSets(std::vector<T> arr1, std::vector<T> arr2) {
	std::vector<T> v;
	// with pre-ordered sets: stackoverflow.com/questions/60008057/how-to-get-unordered-set-difference-or-symmetric-difference-in-c
	std::sort(arr1.begin(), arr1.end());
	std::sort(arr2.begin(), arr2.end());
	std::set_difference(arr1.begin(), arr1.end(), arr2.begin(), arr2.end(), std::inserter(v, v.begin())); 
	return v;	
};
template <typename T>
std::vector<T> intersectSets(std::vector<T> arr1, std::vector<T> arr2) {
	std::vector<T> v;
	std::set_intersection(arr1.begin(), arr1.end(), arr2.begin(), arr2.end(), std::back_inserter(v)); 
	return v;	
};
template <typename T>
bool equalMultisets(std::vector<T> arr1, std::vector<T> arr2) {
	// https://en.cppreference.com/w/cpp/container/multiset
	std::multiset<T> s1(arr1.begin(), arr1.end()), s2(arr2.begin(), arr2.end());
	return s1 == s2;
};


// LINEAR ALGEBRA

// (template) Alias / typedefs
template <typename T>
using matrix = std::vector<std::vector<T>>; //typedef vector<vector<int>> matrix;

// matrix multiplication
template <typename T>
matrix<T> matmult(matrix<T> A, matrix<T> B) {
	const int n = A.size();     // A rows
	const int m = A[0].size();  // A cols and B rows
	const int p = B[0].size();  // B cols
	matrix<T> C(n, vector<T>(p, 0));
	for (int i = 0; i < n; i++)
		for (int j = 0; j < p; j++) 
			for (int k = 0; k < m; k++)
				C[i][j] += A[i][k] * B[k][j];
	return C;
};
// mahalanobis inner product
float mip(Eigen::Vector2f x, Eigen::Matrix2f C, Eigen::Vector2f y) {
	const Eigen::Matrix2f P = C.inverse();
	//ofLogVerbose() << "mip " << 1.f/2 * x.adjoint() * P * y << " " << x << "\n" << C << "\n" << P << "\n" << endl; 
	return 1.f/2 * x.adjoint() * P * y;
};
float mip(Eigen::Vector2f x, Eigen::Matrix2f C) { // overload
	return mip(x, C, x);
};
// negative log-Gaussian function
float nlg(Eigen::Vector2f x, Eigen::Matrix2f C) {
	//return 1.f/2 * std::log((M_PI * C).determinant()) + mip(x, C);
	return 1.f/2 * std::log(std::pow(2*M_PI, ofApp::nd) * C.determinant()) + mip(x, C);
};
// singular value decomposition from member coordinates
JsvdXf svdFromCoords(std::array<std::vector<float>,2> X, std::array<float,2> bc) {
	const unsigned int nrows = X[0].size();
	// the non-zero elements of S (singular values) are the square roots of the non-zero eigenvalues of MtM or MMt
	//  M = U * S * Vt,  (V is transposed);    Mt * M = V * St*S * Vt
	Eigen::ArrayXf Xc1 = Eigen::Map<Eigen::ArrayXf>(X[0].data(), nrows); 
	//Eigen::ArrayXf Xc2 = Eigen::Map<Eigen::ArrayXf>(X[1].data(), nrows);  
	float * fp = X[1].data();
	Eigen::ArrayXf Xc2 = Eigen::Map<Eigen::ArrayXf>(fp, nrows);  
	//en.wikipedia.org/wiki/Estimation_of_covariance_matrices
	//divide by sqrt(nrows-1) to get correct semiaxes singvals because we want to divide the covariance matrix by nrows-1
	Xc1 -= bc[0]; Xc2 -= bc[1];
	Xc1 /= std::sqrt(nrows - 1); Xc2 /= std::sqrt(nrows - 1);
	//SVDBase: thin U and V are only available when your matrix has a dynamic number of columns.
	//gitlab.com/libeigen/eigen/-/issues/2051
	Eigen::MatrixXf M(zipTwoArrays(Xc1, Xc2).matrix());

	// eigen.tuxfamily.org/dox/classEigen_1_1JacobiSVD.html; eigen.tuxfamily.org/dox/classEigen_1_1SVDBase.html
	JsvdXf svd;  
	svd.compute(M, Eigen::ComputeThinV | Eigen::ComputeThinU);

if (nrows > 17 && ((svd.singularValues()[0] < 1 && svd.singularValues()[0] > 0) && 
		   (svd.singularValues()[1] < 1 && svd.singularValues()[1] > 0))) {
  //throw std::invalid_argument("collapsed cluster");
  cout << "\nquasi-collapsed cluster\nPress Enter for getchar() to continue\n";
  //getchar(); // wait for user input Enter
}

	//ofLogVerbose() << M.size() << endl << M.transpose()*M << endl << M.mean() << endl << M.colwise().mean() << endl;
	return svd;
}

Eigen::Vector2f regularizeCovmat(std::array<std::vector<float>,2> X, Eigen::Vector2f sv) {
	ofLogVerbose() << "sv " <<  sv(0) << " " << sv(1);
	// two-point clusters yield singular covariance matrices: eschew by setting a positive minimum sma
	if (X[0].size() == 2) {
		// std::find(v.begin(), v.end(), item) != v.end() ; std::find_if(v.begin(), v.end(), std::isnan)
		if (std::isnan(sv(0) || std::isnan(sv(1))) || std::isinf(sv(0)) || std::isinf(sv(1))) {
			sv(0) = std::abs(X[0][0]) + std::abs(X[1][1]); // dirty patch
			sv(1) = 0;
		}	
		sv(1) = std::max(Atom::ra, sv(1)); // 2*Atom::ra
	} else if(X[0].size() == 1) 
		throw std::invalid_argument("single child cluster");
	return sv;
}




// Atom groups by color
std::vector<Atom> red, green, blue, white, yellow;

// draw all atoms from a vector<Atom>*
void drawAtoms(const std::vector<Atom>* atoms) {
	for (auto& atom : *atoms) atom.draw();
}

void setAtomsAlpha(std::vector<Atom>* atoms, const int a) {
	// don't make vector const to modify atom's members
	for (auto& atom : *atoms) atom.a = a;
}

// Generate a number of single colored atoms randomly distributed on canvas
std::vector<Atom> createAtoms(const int num, const int r, const int g, const int b, float m) {
	std::vector<Atom> atoms;
	atoms.reserve(num);
	for (auto i = 0; i < num; i++) {
		int x = static_cast<int>(ofRandomWidth());
		int y = static_cast<int>(ofRandomHeight());
		atoms.emplace_back(x, y, r, g, b, m);   //append
	}
	return atoms;
}



// INTERACTIONS

// for collision detection :
//if (distance(x center, x line) < radius) then intersect 

// interaction coefficients matrix to Slider objects 
void ofApp::mat2ixc(float M[nc][nc]) {
	ixcSliderRR = M[0][0]; ixcSliderRG = M[0][1]; ixcSliderRB = M[0][2]; ixcSliderRW = M[0][3];
	ixcSliderGR = M[1][0]; ixcSliderGG = M[1][1]; ixcSliderGB = M[1][2]; ixcSliderGW = M[1][3];
	ixcSliderBR = M[2][0]; ixcSliderBG = M[2][1]; ixcSliderBB = M[2][2]; ixcSliderBW = M[2][3];
	ixcSliderWR = M[3][0]; ixcSliderWG = M[3][1]; ixcSliderWB = M[3][2]; ixcSliderWW = M[3][3];
}
// interaction ranges matrix to Slider objects 
void ofApp::mat2ixr(float M[nc][nc]) {
	ixrSliderRR = M[0][0]; ixrSliderRG = M[0][1]; ixrSliderRB = M[0][2]; ixrSliderRW = M[0][3];
	ixrSliderGR = M[1][0]; ixrSliderGG = M[1][1]; ixrSliderGB = M[1][2]; ixrSliderGW = M[1][3];
	ixrSliderBR = M[2][0]; ixrSliderBG = M[2][1]; ixrSliderBB = M[2][2]; ixrSliderBW = M[2][3];
	ixrSliderWR = M[3][0]; ixrSliderWG = M[3][1]; ixrSliderWB = M[3][2]; ixrSliderWW = M[3][3];
}

/**
 * @brief Interaction between two atom colors
 * @param vecol1: the group that will be affected by the interaction
 * @param vecol2: the effector group (not affected)
 * @param ixcoef:      interaction coefficient
 * @param ixrang:  range of interaction
 */
void ofApp::interact(unsigned int ac1, unsigned int ac2, const float ixcoef, const float ixrang) {
	std::vector<Atom>* vecol1 = atoms.colors[ac1];
	std::vector<Atom>* vecol2 = atoms.colors[ac2];
	const bool isInfRange = infiniteRangeToggle;
	const float dt = std::pow(10, log10TimeStep); 
	const float c = viscosityToggle ? std::pow(10, log10DampingCoef) : 0.f;
	const float n = interactionLaw;
	const float interacProb100 = std::pow(10, interacLog10Prob100);

	boxHeight = ofGetHeight();
	boxWidth = ofGetWidth();

	#pragma omp parallel 
	{ 

		// omp for directive instructs the compiler to distribute loop iterations within the team of threads 
		#pragma omp for 
		for (unsigned int i = 0; i < vecol1->size(); i++) {
			if (urd2(mterui) < interacProb100) {   // dis(gen) % 100 < prob
				auto& a = (*vecol1)[i];
				float Fx = 0;
				float Fy = 0;

				// This inner loop is where most of the CPU time is spent
				for (unsigned int j = 0; j < vecol2->size(); j++) {
					const auto& b = (*vecol2)[j];

					float dx = a.x - b.x;
					float dy = a.y - b.y;

					if (dx == 0 && dy == 0) // if *a == *b 
						continue;  // don't interact with yourself

					if (wrapAroundToggle) {
						const vector<float> dxpm{dx-boxWidth,dx,dx+boxWidth}, dypm{dy-boxHeight,dy,dy+boxHeight};
						const vector<float> dxa{vectorAbs(dxpm)},             dya{vectorAbs(dypm)};
                    				unsigned int        dxi = vectorArgmin(dxa),          dyi = vectorArgmin(dya);
						dx = dxpm[dxi]; dy = dypm[dyi];
					}

					const auto dr2 = dx * dx + dy * dy;  // pow(dx, 2)
					const float dr = std::sqrt(dr2);

					// calculate interaction forces  
					if ((dr < ixrang || isInfRange) && dr2 != 0.f) {
						// n-1 to normalize (dx,dy) to unit vector
						float F = ixcoef * std::pow(dr, n); 

						// assume finite spherical particle uniformly charged
						// note this is correct only for n+nd=1, eg -1+2=1: 
						// shells have:
						//     field:     inside zero (0), outside power n (-2, -1)
						//     potential: inside constant (0), outside power n+1 (-1, log) 
						// for solid spheres this yields a:
						//    continuous central field: linear inside (1), power n outside (-2, -1)
						//    derivable potential:      parabolic inside (2), power n+1 outside (-1, log)
						if (regularPotentialToggle && dr <= Atom::ra)
							// charged shell: nd-1+n=0
							//f = ixcoef * std::pow(Atom::ra, n); 
							// charged solid sphere: nd+n=1
							F = ixcoef * std::pow(Atom::ra, n) * dr / Atom::ra; 

						// dr^-1 because (dx,dy) must be normalized to unit vectors
						Fx += F * dx/dr; //+= dx * f 
						Fy += F * dy/dr;
					}
				}

				// Bouncing back (reflecting) on elastic inner walls 
				if (wallThickness > 0.f) {
					const float wt = wallThickness, we = wallElasticity;
					if (a.x < wt)             Fx += (wt - a.x) * we;
					if (a.y < wt)             Fy += (wt - a.y) * we;
					if (a.x > boxWidth - wt)  Fx += (boxWidth - wt - a.x) * we;
					if (a.y > boxHeight - wt) Fy += (boxHeight - wt - a.y) * we;
				}

			        // dynamic equation with damping coefficient: 
				// m * dv/dt = -c*v  =>  v = exp(-c*t) ~ -c*t => v1-v0 ~ -c*(t1-t0) ~ -c*dt
         			//  a[2] -= c * a[2] * dt; a[3] -= c * a[3] * dt;  // the damping coefficient multiplies velocity
				//**
				if (c * dt >= 1) { a.vx = 0;                    a.vy = 0;                    } 
				else             { a.vx -= c * a.vx * dt / a.m; a.vy -= c * a.vy * dt / a.m; }   
				//**/

			        // dynamic equation with drag coefficient: 
				//  m * dv/dt = -c*v^2  => v = 1/(c*t) => 
				//  v1-v0 ~ 1/c*(1/t1-1/t0) = (t0-t1)/(c*t0*t1) = -dt*c*v1*v0 ~ -dt*c*v1^2
			        // drag coefficient (skin friction and form drag) depends on the Reynolds number for fluids
				/**
				if (std::abs(c * a.vx * dt) >= 1) a.vx = 0; 
				else                              a.vx -= c * a.vx*a.vx * dt * sgn<float>(a.vx) / a.m;   
				if (std::abs(c * a.vy * dt) >= 1) a.vy = 0; 
				else                              a.vy -= c * a.vy*a.vy * dt * sgn<float>(a.vy) / a.m;   
				**/

				// Vertical gravity force
				a.vy += vertGravity * dt / a.m;

				// Pairwise interaction forces
				// dp/dt = F
				//previously: a.vx = (a.vx + Fx) * (1.0 - viscosity); 
				a.vx += Fx * dt / a.m;
				a.vy += Fy * dt / a.m;

				// cumulative square velocity
				if (ac2 == nc - 1) { // because we want to count atom velocities once per atom of any kind
					float sv = a.vx*a.vx + a.vy*a.vy;
					msv += sv;
					msvk[ac1] += sv;
				}

				// Update positions
				// dr/dt = v
				a.x += a.vx * dt; 
				a.y += a.vy * dt;
				 
				// upon reaching walls: hard wall or wraparound
				if (wrapAroundToggle) { // torus topology (closed manifold, without boundaries)
					if (a.x < 0) 
						a.x = boxWidth + fmod(a.x, boxWidth);
					else if (a.x > boxWidth) 
						a.x = fmod(a.x, boxWidth);
					
					if (a.y < 0) 
						a.y = boxHeight + fmod(a.y, boxHeight);
					else if (a.y > boxHeight) 
						a.y = fmod(a.y, boxHeight);
				} else { // hard wall (with boundaries)
					if (a.x < 0) { 
					        a.vx *= -1;
						a.x = fmod(-a.x, boxWidth); //a.x = 0; // fmod is % for floats
					} else if (a.x > boxWidth) { 
					        a.vx *= -1;
						a.x = fmod(2*boxWidth - a.x, boxWidth); //a.x = boxWidth;
					}

					if (a.y < 0) { 
					        a.vy *= -1;
						a.y = fmod(-a.y, boxHeight);
					} else if (a.y > boxHeight) {
					        a.vy *= -1;
						a.y = fmod(2*boxHeight - a.y, boxHeight);
					}
				}
			}
		}
	}
        /* omp end parallel */
}

// Randomize simulation parameters
void ofApp::randomizeParameters(char symmetrize) {
	// Populate Xc
	for (auto &row : Xc) 
		for (auto &e : row) 
			e = randomFloat(ixcULB);

	// Populate Xr
	for (auto &row : Xr) 
		for (auto &e : row) 
			e = randomFloat(rangeLB, rangeUB);

	// symmetrize 
	if (symmetrize == 1) 
		for (unsigned int i = 0; i < nc; i++) 
			for (unsigned int j = 0; j < nc; j++)
				if (j < i) {
					const float symcoef = (Xc[i][j] + Xc[j][i]) / 2;
					Xc[i][j] = Xc[j][i] = symcoef;       	
					const float symrng = (Xr[i][j] + Xr[j][i]) / 2;
					Xr[i][j] = Xr[j][i] = symrng;       	
				}
	// skew-symmetrize 
	if (symmetrize == 2) 
		for (unsigned int i = 0; i < nc; i++) 
			for (unsigned int j = 0; j < nc; j++)
				if (j <= i) {
					const float symcoef = (Xc[i][j] - Xc[j][i]) / 2;
					Xc[i][j] = symcoef;       	
					Xc[j][i] = -symcoef;       	
					const float symrng = (Xr[i][j] + Xr[j][i]) / 2;
					Xr[i][j] = Xr[j][i] = symrng;       	
				}

	// pass new coefficients to Slider objects
	mat2ixc(Xc);
	mat2ixr(Xr);

}
// overload to define default argument
void ofApp::randomizeParameters() {
	ofApp::randomizeParameters(0);
}



// IO

void ofApp::saveParameters() {
	const std::vector<float> pars = {
		ixcSliderRR, ixcSliderRG, ixcSliderRB, ixcSliderRW, 
		ixcSliderGR, ixcSliderGG, ixcSliderGB, ixcSliderGW, 
		ixcSliderBR, ixcSliderBG, ixcSliderBB, ixcSliderBW, 
		ixcSliderWR, ixcSliderWG, ixcSliderWB, ixcSliderWW, 
		ixrSliderRR, ixrSliderRG, ixrSliderRB, ixrSliderRW,
		ixrSliderGR, ixrSliderGG, ixrSliderGB, ixrSliderGW,
		ixrSliderBR, ixrSliderBG, ixrSliderBB, ixrSliderBW,
		ixrSliderWR, ixrSliderWG, ixrSliderWB, ixrSliderWW,
		static_cast<float>(redCountSlider), float(greenCountSlider), float(blueCountSlider), float(whiteCountSlider),
		interactionLawSlider, log10TimeStepSlider, log10DampingCoefSlider, interacProbSlider,
		vertGravitySlider, wallThicknessSlider, wallElasticitySlider, wrapAroundToggle, nc
	};

	// Dialog gui: openframeworks.cc/documentation/utils/ofSystemUtils/

	// Open files for writing
	// This overwrites past saved files for writing now
	parsFile.open("pars_" + ofGetTimestampString() + ".txt", ofFile::WriteOnly);
	statsFile.open("stats_" + ofGetTimestampString() + ".txt", ofFile::WriteOnly);
	wholeEntdenFile.open("wedst_" + ofGetTimestampString() + ".txt", ofFile::WriteOnly);
	liveEntdenFile.open("ledst_" + ofGetTimestampString() + ".txt", ofFile::WriteOnly);
	liveCludenFile.open("lcdst_" + ofGetTimestampString() + ".txt", ofFile::WriteOnly);

	// write to file
	for (unsigned int i = 0; i < pars.size(); i++) 
		parsFile << pars[i] << "\n";

	// mean square velocity
	// specific internal energy U/N = v^2/N
	for (unsigned int i = 0; i < cvNkT.size(); i++) {
		// sundry stats
		statsFile << stepts[i] << "\t" << ets[i] << "\t" << boxVol[i] << "\t" << cvNkT[i] << "\t"; //time, therdynam
	        statsFile << boxAtomDens[i] << "\t" << boxClusDens[i] << "\t" << boxPressure[i] << "\t"; 
	        statsFile << supats[i] << "\t" << supcts[i] << "\t" << subats[i] << "\t";  // surprisal
       		statsFile << lcnts[i] << "\t" << dcnts[i] << "\t" << lents[i] << "\t" << dents[i] << "\t"; // clus and ents count 
		for (unsigned int j = 0; j < nc; j++) { 
			statsFile << cvNkTk[i][j]; (j < nc-1) ? statsFile << "\t" : statsFile << endl; 
		}

		// memberwise cluster and entities sv and su 
		for (unsigned int j = 0; j < livclusizts.size(); j++) 
			liveCludenFile << livclusizts[j][i] << "\t"; // clu sizes
		for (unsigned int j = 0; j < csv.size(); j++) 
			liveCludenFile << csv[j][i] << "\t";
		for (unsigned int j = 0; j < csmv.size(); j++) 
			liveCludenFile << csmv[j][i] << "\t";
		for (unsigned int j = 0; j < csu.size(); j++) {
			liveCludenFile << csu[j][i];
			if (j < csu.size() - 1)  liveCludenFile << "\t";
			if (j == csu.size() - 1) liveCludenFile << endl;
		}

		// whole dendron: lifespans, complexity
		for (std::size_t j = 0; j < entities.D.size(); j++) 
			if (j < entities.D.size()) 
				wholeEntdenFile << wdTts[j][i] << "\t";
		for (std::size_t j = 0; j < entities.D.size(); j++) 
			(j < entities.D.size() - 1) ? wholeEntdenFile << wdCts[j][i] << "\t" : wholeEntdenFile << wdCts[j][i] << endl;

		// live dendron: ages, complexity, liveness
		EntityDendron led = entities.liveEntsDendron();
		for (std::size_t j = 0; j < led.D.size(); j++) 
			if (j < led.D.size()) 
				liveEntdenFile << ldcurTts[j][i] << "\t";
		for (std::size_t j = 0; j < led.D.size(); j++) 
			if (j < led.D.size()) 
				liveEntdenFile << ldcumTts[j][i] << "\t";
		for (std::size_t j = 0; j < led.D.size(); j++) 
			if (j < led.D.size()) 
				liveEntdenFile << ldsts[j][i] << "\t";
		for (std::size_t j = 0; j < led.D.size(); j++) 
			(j < led.D.size() - 1) ? liveEntdenFile << ldCts[j][i] << "\t" : liveEntdenFile << ldCts[j][i] << endl;
	}
	
	//close files
	parsFile.close(); statsFile.close(); wholeEntdenFile.close(); liveEntdenFile.close(); liveCludenFile.close();

	sleep(.5);
}

// Dialog gui only tested on windows machine 
void ofApp::loadParameters() {

	std::string path;
	std::string text;
	ofFileDialogResult result = ofSystemLoadDialog("Load file", false, path);
	if (result.bSuccess) {
		path = result.getPath();
		std::ifstream t(path);
		std::stringstream loaded;
		loaded << t.rdbuf();
		text = loaded.str();
	} else {
		ofSystemAlertDialog("Could not load the file!");
		return;
		//throw 2;
	}

	// split text by space and convert them to floats
	std::string word;
	std::vector<float> p;
	for (auto x : text) {
		if (x == '\t') {
			p.push_back(std::stof(word));
			word = "";
		} else 
			word += x;
	}

	if (p.size() != 45) { 
		ofSystemAlertDialog("Failed to read the file");
		return;
	}  

	ixcSliderRR = p[0];  ixcSliderRG = p[1];  ixcSliderRB = p[2];  ixcSliderRW = p[3];
	ixcSliderGR = p[4];  ixcSliderGG = p[5];  ixcSliderGB = p[6];  ixcSliderGW = p[7];
	ixcSliderBR = p[8];  ixcSliderBG = p[9];  ixcSliderBB = p[10]; ixcSliderBW = p[11];
	ixcSliderWR = p[12]; ixcSliderWG = p[13]; ixcSliderWB = p[14]; ixcSliderWW = p[15];
	ixrSliderRR = p[16]; ixrSliderRG = p[17]; ixrSliderRB = p[18]; ixrSliderRW = p[19];
	ixrSliderGR = p[20]; ixrSliderGG = p[21]; ixrSliderGB = p[22]; ixrSliderGW = p[23];
	ixrSliderBR = p[24]; ixrSliderBG = p[25]; ixrSliderBB = p[26]; ixrSliderBW = p[27];
	ixrSliderWR = p[28]; ixrSliderWG = p[29]; ixrSliderWB = p[30]; ixrSliderWW = p[31];

	redCountSlider = static_cast<int>(p[32]);  greenCountSlider = static_cast<int>(p[33]);
	blueCountSlider = static_cast<int>(p[34]); whiteCountSlider = static_cast<int>(p[35]);
	interactionLawSlider =   p[36];
	log10TimeStepSlider =    p[37];
	log10DampingCoefSlider = p[38];
	interacProbSlider =      p[39];
	vertGravitySlider =      p[40];
	wallThicknessSlider =    p[41];
	wallElasticitySlider =   p[42];
	wrapAroundToggle =       p[43];
	//nc = 			 p[44];

	for (unsigned int i = 0; i < static_cast<int>(nc*nc-1); i++) {
		const auto [q, r] = std::div(i, static_cast<int>(nc)); // q * nc + r == i
		if (i < nc*nc) *Sc[r][q] = p[i];
		else           *Sr[r][q-nc*nc] = p[i+nc*nc];
	}

	atoms.reatomize(Sn);
}



// OFAPP METHODS

// This function gets called once, just at the start of the app. It would be a good place to allocate variables or load in any files.
void ofApp::setup() {

	ofSetWindowTitle("Racemi");
	ofSetVerticalSync(false);

	//ofSetWindowShape(1024, 768);
	//ofSetWindowPosition(10,10);
	ofBackground(0, 0, 0);  // Sets the background color to black
				
	// time keeping
	ofResetElapsedTimeCounter();
	lastDrawTime = std::clock();
	// Returns the approximate processor time used by the process since the beginning of 
	//an implementation-defined era related to the program's execution. 
	//To convert result value to seconds divide it by CLOCKS_PER_SEC.
	float setuptime = lastDrawTime / CLOCKS_PER_SEC;  // clock ticks per second
	ofLogNotice("Setup");
	ofLogNotice() << "Begin setup at timepoint " << setuptime << "s" << endl;
	ofLogNotice() << "Clock ticks per second: " << CLOCKS_PER_SEC << endl;
	ofLogNotice() << "Box size: " << ofGetWidth() << "x" << ofGetHeight() << endl;
	//ofLogToFile("myLogFile.txt", true); // all following logs will be appended to myLogFile.txt

	// atom count pointers
	Sn[0] = &redCountSlider; Sn[1] = &greenCountSlider; Sn[2] = &blueCountSlider; Sn[3] = &whiteCountSlider;

	// Interaction matrix
	for (auto &row : initXc) 
		for (auto &e : row) 
			e = initInteracCoef;
	for (auto &row : initXr) 
		for (auto &e : row) 
			e = initInteracRange;
	// interaction coefficient slider matrix pointers to coefficient slider objects
	Sc[0][0] = &ixcSliderRR; Sc[0][1] = &ixcSliderRG; Sc[0][2] = &ixcSliderRB; Sc[0][3] = &ixcSliderRW;	
	Sc[1][0] = &ixcSliderGR; Sc[1][1] = &ixcSliderGG; Sc[1][2] = &ixcSliderGB; Sc[1][3] = &ixcSliderGW;	
	Sc[2][0] = &ixcSliderBR; Sc[2][1] = &ixcSliderBG; Sc[2][2] = &ixcSliderBB; Sc[2][3] = &ixcSliderBW;	
	Sc[3][0] = &ixcSliderWR; Sc[3][1] = &ixcSliderWG; Sc[3][2] = &ixcSliderWB; Sc[3][3] = &ixcSliderWW;	
	// interaction range slider matrix pointers to range slider objects
	Sr[0][0] = &ixrSliderRR; Sr[0][1] = &ixrSliderRG; Sr[0][2] = &ixrSliderRB; Sr[0][3] = &ixrSliderRW;	
	Sr[1][0] = &ixrSliderGR; Sr[1][1] = &ixrSliderGG; Sr[1][2] = &ixrSliderGB; Sr[1][3] = &ixrSliderGW;	
	Sr[2][0] = &ixrSliderBR; Sr[2][1] = &ixrSliderBG; Sr[2][2] = &ixrSliderBB; Sr[2][3] = &ixrSliderBW;	
	Sr[3][0] = &ixrSliderWR; Sr[3][1] = &ixrSliderWG; Sr[3][2] = &ixrSliderWB; Sr[3][3] = &ixrSliderWW;	


	// GUI
	gui.setup("Racemi GUI");
	gui.loadFont("Helvetica", 12);
	gui.setWidthElements(300.0f);

	gui.add(fpsLabel.setup("FPS (Hz)", "0"));
	gui.add(forwardStepLabel.setup("Step interval (ms)", "0"));
	gui.add(doStir.setup("Stir (r)"));
	gui.add(doRandomizeReatomize.setup("Reset (space bar)"));
	gui.add(symmetrizeInteractionsToggle.setup("Symmetric interactions", false));
	gui.add(skewsymmetrizeInteractionsToggle.setup("Skew-symmetric interactions", false));
	gui.add(doSave.setup("Save model (s)"));
	gui.add(doLoad.setup("Load model"));
	
	const char* acl[4] = {"red", "green", "blue", "white"};
	std::string ixctxt = " <- ";
	std::string ixrtxt = " <-- ";

	// Model diagram matrix
	mdc[0][0] += md_xshift; 		mdc[0][1] += md_yshift;
	mdc[1][0] += md_xshift + md_sidelen;	mdc[1][1] += md_yshift; 
	mdc[2][0] += md_xshift; 		mdc[2][1] += md_yshift + md_sidelen;
	mdc[3][0] += md_xshift + md_sidelen; 	mdc[3][1] += md_yshift + md_sidelen;

	// Physics
	physicsGuig.setup("Physics");
	physicsGuig.add(interactionLawSlider.setup("Interaction power law exponent", interactionLaw, -4, 2));
	physicsGuig.add(regularPotentialToggle.setup("Regular potential", true));
	physicsGuig.add(log10TimeStepSlider.setup("Log 10 time step", 0, -2, 1)); // log10TimeStep
	physicsGuig.add(viscosityToggle.setup("Viscosity", true));
	physicsGuig.add(log10DampingCoefSlider.setup("Log 10 damping ", log10DampingCoef, -9, 9));
	physicsGuig.add(interacProbSlider.setup("Interaction log10 %probability", 2, -2, 2)); // interacLog10Prob100
	physicsGuig.add(infiniteRangeToggle.setup("Infinite range", true));
	physicsGuig.add(vertGravitySlider.setup("Gravity", vertGravity, -.2, .2));
	physicsGuig.add(wallThicknessSlider.setup("Wall thickness", wallThickness, 0, 300));
	physicsGuig.add(wallElasticitySlider.setup("Wall elasticity", wallElasticity, 0, 10));
	physicsGuig.add(wrapAroundToggle.setup("Wrap around; else hard wall", wrapAround));
	physicsGuig.add(computeClustersToggle.setup("Track clusters (c)", false));
	gui.add(&physicsGuig);

	// Atom count
	countGuig.setup("Atom count"); // updated via reatomize or randomize
	for (unsigned int i = 0; i < nc; i++)
		countGuig.add(Sn[i]->setup(acl[i], initCount, 0, 5000));
	//countGuig.minimize();
	gui.add(&countGuig);

	// Atom set 1: red
	redGuig.setup(acl[0]);
	for (unsigned int i = 0; i < nc; i++)
		redGuig.add(Sc[0][i]->setup(acl[0] + ixctxt + acl[i], initXc[0][i], -ixcULB, ixcULB));
	for (unsigned int i = 0; i < nc; i++)
		redGuig.add(Sr[0][i]->setup(acl[0] + ixrtxt + acl[i], initXr[0][i], rangeLB, rangeUB));
	redGuig.minimize();
	gui.add(&redGuig);

	// Atom set 2: green
	greenGuig.setup(acl[1]);
	for (unsigned int i = 0; i < nc; i++)
		greenGuig.add(Sc[1][i]->setup(acl[1] + ixctxt + acl[i], initXc[1][i], -ixcULB, ixcULB));
	for (unsigned int i = 0; i < nc; i++)
		greenGuig.add(Sr[1][i]->setup(acl[1] + ixrtxt + acl[i], initXr[1][i], rangeLB, rangeUB));
	greenGuig.minimize();
	gui.add(&greenGuig);

	// Atom set 3: blue
	blueGuig.setup(acl[2]);
	for (unsigned int i = 0; i < nc; i++)
		blueGuig.add(Sc[2][i]->setup(acl[2] + ixctxt + acl[i], initXc[2][i], -ixcULB, ixcULB));
	for (unsigned int i = 0; i < nc; i++)
		blueGuig.add(Sr[2][i]->setup(acl[2] + ixrtxt + acl[i], initXr[2][i], rangeLB, rangeUB));
	blueGuig.minimize();
	gui.add(&blueGuig);

	// Atom set 4: white
	whiteGuig.setup(acl[3]);
	for (unsigned int i = 0; i < nc; i++)
		whiteGuig.add(Sc[3][i]->setup(acl[3] + ixctxt + acl[i], initXc[3][i], -ixcULB, ixcULB));
	for (unsigned int i = 0; i < nc; i++)
		whiteGuig.add(Sr[3][i]->setup(acl[3] + ixrtxt + acl[i], initXr[3][i], rangeLB, rangeUB));
	whiteGuig.minimize();
	gui.add(&whiteGuig);


	// Parameter space roving 
	roveGuig.setup("Roving in ix parameter space");
	roveGuig.add(roveToggle.setup("Roving", false));
	roveGuig.add(roveProbSlider.setup("Probability (%) per step", 1, 0, 100)); // initial rove chance 1% per step
	roveGuig.add(roveRatioSlider.setup("Ratio (%)", 5, 0, 100)); // initial rove ratio 5%
	gui.add(&roveGuig);


	// View
	viewGuig.setup("View");
	viewGuig.add(motionBlurToggle.setup("Motion blur (b)", false));
	viewGuig.add(canvasRedrawAlphaSlider.setup("Redrawing opaqueness", 32, 0, 255)); // starting alpha=64
	viewGuig.add(atomsAlphaSlider.setup("Atoms opaqueness", 192, 0, 255)); // starting alpha=111
	viewGuig.add(viewSpokesToggle.setup("Cluster spokes", false));
	viewGuig.add(modelDiagramToggle.setup("Show diagram (d)", false));
	gui.add(&viewGuig);


	// Atomize
	atoms.reatomize(Sn);

	// Stir atoms
	//AtomMash atoms2(atoms); // copy constructor: this copies atoms into atoms2
	//atoms2 = AtomMash(initCount); // copy assignment: this creates a new instance of atom mash 
	atoms.stirAll();  //segfault: atoms = AtomMash(initCount)


	// Clusters
	// Initialize cluster dendron first (atom) level
	clusters.fillAtomicLevel();
	// Create primordial cluster in level 1 (just above atomic level)
	clusters.conceivePrimal();
	// Initialize entities dendron zeroth level
	entities.findAddAtomicEntities(clusters);


	ofLogNotice() << atoms << endl;
	ofLogNotice() << clusters << endl; 
	ofLogNotice() << "set up finished\n";
}


// This function gets called repeatedly. It gets called just before draw, so it is an ideal place to do any updating of variables
void ofApp::update() {
	step_start = clock();

	// initialize
	interactionLaw = interactionLawSlider;
	log10TimeStep = log10TimeStepSlider;
	log10DampingCoef = log10DampingCoefSlider;
	interacLog10Prob100 = interacProbSlider;
	vertGravity = vertGravitySlider;
	wallThickness = wallThicknessSlider;
	wallElasticity = wallElasticitySlider;

	if (doStir) {
		atoms.stirAll();
		ofLogNotice("Stir");
	}
	if (doRandomizeReatomize) {
		if (symmetrizeInteractionsToggle)          randomizeParameters(1); 
		else if (skewsymmetrizeInteractionsToggle) randomizeParameters(2); 
		else	                                   randomizeParameters(0);
		// remake atoms
		atoms.reatomize(Sn);
		if (computeClustersToggle) { // remake clusters
	        	clusters = ClusterDendron(&atoms);
			clusters.fillAtomicLevel();
			clusters.conceivePrimal();
			entities = EntityDendron();
			entities.findAddAtomicEntities(clusters);
		}
        	ofLogNotice("Reset");
		ofLogNotice() << atoms << endl << clusters << endl; 
	}

	// rove parameter space
	if(roveToggle && ofRandom(1.0F) < (roveProbSlider / 100.0F)) {

		for (unsigned int i = 0; i < nc; i++) for (unsigned int j = 0; j < nc; j++) { 
			*Sc[i][j] = *Sc[i][j] + ofRandomf() * (Sc[i][j]->getMax() - Sc[i][j]->getMin()) * roveRatioSlider / 100;
			*Sr[i][j] = *Sr[i][j] + ofRandomf() * (Sr[i][j]->getMax() - Sr[i][j]->getMin()) * roveRatioSlider / 100;
		//	*Sc[i][j] = Xc[i][j];  // ofRandomf() = randomFloat(1.0f)
		//	*Sr[i][j] = Xr[i][j];
			if (*Sr[i][j] < rangeLB)      *Sr[i][j] = rangeLB;
			else if (*Sr[i][j] > rangeUB) *Sr[i][j] = rangeUB; 
		}
		//mat2ixc(Xc); mat2ixr(Xr);
	}


	// Step forward
	// Interact
	msv = 0;  //atoms mean squared velocity, in timeStep time units
	std::fill(msvk.begin(), msvk.end(), 0);  
	for (unsigned int i = 0; i < nc; i++)
		for (unsigned int j = 0; j < nc; j++)
			interact(i, j, *Sc[i][j], *Sr[i][j]); // i <- j
	volume = (ofGetWidth()-wallThickness)*(ofGetHeight()-wallThickness);
	atomdens = atoms.countAll() / volume;
	clusdens = clusters.countAllLive() / volume;
	pressure = msv * atoms.countAll(); // see Feynman(1963), page 39-6
	dt = std::pow(10, log10TimeStep); 

	// Calculate aggregate statistics
	stepts.emplace_back(step);
	ets.emplace_back(ofGetElapsedTimef()); 
        msv /= 2*atoms.countAll();  // Temperature if m = 1, as average kinetic energy
	cvNkT.emplace_back(msv); // temperature 
	for (unsigned int j = 0; j < nc; j++)
		msvk[j] *= .5 * AtomMash::masses[j] / atoms.colors[j]->size();  
		// msv += msvk[j];
	cvNkTk.emplace_back(msvk); // temperature by atom kind
	boxVol.emplace_back(volume);
	boxAtomDens.emplace_back(atomdens);
	boxClusDens.emplace_back(clusdens);
	boxPressure.emplace_back(pressure);
	supats.emplace_back(clusters.totSurpPerAtom()); supcts.emplace_back(clusters.totSurpPerLivclu());
	subats.emplace_back(vectorSum(clusters.omniClus().memsu) / float(atoms.countAll())); 

	// live and dead clusters and entities
	lcnts.emplace_back(clusters.count()[0]); dcnts.emplace_back(clusters.count()[1]);
	lents.emplace_back(entities.count()[0]); dents.emplace_back(entities.count()[1]);
	// whole entity dendron: lifespans and complexity
	wdTts[0].emplace_back(entities.lifespans()); // all levels aggregate for all ents
	std::vector<std::vector<float>> wdC{entities.wholeDendronComplexity()};
	wdCts[0].emplace_back(wdC[0]);
	// live entities: ages
	EntityDendron led = entities.liveEntsDendron();
	ldcurTts[0].emplace_back(entities.ages(0)); // all levels aggregate for living ents
	ldcumTts[0].emplace_back(entities.ages(1)); 
	// live entitie: subclus/ents sizes 
	std::vector<std::vector<unsigned int>> lds{entities.liveDendronSubcluSiz()};
	ldsts[0].emplace_back(lds[0]);
	// live clus/ents dendron complexity
	std::vector<std::vector<float>> ldC{entities.liveDendronComplexity()};
	ldCts[0].emplace_back(ldC[0]);
	for (unsigned int l = 1; l < std::max(entities.D.size(), wdTts.size()); l++) { 
		if (wdTts.size() == l)
			wdTts.push_back(std::vector<std::vector<float>>(wdTts[l-1].size()-1));
		if (l < entities.D.size())
			wdTts[l].emplace_back(entities.cumLifespanByLev()[l]);
		else
			wdTts[l].emplace_back(std::vector<float>());
		if (wdCts.size() == l)
			wdCts.push_back(std::vector<std::vector<float>>(wdCts[l-1].size()-1));
		if (l < entities.D.size())
			wdCts[l].emplace_back(wdC[l]);
		else
			wdCts[l].emplace_back(std::vector<float>());

		// ent current lifespan
		if (ldcurTts.size() == l)
			ldcurTts.push_back(std::vector<std::vector<float>>(ldcurTts[l-1].size()-1));
		if (l < led.D.size())
			ldcurTts[l].emplace_back(entities.ageByLev(0)[l]); // ~7ms later than aggregate ages at l=0
		else
			ldcurTts[l].emplace_back(std::vector<float>());
		// ent cumulative lifespan
		if (ldcumTts.size() == l)
			ldcumTts.push_back(std::vector<std::vector<float>>(ldcumTts[l-1].size()-1));
		if (l < led.D.size())
			ldcumTts[l].emplace_back(entities.ageByLev(1)[l]); 
		else
			ldcumTts[l].emplace_back(std::vector<float>());
		// subclusizes
		if (ldsts.size() == l)
			ldsts.push_back(std::vector<std::vector<unsigned int>>(ldsts[l-1].size()-1));
		if (l < led.D.size())
			ldsts[l].emplace_back(lds[l]);
		else
			ldsts[l].emplace_back(std::vector<unsigned int>());
		if (ldCts.size() == l)
			ldCts.push_back(std::vector<std::vector<float>>(ldCts[l-1].size()-1));
		if (l < led.D.size())
			ldCts[l].emplace_back(ldC[l]);
		else
			ldCts[l].emplace_back(std::vector<float>());
	}
	// cluster-wise variables
	for (std::size_t l = 0; l < clusters.D.size(); l++) { 
		if (csv.size() == l && l >= 1)
			csv.push_back(std::vector<std::vector<float>>(csv[l-1].size()-1));
		if (csmv.size() == l && l >= 1)
			csmv.push_back(std::vector<std::vector<float>>(csmv[l-1].size()-1));
		if (csu.size() == l && l >= 1)
			csu.push_back(std::vector<std::vector<float>>(csu[l-1].size()-1));
		std::vector<float> csvl{std::vector<float>()}, csul{std::vector<float>()}, csmvl{std::vector<float>()};
		if (computeClustersToggle) 
			for (unsigned int ci = 0; ci < clusters.D[l].size(); ci++) {
				const auto& c = clusters.D[l][ci];
				if (c.alive) {
					csvl.push_back((c.cvx*c.cvx + c.cvy*c.cvy)/(dt*dt)); //squared velocities
					csmvl.push_back((c.mvx*c.mvx + c.mvy*c.mvy)/(dt*dt)); //member squared velocities
					// note that surprisals at l are of subordinate members (l-1)
					for (const auto msu : c.memsu)
						csul.push_back(msu); //surprisals
				} 
			}
		csv[l].emplace_back(csvl);
		csmv[l].emplace_back(csmvl);
		csu[l].emplace_back(csul);

		//cluster sizes
		if (livclusizts.size() == l && l >= 1)
			livclusizts.push_back(std::vector<std::vector<unsigned int>>(livclusizts[l-1].size()-1));
		livclusizts[l].emplace_back(clusters.livCluSiz()[l]);
	}
	// fill rows even when no clusters are computed for dataframe compatibility
	if (clusters.D.size() == 0) { 
		csv[0].emplace_back(std::vector<float>());
		csmv[0].emplace_back(std::vector<float>());
		csu[0].emplace_back(std::vector<float>());
		livclusizts[0].emplace_back(std::vector<unsigned int>());
	}
	

	// Recompute clusters
	if (computeClustersToggle) {
		// scan from lesl (lowest with cluster changes) level upward	
		clusters.updateAtomicLevel();
		const auto [doEntscan, lesl] = clusters.trackClusters();

		// compute entities
		entities.scanUpdateEnts(clusters, lesl);
	}

	// save and load
	if (doSave) saveParameters();
	if (doLoad) loadParameters();

	step_delta = clock() - step_start;

	ofLogNotice() << "frame " << ++step << " updated\n";
}


// This function gets called regularly just after update. It's where you draw things
void ofApp::draw() {
	// Background color
        // line 504

	// https://openframeworks.cc/documentation/graphics/ofGraphics
	if (motionBlurToggle) {
		ofEnableAlphaBlending(); // turn on alpha blending
		ofSetBackgroundAuto(false); // disable automatic background redraw
	        // if non-auto, background clearing will not occur per frame (at the start of draw) but only when ofBackground is called
				 
		// erases previous frame via canvas redraw
		//sets the draw color with r,g,b,a in 0-255 or as one hex; a is the degree of opaqueness 
		ofSetColor(0, 0, 0, canvasRedrawAlphaSlider);
		ofDrawRectangle(0, 0, boxWidth, boxHeight);
	} else { 
		if (atomsAlphaSlider < 255) ofEnableAlphaBlending(); 
		else                        ofDisableAlphaBlending();  // turn off alpha blending
		ofSetBackgroundAuto(true); 
		ofClear(0,0,0); // clears the color and depth bits of current renderer and replaces it 
	}

	// FPS calculation
	frameCount++;
	nowDrawTime = clock();
	deltaDrawTime = nowDrawTime - lastDrawTime;

	// Update FPS and step period every 0.4s
	if (deltaDrawTime/CLOCKS_PER_SEC > 0.4) {
		lastDrawTime = nowDrawTime;
		fpsLabel.setup("FPS (Hz)", std::to_string(frameCount / static_cast<float>(deltaDrawTime) * CLOCKS_PER_SEC));
		//fpsLabel.setup("FPS (Hz)", std::to_string(ofGetFrameRate()));
		forwardStepLabel.setup("Step interval (ms)", std::to_string(step_delta * 1000.f/CLOCKS_PER_SEC));
		frameCount = 0;
	}

	// set alpha
	if (atomsAlphaSlider < 255) 
		atoms.setAlpha(atomsAlphaSlider);

	// Redraw atoms
	atoms.drawAll();	

	// Redraw clusters
	if (computeClustersToggle) 
		clusters.drawAll(viewSpokesToggle);
	

	// draw GUI
	gui.draw();

	// draw model diagram: maximum 4 colors
	if (modelDiagramToggle) {
		// draw graph 
		/**
		ofSetLineWidth(5);
		ofSetColor(127*(1 - *Sc[0][1]), 255 * *Sc[0][1], 0); ofDrawLine(mdc[1][0], mdc[1][1] + 10, mdc[0][0], mdc[0][1] + 10);
		ofSetColor(127*(1 - *Sc[0][2]), 0, 255 * *Sc[0][2]); ofDrawLine(mdc[0][0], mdc[0][1] - 10, mdc[2][0], mdc[2][1] - 10);
		ofSetColor(127*(1 - *Sc[0][3]), 255 * *Sc[0][3], 255 * *Sc[0][3]); 
		ofDrawLine(mdc[0][0] - 10, mdc[0][1], mdc[3][0] - 10, mdc[3][1]);
		ofSetColor(255 * *Sc[1][0], 127*(1 - *Sc[1][0]), 0); ofDrawLine(mdc[1][0], mdc[1][1] - 10, mdc[0][0], mdc[0][1] - 10);
		ofSetColor(0, 127*(1 - *Sc[1][2]), 255 * *Sc[1][2]); ofDrawLine(mdc[2][0] - 10, mdc[2][1], mdc[1][0] - 10, mdc[1][1]);
		ofSetColor(255 * *Sc[1][3], 127*(1 - *Sc[1][3]), 255 * *Sc[1][3]); 
		ofDrawLine(mdc[3][0], mdc[3][1] - 10, mdc[1][0], mdc[1][1] - 10);
		ofSetColor(255 * *Sc[2][0], 0, 127*(1 - *Sc[2][0])); ofDrawLine(mdc[0][0], mdc[0][1] + 10, mdc[2][0], mdc[2][1] + 10);
		ofSetColor(0, 255 * *Sc[2][1], 127*(1 - *Sc[2][1])); ofDrawLine(mdc[2][0] + 10, mdc[2][1], mdc[1][0] + 10, mdc[1][1]);
		ofSetColor(255 * *Sc[2][3], 255 * *Sc[2][3], 127*(1 - *Sc[2][3])); 
		ofDrawLine(mdc[3][0], mdc[3][1] + 10, mdc[2][0], mdc[2][1] + 10);
		ofSetColor(255 * *Sc[3][0], 127*(1 - *Sc[3][0]), 127*(1 - *Sc[3][0])); 
		ofDrawLine(mdc[0][0] + 10, mdc[0][1], mdc[3][0] + 10, mdc[3][1]);
		ofSetColor(127*(1 - *Sc[3][1]), 255 * *Sc[3][1], 127*(1 - *Sc[3][1])); 
		ofDrawLine(mdc[3][0], mdc[3][1] + 10, mdc[1][0], mdc[1][1] + 10);
		ofSetColor(127*(1 - *Sc[3][2]), 127*(1 - *Sc[3][2]), 255 * *Sc[3][2]); 
		ofDrawLine(mdc[3][0], mdc[3][1] - 10, mdc[2][0], mdc[2][1] - 10);
		ofNoFill();
		ofSetColor(127*(1 - *Sc[0][0]), 0, 0); ofDrawCircle(mdc[0][0] - 20, mdc[0][1] - 20, md_circrad + 20);
		ofSetColor(0, 127*(1 - *Sc[1][1]), 0); ofDrawCircle(mdc[1][0] + 20, mdc[1][1] - 20, md_circrad + 20);
		ofSetColor(0, 0, 127*(1 - *Sc[2][2])); ofDrawCircle(mdc[2][0] - 20, mdc[2][1] + 20, md_circrad + 20);
		ofSetColor(127*(1 - *Sc[3][3]), 127*(1 - *Sc[3][3]), 127*(1 - *Sc[3][3])); 
		ofDrawCircle(mdc[3][0] + 20, mdc[3][1] + 20, md_circrad + 20);

		ofFill();
		for (std::size_t i = 0; i < nc; i++) {
			ofSetColor(colCh[i][0], colCh[i][1], colCh[i][2]); 
			ofDrawCircle(mdc[i][0], mdc[i][1], md_circrad);
		}
		**/

		// draw matrix
		for (std::size_t i = 0; i < nc; i++) 
			for (std::size_t j = 0; j < NC; j++) {
				ofSetColor(255, 255, 255, 127*(1 - *Sc[i][j]));
				ofDrawRectangle(anchor + 0.9*md_xshift + j * mm_rectseg, 
						anchor + 3*md_yshift + i * mm_rectseg, mm_rectseg-2, mm_rectseg-2);
			}
	}
	gui.draw();

	ofLogNotice() << "frame " << step << " drawn\n";
}


// This function gets called when a key is pressed. The value key can be tested against
void ofApp::keyPressed(int key) {
	// openframeworks.cc/documentation/application/ofBaseApp/#show_keyPressed
	if (key == ' '){
		if (symmetrizeInteractionsToggle)          randomizeParameters(1);
		else if (skewsymmetrizeInteractionsToggle) randomizeParameters(2); 
		else	                                   randomizeParameters();
		atoms.reatomize(Sn); // remake atoms
		if (computeClustersToggle) {
	        	clusters = ClusterDendron(&atoms); // remake clusters
			clusters.fillAtomicLevel();
			clusters.conceivePrimal();
			entities = EntityDendron();
			entities.findAddAtomicEntities(clusters);
		}
        	ofLogNotice("Reset"); ofLogNotice() << atoms << endl << clusters << endl; 
	}
	if (key == 'r')  {
		atoms.stirAll();
        	ofLogNotice("Stir");
	}
	if (key == 's') saveParameters();
	if (key == 'b') motionBlurToggle = !motionBlurToggle;
	if (key == 'c') computeClustersToggle = !computeClustersToggle; 
	if (key == 'd') modelDiagramToggle = !modelDiagramToggle; 
	//if (key == 27) ofApp::exit();
	if (key == 'p') cin.get(); // pause until user input
}


// Upon closing or esc the app
void ofApp::exit() {
	// openframeworks.cc/documentation/application/ofBaseApp/#show_exit
	ofLogNotice("Exiting");
	
	std::cout << clusters << endl;

	std::cout << "System time: " << ofGetSystemTimeMillis() << "ms" << endl;
	std::cout << "CPU elapsed time: " << clock() / CLOCKS_PER_SEC << "s" << endl;
	std::cout << "Elapsed time: " << ofGetElapsedTimef() << "s" << endl;
	std::cout << "Number of frames rendered: " << ofGetFrameNum() << endl;
}
