#pragma once

#include "ofMain.h"
#include "ofxGui.h"

#include <iostream>
#include <vector>
#include <random>
#include "Eigen/Core" // eigen.tuxfamily.org/dox/group__QuickRefPage.html
#include "Eigen/LU"
#include "Eigen/SVD"
#include <tuple>
#include <algorithm>
#include <unistd.h>


// Maximum NC is 4
#define NC 4
#define ND 2
#define GRID_DIV 4


// RANDOM NUMBER GENERATOR
inline float randomFloat(float a, float b);
inline float randomFloat(const float a);
//stackoverflow.com/questions/1330114/whats-the-difference-between-using-extern-and-including-header-files
//extern is optional for functions (functions are automatically extern), but not for variables
// when you share a variable between a few modules you define it in one module and use extern in the others or only in the header
extern std::random_device rd;  // to obtain a seed for the random number engine
extern std::mt19937 mterui; // standard mersenne_twister_engine seeded with rd()
extern std::uniform_int_distribution<unsigned int> uid; // use uri to map the random unsigned int generated by mterui into [0, 99] 
extern std::uniform_real_distribution<> urd0; // use urd to transform the random unsigned int generated by mterui 
extern std::uniform_real_distribution<> urd2;

// globals
extern int globvar;


// ARRAYS
//vector implements a stack: https://stackoverflow.com/questions/2209224/vector-vs-list-in-stl
template <typename T> int sgn(T val);
template <typename T> T vectorSum(std::vector<T> v);
template <typename T> T vectorProd(std::vector<T> v);
template <typename T> bool equalArrays(std::vector<T> arr1, std::vector<T> arr2);
std::array<std::vector<float>,2> zipTwoArrays(std::vector<float> arr1, std::vector<float> arr2);
std::array<std::vector<float>,2> zipTwoArrays(std::array<float,2> arr1, std::array<float,2> arr2);
Eigen::ArrayX2f zipTwoArrays(Eigen::ArrayXf arr1, Eigen::ArrayXf arr2);
template <typename T> std::vector<T> zipSumTwoArrays(std::vector<T> arr1, std::vector<T> arr2);
template <typename T> T vectorMax(std::vector<T> v);
template <typename T> int vectorArgmax(std::vector<T> v);
float vectorSumsq(std::vector<float> v, float center);
float vectorSumsq(std::vector<float> v);
float vectorStdev(std::vector<float> v, float center);
float vectorStdev(std::vector<float> v);
template <typename T> bool vectorIncludes(const std::vector<T>& v, T x);
template<typename T> std::ostream& operator<<(std::ostream& os, std::vector<T> const& v);

// SETS
template <typename T> bool equalSets(std::vector<T> arr1, std::vector<T> arr2);
template <typename T> std::vector<T> subtractSets(std::vector<T> arr1, std::vector<T> arr2);
template <typename T> std::vector<T> intersectSets(std::vector<T> arr1, std::vector<T> arr2);
template <typename T> bool equalMultisets(std::vector<T> arr1, std::vector<T> arr2);

// LINEAR ALGEBRA
template <typename T> using matrix = std::vector<std::vector<T>>;
template <typename T> matrix<T> matmult(matrix<T> A, matrix<T> B); 
float mip(Eigen::Vector2f x, Eigen::Matrix2f C, Eigen::Vector2f y);
float mip(Eigen::Vector2f x, Eigen::Matrix2f C); // overload
float nlg(Eigen::Vector2f x, Eigen::Matrix2f C);
typedef Eigen::JacobiSVD<Eigen::Matrix<float,Eigen::Dynamic,2>, Eigen::ComputeThinU | Eigen::ComputeThinV> JsvdX2fThin;
typedef Eigen::JacobiSVD<Eigen::Matrix<float,Eigen::Dynamic,2>> JsvdX2f;
typedef Eigen::JacobiSVD<Eigen::MatrixXf> JsvdXf;
JsvdXf svdFromCoords(std::array<std::vector<float>,2> X, std::array<float,2> bc);
Eigen::Vector2f regularizeCovmat(std::array<std::vector<float>,2> X, Eigen::Vector2f sv);

// GRID
struct grid {
	const int gridSize = GRID_DIV * GRID_DIV; // must be a power of 2
};

//CLASSES
class EntityDendron;



// ATOMS
struct Atom {
	// position
	float x, y;
	// velocity
	float vx = 0, vy = 0;
	// color 
	const int r, g, b;
	// mass
	float m = 1;
	// alpha
	int a = 111; // atomsAlpha: opaqueness 0-255
	// atom radius
        static constexpr float ra = 3.0F;
	// grid
	static constexpr int gridId = -1;

	// constructor with member initializer list
	Atom(float _x, float _y, const int _r, const int _g, const int _b, float _m) : x(_x), y(_y), r(_r), g(_g), b(_b), m(_m) {}
	
	// copy assignment
	Atom& operator=(const Atom& a) {
		x = a.x; y = a.y;
		vx = a.vx; vy = a.vy;
		return *this;	
	}

	// methods
	void draw() const {
		ofSetColor(r, g, b, a); //set particle color plus alpha
		ofFill();
		ofDrawCircle(x, y, ra); // draw a point at (x, y), radius 2(float) pixels
	}
};

// atom jumble
//stackoverflow.com/questions/20013901/im-getting-an-error-invalid-use-of-incomplete-type-class-map
struct AtomMash {
        std::vector<Atom> red, green, blue, white, yellow;
	std::vector<Atom> *colors[4] = {&red, &green, &blue, &white}; 

	// color channels
	static constexpr unsigned char colCh[4][3] = {{250, 10, 100}, {100, 250, 10}, {10, 100, 250}, {250, 250, 250}};

	// mass vector
	static constexpr float masses[4] = {1, 1, 1, 1};

	// generate atoms randomly allocated on canvas
	void create1ColorAtoms(unsigned int na, const int c) {
		//not needed because there was no new: red,green,etc already exist and are pointed to
		//delete colors[c]; 
		//colors[c] = new std::vector<Atom>;
		
		colors[c]->reserve(na); // reserve alone doesnt resize during reatomization
		for (unsigned int i = 0; i < na; i++) {
			int x = static_cast<int>(ofRandomWidth());
			int y = static_cast<int>(ofRandomHeight());
			if (colors[c]->size() < na) 
				colors[c]->emplace_back(Atom(x, y, colCh[c][0], colCh[c][1], colCh[c][2], masses[c]));   //append
			else if (colors[c]->size() == na)
				colors[c]->at(i) = Atom(x, y, colCh[c][0], colCh[c][1], colCh[c][2], masses[c]);
		}

 		// when the number of atoms is reduced
		//if (colors[c]->size() > na) colors[c]->resize(na); // but you cant resize down objects
		//stackoverflow.com/questions/1155693/stdvector-resize-downward

	}
	void reatomize(unsigned int nas[NC]) {
		for (unsigned int i = 0; i < NC; i++) 
			create1ColorAtoms(nas[i], i);
	}
	void reatomize(ofxIntSlider* Sn[NC]) {
		unsigned int nas[NC];
		for (unsigned int i = 0; i < NC; i++) 
			nas[i] = *Sn[i];
	       	reatomize(nas);
	}

	// RULE OF FIVE
	// constructor
	AtomMash(unsigned int nas[NC]) {
		reatomize(nas);
	};
	AtomMash(ofxIntSlider* Sn[NC]) {
	       	reatomize(Sn);
	};
	AtomMash(unsigned int na) {
		//stackoverflow.com/questions/39199023/how-to-call-a-c-class-constructor-from-another-constructor
		unsigned int nas[NC];
	       	for (unsigned int i = 0; i < NC; i++) 
			nas[i] = na;
		reatomize(nas); // doesn't work: *this = AtomMash(nas); 
	};

	// copy constructor
	AtomMash(const AtomMash& am) {
		for (unsigned int c = 0; c < NC; c++) {
			*colors[c] = *am.colors[c]; 
		}
	}
	// move constructor
	AtomMash(AtomMash&& am) {
		if (this !=  &am) {
			for (std::size_t c = 0; c < NC; c++) {
				*colors[c] = *am.colors[c]; 
				am.colors[c] = nullptr;
			}
		}
	}

	// copy assignment
	AtomMash& operator=(const AtomMash& am) {
		for (unsigned int c = 0; c < NC; c++) {
			*colors[c] = *am.colors[c]; 
		}
		return *this;
	}
	// move assignment
	//stackoverflow.com/questions/5481539/what-does-t-double-ampersand-mean-in-c11
	AtomMash& operator=(AtomMash&& am) {
		if (this !=  &am) {
			//stackoverflow.com/questions/33366877/c-garbage-values-in-vector-of-pointer
			for (unsigned int c = 0; c < NC; c++) {
				*colors[c] = *am.colors[c]; // garbage in first element if copying pointers instead of values 
				am.colors[c] = nullptr;
			}
		}
		return *this;
	}

	// destructor
	//if the class is designed such that RAII is used for all its (nontrivial) members the destructor may be left undefined


	// rellocate extant atoms to random canvas positions 
	void whip1Color(const unsigned int c) {
		const unsigned int na = colors[c]->size();
		for (unsigned int i = 0; i < na; i++) {
			(*colors[c])[i].x = ofRandomWidth(); 
			(*colors[c])[i].y = ofRandomHeight(); 
		}
	} 
	void stirAll() {
		for (unsigned int c = 0; c < NC; c++)
			whip1Color(c);
	}

	// drawing
	void drawAll() const {
		for (auto color : colors)
			for (auto& atom : *color) 
				atom.draw();
	}
	void setAlpha(const int a) {
		// don't make vector const to modify atom's members
		for (auto color : colors)
			for (auto& atom : *color) 
				atom.a = a;
	}

	// count all atoms
	int countAll() const {
		int count = 0;
	       	for (auto colorp : colors)
			count += colorp->size();	
		return count;
	}

	// output
	friend std::ostream& operator<<(std::ostream& os, const AtomMash& am) {
		os << "atom jumble attributes\n";
		os << "number of colors:\t" << sizeof(am.colors)/sizeof(std::vector<Atom>*) << "\n";
		for (unsigned int ci = 0; ci < NC; ci++) {
			unsigned int ai = static_cast<unsigned int>(ofRandom((*am.colors)[ci].size())); // std::rand() is [0, RAND_MAX) 
			const std::vector<Atom>& ac = (*am.colors)[ci];
			os << "atom color " << ci << "\n"
			   << "size:\t" << ac.size() << "\n"
			   << "capacity:\t" << ac.capacity() << "\n"
			   << "max_size:\t" << ac.max_size() << "\n"
			   << "atom " << ai << " red channel:\t" << ac[ai].r << "\n"
			   << "atom " << ai << " x coordinates:\t" << ac[ai].x << "\n";
			//for (auto a : (*am.colors)[ci]) os << a.x << " ";  
			os << "\n";
		}
		return os;
    	}
};



// CLUSTERS

class Cluster {
	// from C++11 in-class member initializers are allowed
	
	// drawing
	static constexpr float strokeWidth = Atom::ra/2;
	static constexpr float csmr = 0.05;  // cluster shape mean-reversion parameter or learning rate
public:
	// member list
	std::vector<unsigned int> memls; 
	
	// centroid position: random location, generic large white sphere
	float x = ofGetWidth() / 2, y = ofGetHeight() / 2;    
	// semi-major and minor axes
	float sma1 = ofGetHeight(), sma2 = ofGetHeight();         

	//velocity
	float avx = NAN, avy = NAN; // post-atom displacement estimate
	float cvx = NAN, cvy = NAN; // post-cluster displacement estimate
	float mvx = NAN, mvy = NAN; // average member velocity
	
	// tan of orientation radians
	float tanphi = 0;		      
	
	// rim color
	static constexpr unsigned char colch[4] = {255, 255, 255, 127};
	static constexpr int hexcol = 0xffffff; // white
	
	// member suprisal list
	std::vector<float> memsu;     
	
	// matching entity id
	unsigned int entid;	      
	
	// live or dead
	bool alive = true;                   
	

	// overloaded constructor (spawn cluster)
	Cluster() {
		x = ofRandomuf() * ofGetWidth();  //ofRandomWidth();
		y = ofRandomuf() * ofGetHeight();    
		//colch = {255, 255, 255, 255}; // white  // error: questions/30178879/how-can-i-assign-an-array-from-an-initializer-list
	};
	Cluster(float x_, float y_, float sma1_, float sma2_, float tanphi_, std::vector<unsigned int> memls_, std::vector<float> memsu_) 
		: x(x_), y(y_), sma1(sma1_), sma2(sma2_), tanphi(tanphi_), memls(memls_), memsu(memsu_) {};
	Cluster(float x_, float y_, float sma1_, float sma2_, float tanphi_) 
		: x(x_), y(y_), sma1(sma1_), sma2(sma2_), tanphi(tanphi_) {};
	Cluster(float x_, float y_, float sma1_) 
		: x(x_), y(y_), sma1(sma1_), sma2(sma1_) {};
	Cluster(float x_, float y_, float sma1_, unsigned int atcol) 
		: x(x_), y(y_), sma1(sma1_), sma2(sma1_), memls(std::vector<unsigned int>{atcol}) {};

	// copy constructor not deleted if const member is rendered static constexpr

	friend class ClusterDendron;


	// METHODS
	
	void drawEllipse(unsigned int l) const {
		const float ew = std::max(2*sma1, 2*Atom::ra); // ellipse width or major axis
		const float eh = std::max(2*sma2, 2*Atom::ra); // ellipse height or minor axis
		ofSetColor(colch[0], colch[1], colch[2], std::min(colch[3] + (l-1)*16, 255U)); //ofSetColor(hexcol); 
		ofSetLineWidth(l * strokeWidth);

		//openframeworks.cc/ofBook/chapters/intro_to_graphics.html
		ofPushMatrix();  // forum.openframeworks.cc/t/simple-rotation-question/3154/4
		ofTranslate(x, y);
		ofRotateRad(std::atan(tanphi)); // pi is M_PI
		ofDrawEllipse(0, 0, ew, eh); // width = 2*sma1; height = 2*sma2 
		ofPopMatrix();
		//ofRotateRad(-std::atan(tanphi));

		// openframeworks.cc/documentation/graphics/ofPath/
		//ofPath path; path.ellipse(x, y, sma2, sma1);
		//path.translate(x, y);
		// openframeworks.cc/documentation/glm/
		//glm::vec2 ra(0, 0); path.rotateRad(std::atan(tanphi), ra); path.setStrokeWidth(strokeWidth); path.draw();
		//community.khronos.org/t/circles-ellipses-with-stipple-pattern/24157/3
	}
	void drawTriangle(unsigned int l, const std::vector<std::vector<Cluster>>& D) const {
		ofSetColor(colch[0], colch[1], colch[2], std::min(colch[3] + (l-1)*16, 255U)); 
		std::vector<Cluster> tc(3);
		for (unsigned int i = 0; i < 3; i++)
			tc[i] = D[l-1][memls[i]];
		ofSetLineWidth(strokeWidth);
		ofDrawTriangle(tc[0].x, tc[0].y, tc[1].x, tc[1].y, tc[2].x, tc[2].y);
	}
	void drawSpokes(unsigned int l, const std::vector<std::vector<Cluster>>& D) const {
		ofSetColor(colch[0], colch[1], colch[2], l * 16U); 
		std::vector<Cluster> tc(3);
		ofSetLineWidth(l * strokeWidth);
		for (unsigned int i = 0; i < memls.size(); i++) 
			ofDrawLine(x, y, D[l-1][memls[i]].x, D[l-1][memls[i]].y);
	}


	// covariance matrix reconstruction
	Eigen::Matrix2f rebuildCovmat() {
		Eigen::Vector2f sv(sma1, sma2); // sv << sma1, sma2; singular values

		if (sma1 == sma2) 
			return sv.cwiseAbs2().asDiagonal(); 
		
		const float phi = std::atan(tanphi);  //in radians
		// rotation matrix: from 0 to semi-major axis orientation
		Eigen::Matrix2f R; 
		R << std::cos(phi), -std::sin(phi), std::sin(phi), std::cos(phi);

		// M = U * S * Vt,  (V is transposed);    Mt * M = V * St*S * Vt
		const Eigen::Matrix2f V(R);  // this is the rotation from sv space to covmatrix space  
		//const Eigen::DiagonalMatrix<float, 2> S = sv.asDiagonal(); // S.diagonal() = sv;           
		const Eigen::Matrix2f S(sv.asDiagonal()); 
		
		return V * S * S * V.transpose(); // ellipse axis length is sqrt of covariance
	}

};


class ClusterDendron {
	unsigned int numlev;                  // number of levels: nl = D.size()
	static constexpr int minClusMembCount = 2;
	static constexpr bool sphericalVar = false;
public:
	AtomMash* A;
	std::vector<std::vector<Cluster>> D;  // hierarchy of clusters
	
	unsigned int nsplits = 0;
	unsigned int nmerges = 0;
	

	// CONSTRUCTOR
	ClusterDendron() : numlev(1), D(1, std::vector<Cluster>()) {}

	ClusterDendron(AtomMash* A_) : A(A_), numlev(1), D{std::vector<Cluster>()} {}

	// Initialize cluster dendron first (atom) level
	void fillAtomicLevel() {
		for (unsigned int aci = 0; aci < NC; aci++)
			for (auto &a : *A->colors[aci]) {
				D[0].push_back(Cluster(a.x, a.y, a.ra, aci));
			}
	}

	// Create primordial cluster in level 1 (just above atomic level)
	void conceivePrimal() {
		D.push_back(std::vector<Cluster>{Cluster()});
		auto& M = D[1][0].memls;
		M.resize(A->countAll());
		std::iota(std::begin(M), std::end(M), 0);	
	}

	// FRIENDS
	friend class EntityDendron;


	// UPDATE TREE
	
	void updateAtomicLevel() {
		for (unsigned int aci = 0; aci < NC; aci++) {
			std::vector<Atom> &av = *(A->colors[aci]);
			unsigned int napc = A->colors[aci]->size(); // av.size()
			for (unsigned int ci = 0; ci < napc; ci++) {
				D[0][ci + napc*aci].x = av[ci].x;
				D[0][ci + napc*aci].y = av[ci].y;
				D[0][ci + napc*aci].cvx = av[ci].vx;
				D[0][ci + napc*aci].cvy = av[ci].vy;
				D[0][ci + napc*aci].avx = av[ci].vx;
				D[0][ci + napc*aci].avy = av[ci].vy;
				D[0][ci + napc*aci].mvx = av[ci].vx;
				D[0][ci + napc*aci].mvy = av[ci].vy;
			}
		}
	}

	
	// COUNT, SHOW
	// count atoms
	unsigned int atomCount() const {
		return D[0].size();	
	};
	// count clusters
	unsigned int maxNumLiveClusters() const {
		return static_cast<unsigned int>(atomCount() * (1/(1-1.f/5) - 1));
	};
	int** countClike() {
		// no way to tell the length of the returned pointed array
		// https://stackoverflow.com/questions/4108313/how-do-i-find-the-length-of-an-array
		// https://stackoverflow.com/questions/19894686/getting-size-of-array-from-pointer-c
		//  requires delete[]'ing later 
		if (D.size() < 1) return  NULL;
		int *nlc, *ndc;
		int slc = 0, sdc = 0;
		for (unsigned int l = 1; l < D.size(); l++) {
			nlc[l] = ndc[l] = 0;
			for (auto& C : D[l]) 
				(C.alive) ? nlc[l]++ : ndc[l]++;
			slc += nlc[l]; sdc += ndc[l];
		};
		// array of pointers to arrays dynamically allocated
		int** nldc = new int*[4]; 
		// if **nld = {..}, error: scalar object ‘nld’ requires one element in initializer
		// https://stackoverflow.com/questions/17521853/whats-the-difference-between-int-and-int
		// so alternatively *nld[] = {..,..}
		nldc[0] = nlc; nldc[1] = ndc; nldc[2] = &slc; nldc[3] = &sdc;
		return nldc; 
	};
	std::array<std::vector<unsigned int>,2> count() const {
		if (D.size() < 1) 
			return  std::array<std::vector<unsigned int>,2>();

		std::vector<unsigned int> nlc(D.size(), 0), ndc(D.size(), 0);
		for (unsigned int l = 1; l < D.size(); l++)
			for (auto& C : D[l]) 
				(C.alive) ? nlc[l]++ : ndc[l]++;

		std::array<std::vector<unsigned int>,2> nldc;
		nldc[0] = nlc; nldc[1] = ndc;
		return nldc; 
	};
	unsigned int countAllLive() const {
		std::array<std::vector<unsigned int>,2> nldc = count();
		return vectorSum(nldc[0]);
	}

	unsigned int topLiveClusLev() const {
		std::vector<unsigned int> nlc(count()[0]);
		for (unsigned int l = nlc.size() - 1; l >= 1; l--)
			if (nlc[l] > 0) 
				return l;
		return nlc.size() - 1;
		
	};

	// extract clusters	
	std::vector<std::vector<Cluster>> liveClusDendron() const {
		std::vector<std::vector<Cluster>> lcd(D.size());
		for (unsigned int l = 0; l < D.size(); l++)  
			//cplusplus.com/reference/vector/vector/cbegin/
			//stackoverflow.com/questions/50710023/how-can-i-fix-this-error-conversion-from-const-iterator-to-non-scalar-type
			for (std::vector<Cluster>::const_iterator it = D[l].cbegin(); it < D[l].cend(); it++)
				if (it->alive)
					lcd[l].push_back(*it);
		return lcd;
	};
	std::vector<std::vector<unsigned int>> liveClusIds() const {
		std::vector<std::vector<unsigned int>> lci(D.size());
		for (unsigned int l = 0; l < D.size(); l++)  
			for (unsigned int ci = 0; ci < D[l].size(); ci++)
				if (D[l][ci].alive)
					lci[l].push_back(ci);
		return lci;
	}
	Cluster omniClus() const {
		std::vector<unsigned int> om(atomCount());
		std::iota(std::begin(om), std::end(om), 0); // fill with increasing values
	       	const std::array<std::vector<float>,2> X = getMembersCoordinates(1, om);
		const std::array<float,2> bc = getBarycenter(X);	
		const JsvdXf usv(svdFromCoords(X, bc));
		Eigen::Vector2f sv = usv.singularValues(); // sv's are always sorted in decreasing order
		const Eigen::Matrix2f V = usv.matrixV(); //the m first columns of V are the right sv's
		const float tanphi = V(1,0) / V(0,0); // first right sv: the right sv's are in V's columns
		sv = regularizeCovmat(X, sv);
		Cluster oc(bc[0], bc[1], sv(0), sv(1), tanphi);
		oc.memls = om;
		// specific surprisal benchmark = sum(oc.memsu) / atomCount()
		oc.memsu = computeMemsuAnew(1, om, oc.rebuildCovmat());
		return oc;
	}
	
	// parent clusters
	unsigned int findParentCluster(unsigned int l, unsigned int ci) const {
		if (l < topLiveClusLev() && D[l+1].size() > 0) {
			for (unsigned int i = 0; i < D[l+1].size(); i++) {
				if (D[l+1][i].alive && vectorIncludes(D[l+1][i].memls, ci))
			//for (unsigned int i : liveClusIds()[l+1]) {
			//	if (vectorIncludes(D[l+1][i].memls, ci))
					return i;  // if v includes ci then return i
			}
			return UINT_MAX;		
		} else
			return UINT_MAX;
	}
	// cluster sizes
	std::vector<std::vector<unsigned int>> livCluSiz() const {
		std::vector<unsigned int> maxclusiz(D.size()), maxclusizid(D.size());
		for (unsigned int l = 1; l < D.size(); l++) {
			// l=0 is not used
			maxclusiz[l] = 0;
			for (unsigned int ci = 0; ci < D[l].size(); ci++) {
				if (D[l][ci].alive && D[l][ci].memls.size() > maxclusiz[l]) {
					maxclusiz[l] = D[l][ci].memls.size();	
					maxclusizid[l] = ci;	
				}
			}
		}
		std::vector<std::vector<unsigned int>> clusiz(D.size());
		// use level 0 for the aggregate; +1 to account for dead empty clus
		clusiz[0] = std::vector<unsigned int>(vectorMax(maxclusiz)+1); 
		for (unsigned int l = 1; l < D.size(); l++) {
			clusiz[l] = std::vector<unsigned int>(maxclusiz[l]+1);
			for (unsigned int ci = 0; ci < D[l].size(); ci++) {
				if (D[l][ci].alive) {
					clusiz[l][D[l][ci].memls.size()] += 1; 
					clusiz[0][D[l][ci].memls.size()] += 1;
				}
			}	
		}
//if (clusiz.size() != topLiveClusLev()) 
//	throw "crap";
		return clusiz;	
	}

	// computing member stats
	std::array<std::vector<float>,8> getMembersStats(unsigned int l, vector<unsigned int> mis) const {
		const unsigned int nm = mis.size();
		const vector<Cluster> B = D[l-1]; // cluster level below 
		std::vector<float> X, Y, CVx, CVy, AVx, AVy, MVx, MVy;
		X.reserve(nm); Y.reserve(nm);
		CVx.reserve(nm); CVy.reserve(nm);
		AVx.reserve(nm); AVy.reserve(nm);
		MVx.reserve(nm); MVy.reserve(nm);
		for (auto mi : mis) {
			X.push_back(B[mi].x);
			Y.push_back(B[mi].y);
			CVx.push_back(B[mi].cvx);
			CVy.push_back(B[mi].cvy);
			AVx.push_back(B[mi].avx);
			AVy.push_back(B[mi].avy);
			MVx.push_back(B[mi].mvx);
			MVy.push_back(B[mi].mvy);
		}
		return {X, Y, CVx, CVy, AVx, AVy, MVx, MVy};	
	}; 
	std::array<std::vector<float>,2> getMembersCoordinates(unsigned int l, vector<unsigned int> mis) const {
		std::array<std::vector<float>,8> S = getMembersStats(l, mis);
		std::array<std::vector<float>,2> XY = {S[0], S[1]};
		return XY;
	}
	std::array<std::vector<float>,2> getMembersVelocities(unsigned int l, vector<unsigned int> mis) const {
		std::array<std::vector<float>,8> S = getMembersStats(l, mis);
		std::array<std::vector<float>,2> V = {S[2], S[3]};
		return V;
	}

	std::array<float,2> getBarycenter(std::array<std::vector<float>,2> XY) const {	
		const float nm = XY[0].size();
		const float x = vectorSum(XY[0]) / nm;	
		const float y = vectorSum(XY[1]) / nm;	
		std::array<float,2> bc = {x, y};
		return bc;
	};

	// sum of members' barycenter power distances
	std::vector<float> computeMempowdis(int l, std::vector<unsigned int> mis, int p) const {
		const unsigned int nm = mis.size();
		const std::vector<Cluster> B = D[l-1];
	        std::array<std::vector<float>,2> X = getMembersCoordinates(l, mis);
		const std::array<float,2> bc = getBarycenter(X);
		vector<float> mempd(nm);
		for (auto m : mis) {
			vector<float> v = {B[m].x - bc[0], B[m].y - bc[1]};
			const float pd = std::pow(std::abs(v[0]), p) + std::pow(std::abs(v[1]), p);
			mempd.push_back(pd);
		}
		return mempd;
	};

	// sum of members' surprisals
	std::vector<float> computeMemsuAnew(unsigned int l, std::vector<unsigned int> mis, Eigen::Matrix2f V) const {
		const unsigned int nm = mis.size();
		const std::vector<Cluster> B = D[l-1];
	        std::array<std::vector<float>,2> X = getMembersCoordinates(l, mis);
		const std::array<float,2> bc = getBarycenter(X);
		vector<float> memsu; 
		memsu.reserve(nm);
		for (unsigned int m : mis) {
			//vector<float> v = {B[m].x - bc[0], B[m].y - bc[1]}; Eigen::Vector2f ev(v.data()); 
			Eigen::Vector2f ev(B[m].x - bc[0], B[m].y - bc[1]); 
			memsu.push_back(nlg(ev, V)); // notice this is not mip as in the JS version
		}
		return memsu;
	};
	std::vector<float> recomputeMemsu(unsigned int l, unsigned int ci, Eigen::Matrix2f Cov) const {
		std::vector<float> ms;
		const Cluster& c = D[l][ci]; 
		for (unsigned int i = 0; i < c.memls.size(); i++) {
			unsigned int mi = c.memls[i];
			const float dx = D[l-1][mi].x - c.x;
			const float dy = D[l-1][mi].y - c.y;
			ms.push_back(nlg(Eigen::Vector2f(dx, dy), Cov));	
		}
		return ms;
	}

	// total surprisal or model evidence or free energy (if BUNCH is seen as recognition density)
	std::vector<float> totSurpByLev() const {
		std::vector<float> tsl(topLiveClusLev() + 1);
		for (unsigned int l = 1; l <= topLiveClusLev(); l++) 
			for (const auto& c : D[l])
				if (c.alive)
					tsl[l] += vectorSum(c.memsu); 
		return tsl;
	}
	std::vector<float> totSurpPerAtomByLev() const {
		std::vector<float> tsal(topLiveClusLev() + 1);
		std::vector<float> tsl = totSurpByLev();
		for (unsigned int l = 1; l <= topLiveClusLev(); l++) 
			tsal[l] = (l==1)? tsl[l] / atomCount() : tsl[l] = count()[0][l-1]; 
		return tsal;
	}
	float totSurpPerLivclu() const { 
		return vectorSum(totSurpByLev()) / vectorSum(count()[0]);
	}
	float totSurpPerAtom() const {
		return vectorSum(totSurpByLev()) / atomCount();
	}

	// output
	friend std::ostream& operator<<(std::ostream& os, const ClusterDendron& cd) {
		os << "cluster dendron attributes\n";
		os << "number of levels: " << cd.D.size() << "\n";
	        os << cd.nsplits << " splits and " << cd.nmerges << " merges" << endl;
		const auto lci = cd.liveClusIds();
		for (unsigned int l = 0; l < cd.D.size(); l++) {
			unsigned int ci = static_cast<unsigned int>(ofRandom(cd.D[l].size())); 
			if (lci[l].size() > 0)
			       do ci = static_cast<unsigned int>(ofRandom(cd.D[l].size())); while (!cd.D[l][ci].alive);
			const Cluster& c = cd.D[l][ci];
			unsigned int nlm = 0;
			for (std::size_t cj = 0; cj < cd.D[l].size(); cj++)
				if (cd.D[l][cj].alive)
					nlm += cd.D[l][cj].memls.size();
			os << "level " << l << "\n"
			   << "size:\t" << cd.D[l].size() << "\t(" << cd.count()[0][l] << " live, " << cd.count()[1][l] << " dead)" << "\n"
			   << "live clus ids: " << lci[l] << "\n"
			   << "capacity:\t" << cd.D[l].capacity() << "\n"
			   << "max_size:\t" << cd.D[l].max_size() << "\n"
			   << "total number of live clus members in level: " << nlm << "\n"
			   << "cluster " << ci << " number of members: " << cd.D[l][ci].memls.size() << "\n"
			   << "cluster " << ci << " first 10 members:\t";
		       	for (unsigned int mi = 0; mi < 10 && mi < cd.D[l][ci].memls.size(); mi++)
				os << " " << cd.D[l][ci].memls[mi];
			os << "\n"
			   << "cluster " << ci << " lifeness: " << c.alive << "\n"
			   << "cluster " << ci << " entid: " << c.entid << "\n"
			   << "cluster " << ci << " coordinates: (" << c.x << ", " << c.y << ")\n"
			   << "cluster " << ci << " velocities: (" << c.cvx << ", " << c.cvy << ")\n"
			   << "cluster " << ci << " semiaxes: (" << c.sma1 << ", " << c.sma2 << ")\n";
		}
		return os;
    	}


	// BREED, KILL, PRUNE, GRAFT

	unsigned int breedCluster(int l, float x, float y, float sma1, float sma2, float tanphi, std::vector<unsigned int> memls, std::vector<float> memsu) {
		Cluster C(x, y, sma1, sma2, tanphi, memls, memsu);
		D[l].push_back(C);
		return D[l].size() - 1;
	}
	unsigned int breedCluster(int l, float x, float y, float sma1, std::vector<unsigned int> memls, std::vector<float> memsu) {
		return breedCluster(l, x, y, sma1, sma1, 0, memls, memsu);
	}
	
	// create and attach new top layer
	void tackNewTopLevelOnDendron(Cluster c) {
		unsigned int otl = topLiveClusLev();
		D.push_back(vector<Cluster>(1));
		//D[otl+1].push_back(c);
		D[otl+1][0] = c;
	}
	
	void killCluster(int l, int ci) {
		D[l][ci].alive = false;
	}

	void graftIntoParentCluster(int l, int ci, int pi, float misu) {
		Cluster& P = D[l+1][pi];
		P.memls.push_back(ci);
		P.memsu.push_back(misu);
	}

	void pruneParentCluster(int l, int ci, int pi) {
		Cluster& P = D[l+1][pi]; 
		auto& pcm = P.memls; 
		const auto it = std::find(pcm.begin(), pcm.end(), ci); 
		const int pci = it - pcm.begin(); 
		pcm.erase(pcm.begin() + pci); // pcm.erase(std::next(pcm.begin(), pci), std::next(pcm.begin(), pci+1))
		P.memsu.erase(P.memsu.begin() + pci); 
	}
	void pruneParentCluster(int l, int ci) {
		unsigned int pi = findParentCluster(l, ci);
		pruneParentCluster(l, ci, pi);
	}


	// BISECT-UNITE / SPLIT-MERGE
	
	std::tuple<bool, std::vector<unsigned int>**> trySplitting1ClusterGreedily(unsigned int l) {
		// similar to bisecting k-means
		std::vector<unsigned int> C0, B1, B2;
		std::vector<unsigned int>* ssp[3] = {&C0, &B1, &B2};
									      
		// randomly pick rci
		std::uniform_int_distribution<unsigned int> uid_rci(0, D[l].size() - 1); //  map mterui's rand posint into [0, D[l]-1]
		unsigned int rci;
		do rci = uid_rci(mterui);
		while (!D[l][rci].alive);
		Cluster C(D[l][rci]);    // default copy constructor operator
		C0 = C.memls;
		const unsigned int nm = C0.size();
		if (nm < 2*minClusMembCount)
			return {false, ssp};

		// randomly partition C: n-subset of C, with 2 <= n <= Csize-2
		std::vector<unsigned int> mis;
		std::uniform_int_distribution<unsigned int> uid_bipart(2, nm-2); //disallow clusters of size less than 2
		const unsigned int n = uid_bipart(mterui);
		while (B1.size() != n) {
			std::uniform_int_distribution<unsigned int> uid_loc(0, nm-1); // masking global uid 
			const unsigned int ri = uid_loc(mterui); 
			unsigned int j;
			for (j = 0; j < mis.size(); j++)
				if (mis[j] == ri)
					break;
			if (j == mis.size()) {
				mis.push_back(ri);
				B1.push_back(C.memls[ri]);
			}
		}
		B2 = subtractSets(C.memls, B1);

		// compute sum of intercluster distances/suprisals
		const Eigen::Matrix2f Cov0 = C.rebuildCovmat();  // V0 = [1 0; 0 1]/
		Eigen::Matrix2f Cov1, Cov2;
		Eigen::Vector2f sv1, sv2; 
		float tanphi1, tanphi2, sphsv1, sphsv2;
	        std::array<std::vector<float>,2> X1 = getMembersCoordinates(l, B1);
	        std::array<std::vector<float>,2> X2 = getMembersCoordinates(l, B2);
	        std::array<float,2> bc1 = getBarycenter(X1);	
	        std::array<float,2> bc2 = getBarycenter(X2);	
		if (!sphericalVar) { // elliptical cluster
			JsvdXf usv1(svdFromCoords(X1, bc1));
			JsvdXf usv2(svdFromCoords(X2, bc2));
			// n x p matrix M; m = min(n,p)
			sv1 = usv1.singularValues(); // sv's are always sorted in decreasing order
			Eigen::MatrixXf U1 = usv1.matrixU(); // the m first columns of U are the left sv's
			Eigen::Matrix2f V1 = usv1.matrixV(); //the m first columns of V are the right sv's
			sv2 = usv2.singularValues(); 
			Eigen::MatrixXf U2 = usv2.matrixU(); 
			Eigen::Matrix2f V2 = usv2.matrixV();
							   
			tanphi1 = V1(1,0) / V1(0,0); // first right sv: the right sv's are in V's columns
			tanphi2 = V2(1,0) / V2(0,0); 

			// two-point clusters yield singular covariance matrices: eschew by setting a positive minimum sma
			sv1 = regularizeCovmat(X1, sv1);
			sv2 = regularizeCovmat(X2, sv2);

			//   M = U * S * Vt,  (V is transposed);    Mt * M = V * St*S * Vt
			Cov1 = V1 * sv1.asDiagonal() * sv1.asDiagonal() * V1.transpose();  //var-cov matrices hold sqrd distances
			Cov2 = V2 * sv2.asDiagonal() * sv2.asDiagonal() * V2.transpose();  

		} else { // spherical cluster
			sphsv1 = std::sqrt((vectorSumsq(X1[0]) + vectorSumsq(X1[1])) / X1[0].size());		
			sphsv2 = std::sqrt((vectorSumsq(X2[0]) + vectorSumsq(X2[1])) / X2[0].size());		
			Cov1 = Eigen::Vector2f(sphsv1*sphsv1, sphsv1*sphsv1).asDiagonal();
			Cov2 = Eigen::Vector2f(sphsv2*sphsv2, sphsv2*sphsv2).asDiagonal();
		}
		std::vector<float> msu0 = computeMemsuAnew(l, C.memls, Cov0);
		std::vector<float> msu1 = computeMemsuAnew(l, B1, Cov1);
		std::vector<float> msu2 = computeMemsuAnew(l, B2, Cov2);

		unsigned int pi;
		Cluster P;
		if (l < topLiveClusLev()) {
			pi = findParentCluster(l, rci);
			P = D[l+1][pi]; 
		} else if (l == topLiveClusLev()) {  // there should be only one top cluster  
			// potential new top cluster for l+1
	        	std::array<std::vector<float>,2> XP = zipTwoArrays(bc1, bc2);
	        	std::array<float,2> bcP = {(bc1[0]+bc2[0])/2, (bc1[1]+bc2[1])/2};	
			if (!sphericalVar) {
				JsvdXf usvP(svdFromCoords(XP, bcP));
				Eigen::Vector2f svP = usvP.singularValues(); 
				svP = regularizeCovmat(XP, svP);
				Eigen::MatrixXf VP = usvP.matrixV();
				const float tanphiP = VP(1,0) / VP(0,0); 
				P = Cluster(bcP[0], bcP[1], svP(0), svP(1), tanphiP);
			} else {
				float sphsvP = std::sqrt((vectorSumsq(XP[0]) + vectorSumsq(XP[1])) / XP[0].size());		
				P = Cluster(bcP[0], bcP[1], sphsvP);
			}
		}

		// compute sum of inter-centroid Mahalanobis squared distances
		const Eigen::Matrix2f CovP = P.rebuildCovmat();  
		Eigen::Vector2f cpd0(C.x - P.x, C.y - P.y); // parent to current cluster barycenter distance
		Eigen::Vector2f cpd1(bc1[0] - P.x, bc1[1] - P.y); // parent to children 1 cluster barycenter distance
		Eigen::Vector2f cpd2(bc2[0] - P.x, bc2[1] - P.y); // parent to children 2 cluster barycenter distance
		float ssu0 = vectorSum(msu0) + nlg(cpd0, CovP); // if new top cluster
		float ssu1 = vectorSum(msu1) + nlg(cpd1, CovP); 
		float ssu2 = vectorSum(msu2) + nlg(cpd2, CovP); 

		ofLogNotice("try splitting");
		ofLogNotice() << "ssu of parent and children: " << ssu0 << "; " << ssu1+ssu2 << " = " << ssu1 << " + " << ssu2 << endl;
		ofLogNotice() << "parent and children sizes: " << C.memls.size() << " and " << B1.size() <<  ", " << B2.size() << endl;

		if (ssu1 + ssu2 < ssu0) {  // splitting
			// kill formerly united cluster and prune its parent
			killCluster(l, rci);
			
			// add to entities array and create 2 new clusters
			unsigned int ci1, ci2;
			if (!sphericalVar) {
				ci1 = breedCluster(l, bc1[0], bc1[1], sv1[0], sv1[1], tanphi1, B1, msu1); 
				ci2 = breedCluster(l, bc2[0], bc2[1], sv2[0], sv2[1], tanphi2, B2, msu2); 
			} else {
				ci1 = breedCluster(l, bc1[0], bc1[1], sphsv1, B1, msu1); 
				ci2 = breedCluster(l, bc2[0], bc2[1], sphsv2, B2, msu2); 
			}

			// prune 1 and graft 2 members
			if (l < topLiveClusLev()) {
				pruneParentCluster(l, rci, pi);
				graftIntoParentCluster(l, ci1, pi, nlg(cpd1, CovP));
				graftIntoParentCluster(l, ci2, pi, nlg(cpd2, CovP));
			} else if (l == topLiveClusLev()) {
				// stack a new l+1-topcluster after splitting old l-topclus
				P.memls.push_back(ci1);
				P.memls.push_back(ci2);  // graft splits into new parent cluster
				P.memsu.push_back(nlg(cpd1,CovP));
				P.memsu.push_back(nlg(cpd2,CovP));
				// create new top layer
				if (D.size() - 1 == topLiveClusLev()) // the top level holds 1 live clus; no dead top level
					tackNewTopLevelOnDendron(P); // hence if we split it we need to tack a level on the dendron
				else
					D[l+1].push_back(P);
			}

			ofLogNotice() << "split " << ++nsplits << endl;

			return {true, ssp}; 
		} else {   // no splitting
			return {false, ssp};
		}
	}

	std::tuple<bool, std::vector<unsigned int>**> tryMerging2ClustersGreedily(unsigned int l) {
		std::vector<unsigned int> C1, C2, C3;	
		std::vector<unsigned int>* msp[3] = {&C1, &C2, &C3};

		if (l == topLiveClusLev())
			return {false, msp};

		// pick two arbitrary distinct clusters with common cluster parent
		unsigned int ci1, pi1, ci2, pi2;
		if (l == topLiveClusLev() - 1) {
			std::uniform_int_distribution<unsigned int> uid_rci(0, D[l].size() - 1); 
			unsigned int rci;
			// kill parent cluster if it's top and has no other children
			if (count()[0][l] == 1) {
				do rci = uid_rci(mterui);
				while (!D[l][rci].alive);
				pi1 = findParentCluster(l, rci);
				killCluster(l+1, pi1);
				
				ofLogNotice() << "top cluster removed" << endl;
				return {false, msp};
			}

			do {
				ci1 = uid_rci(mterui);           ci2 = uid_rci(mterui); 
				pi1 = findParentCluster(l, ci1); pi2 = findParentCluster(l, ci2);
          		} while (ci2 == ci1 || !D[l][ci1].alive || !D[l][ci2].alive);

		} else {
			if (count()[0][l] == 1) 
				return {false, msp};   // only 1 live cluster at level l

			// pick 1 cluster parent from the supraordinate level
			std::uniform_int_distribution<unsigned int> uid_rpi(0, D[l+1].size() - 1); 
			do pi1 = uid_rpi(mterui);
			while (!D[l+1][pi1].alive);
			const Cluster P = D[l+1][pi1];
			const unsigned int nm = P.memls.size(); 

			// pick another cluster parent
			std::uniform_int_distribution<unsigned int> uid_rci(0, nm - 1); 
			if (nm >= 2) {
				pi2 = pi1;
				do {	ci1 = P.memls[uid_rci(mterui)]; 
					ci2 = P.memls[uid_rci(mterui)]; 
				} while (ci1 == ci2 || !D[l][ci1].alive || !D[l][ci2].alive);
			} else { // nm==1
				//do not merge if there are 2 or less siblings: this precludes a level 1 universal gigacluster
				// trying to merge a single-child parent cluster with other cluster
				ci1 = P.memls[0];
				do pi2 = uid_rpi(mterui);
				while (!D[l+1][pi2].alive || pi2 == pi1);
				const Cluster P2 = D[l+1][pi2]; 
				const unsigned int nm2 = P2.memls.size(); 
				std::uniform_int_distribution<unsigned int> uid_rci2(0, nm2 - 1); 
				do ci2 = P2.memls[uid_rci2(mterui)];
				while (!D[l][ci2].alive);
			}
		}

		// common parent
		Cluster P = D[l+1][pi1];	
		Cluster P2 = D[l+1][pi2];	// P==P2 except if P is a single-child parent
		
		// define subclusters/children clusters
		C1 = D[l][ci1].memls;	
		C2 = D[l][ci2].memls;	
		C3 = C1; 
		C3.insert(C3.end(), C2.begin(), C2.end()); 
		//there should be no repeats	

		// compute sum of squared/mahalanobis distances
		const Eigen::Matrix2f Cov1 = D[l][ci1].rebuildCovmat(); // covmat = [[1 0] [0 1]] 
		const Eigen::Matrix2f Cov2 = D[l][ci2].rebuildCovmat(); 
	        const std::array<std::vector<float>,2> X3 = getMembersCoordinates(l, C3);
	        const std::array<float,2> bc3 = getBarycenter(X3);	
		Eigen::Matrix2f Cov3;
		Eigen::Vector2f sv3; 
		float tanphi3, sphsv3;
		if (!sphericalVar) {
			JsvdXf usv3(svdFromCoords(X3, bc3));
			// n x p matrix M; m = min(n,p)
			sv3 = usv3.singularValues(); // sv's are always sorted in decreasing order
			Eigen::MatrixXf U3 = usv3.matrixU(); // the m first columns of U are the left sv's
			//for k=min(m,n)=n<m, a thin SVD has mxn = mxn nxn nxn instead of mxn = mxm mxn nxn
			Eigen::Matrix2f V3 = usv3.matrixV(); //the m first columns of V are the right sv's
			tanphi3 = V3(1,0) / V3(0,0); // first right sv: the right sv's are in V's columns
			// two-point clusters yield singular covariance matrices: eschew by setting a positive minimum sma
			sv3 = regularizeCovmat(X3, sv3);
			//   M = U * S * Vt,  (V is transposed);    Mt * M = V * St*S * Vt
			Cov3 = V3 * sv3.asDiagonal() * sv3.asDiagonal() * V3.transpose();  //var-cov matrices hold sqrd distances
		} else {
			sphsv3 = std::sqrt((vectorSumsq(X3[0]) + vectorSumsq(X3[1])) / X3[0].size());		
			Cov3 = Eigen::Vector2f(sphsv3*sphsv3, sphsv3*sphsv3).asDiagonal();
		}
		std::vector<float> msu1 = computeMemsuAnew(l, C1, Cov1);
		std::vector<float> msu2 = computeMemsuAnew(l, C2, Cov2);
		std::vector<float> msu3 = computeMemsuAnew(l, C3, Cov3);
	        std::array<std::vector<float>,2> X1 = getMembersCoordinates(l, C1);
	        std::array<std::vector<float>,2> X2 = getMembersCoordinates(l, C2);
	        std::array<float,2> bc1 = getBarycenter(X1);	
	        std::array<float,2> bc2 = getBarycenter(X2);	

		// compute sum of inter-centroid squared/mahalanobis distances/surprisal
		// pre-merged cluster pair
		const Eigen::Matrix2f CovP = P.rebuildCovmat();
		const Eigen::Matrix2f CovP2 = P2.rebuildCovmat();
		Eigen::Vector2f cpd1(bc1[0] - P.x, bc1[1] - P.y); 
		Eigen::Vector2f cpd2(bc2[0] - P2.x, bc2[1] - P2.y); 
		float ssu1 = vectorSum(msu1) + nlg(cpd1, CovP); 
		float ssu2 = vectorSum(msu2) + nlg(Eigen::Vector2f(bc2[0]-P2.x, bc2[1]-P2.y), CovP2); //CovP=CovP2 if pi1=pi2
		// merged cluster
		float ssu3 = vectorSum(msu3);
		float nlg3;
		// same for second parent P2 unlike P1==P, when P has a single child
		if (l < topLiveClusLev() - 1 && P.memls.size() == 1) { // two parents; at least one with single child
			// use P2 as new common parent: simply pick P2's centroids if P has a single child. even if P2 has also only one
			Eigen::Vector2f cpd3(bc3[0] - P2.x, bc3[1] - P2.y); 
			nlg3 = nlg(cpd3, CovP2);
		} else { // one common parent
			Eigen::Vector2f cpd3(bc3[0] - P.x, bc3[1] - P.y); 
			nlg3 = nlg(cpd3, CovP);
		}
		ssu3 += nlg3;


std::cout << vectorSum(msu1) << "+" << nlg(cpd1, CovP) << "=" << ssu1 << endl;
std::cout << vectorSum(msu2) << "+" << nlg(cpd2, CovP2) << "=" << ssu2 << endl;
std::cout << ssu3-nlg3 << "+" << nlg3 << "=" << ssu3 << endl;

		ofLogNotice("try merging");
		ofLogNotice() << "ssu of children and parent: " << ssu1 << " + " << ssu2 << " = " << ssu1+ssu2 << "; " << ssu3 << endl;
		ofLogNotice() << "children and parent sizes: " << C1.size() <<  ", " << C2.size() << " and " << C3.size() << endl;

		if (ssu3 < ssu1 + ssu2) {
			// kill former halves and prune parents
			killCluster(l, ci1);
			killCluster(l, ci2);
			pruneParentCluster(l, ci1, pi1); 
			//if pi1 had a single child, now it's childless, and will be killed by ekm
			pruneParentCluster(l, ci2, pi2); 

			// create new union and graft new children into it
			unsigned int ci3;
			if (!sphericalVar)
				ci3 = breedCluster(l, bc3[0], bc3[1], sv3[0], sv3[1], tanphi3, C3, msu3);
			else
				ci3 = breedCluster(l, bc3[0], bc3[1], sphsv3, C3, msu3);

			if (l < topLiveClusLev() - 1 && P.memls.size() == 1) // two parents, at least one has a single child
				graftIntoParentCluster(l, ci3, pi2, nlg3);
			else 
				graftIntoParentCluster(l, ci3, pi1, nlg3);

			ofLogNotice() << "merged " << ++nmerges << endl;

			return {true, msp};
		} else
			return {false, msp};
	}

	std::tuple<bool, unsigned int, unsigned int> splitMergeClusters() {
		const unsigned int N = maxNumLiveClusters();
		unsigned int lsl = D.size();  // lowest split level
		unsigned int lml = D.size();  // lowest merge level
		for (unsigned int l = 1; l <= topLiveClusLev(); l++) {

			if (vectorSum(count()[0]) < N) {
				//const auto sc = trySplitting1ClusterGreedily(l); std::get<bool>(sc)
				const auto [split, ssp] = trySplitting1ClusterGreedily(l); 
				if (split && l < lsl)
					lsl = l;
			}

			const auto [merged, msp] = tryMerging2ClustersGreedily(l);
			if (merged && l < lml)
				lml = l;

			if (l == topLiveClusLev() && D[l].size() == 1)
				break;
		}
		const bool splitOrMerged = (lsl < D.size() || lml < D.size()) ? true : false;

		ofLogNotice("split/merge") << count()[0] << " living clusters out of a max of " << N << " and " << atomCount() << " atoms ";
		ofLogNotice() << count()[1] << " dead clusters out of a max of " << N << " and " << atomCount() << " atoms ";
		ofLogNotice() << "lowest split and merge levels: " << lsl << ", " << lml << endl;
		ofLogNotice() << *this << endl;

		return {splitOrMerged, lsl, lml};
	}


	// EM-ALGORITHM: ELLIPTICAL K-MEANS
	
	void MstepTranslocation (unsigned int l) {
		for (auto& c : D[l]) {
			if (!c.alive)
				continue;
			const unsigned int nm = c.memls.size();
			if (nm < 1) // minClusMembCount
				continue;
	        	const std::array<std::vector<float>,2> X = getMembersCoordinates(l, c.memls);
			const std::array<float,2> bc = getBarycenter(X);	

			// velocity estimated via displacement
			// This reports velocity post-atomdisplacement estimates
			// The loop estimates are post-clusterdisplacement
			// Bear in midn that these are different things
			c.avx = bc[0] - c.x;
			c.avy = bc[1] - c.y; // dt
			// update displacement
			c.x = bc[0]; c.y = bc[1];

			// average member velocity
	        	//const std::array<std::vector<float>,2> V = getMembersVelocities(l, c.memls);
			//const std::array<float,2> vc = getBarycenter(V);	
			//c.mvx = vc[0]; c.mvy = vc[1];
		}
	}

	typedef std::vector<std::tuple<std::vector<float>, std::vector<float>, std::vector<unsigned int>, std::vector<float>>> vct;
	struct vcs {
	        std::vector<float> X;
		std::vector<float> Y;
	        std::vector<float> CVx, AVx, MVx;
		std::vector<float> CVy, AVy, MVy;
		std::vector<unsigned int> M;
		std::vector<float> S;
	};

	std::tuple<float, bool> ekmMstepVoronoiTranslocateReshape(unsigned int l, std::vector<vcs> vorcel) {
		float dssu = 0; // sum of surprisal change 
		bool reallocated = false;
		const float w = Cluster::csmr;
		for (unsigned int i = 0; i < D[l].size(); i++) {
			Cluster& c = D[l][i];
			if (!c.alive)
				continue;

			//const unsigned int nnc = std::get<2>(vorcel[i]).size();
			const unsigned int nnc = vorcel[i].M.size();
			
			if (nnc <= 0) {
				c.memls = vorcel[i].M; // empty vector or vector<uint>()
				continue; 
			}

			// translocate
			c.x = vectorSum(vorcel[i].X) / nnc;
			c.y = vectorSum(vorcel[i].Y) / nnc;

			// reshape
			float new_sma1, new_sma2, new_tanphi;
			if (!sphericalVar) {
				if (nnc > 1) {
					std::array<std::vector<float>,2> XY = {vorcel[i].X, vorcel[i].Y};
					std::array<float,2> bc = {c.x, c.y};
					JsvdXf usv(svdFromCoords(XY, bc));
					Eigen::Vector2f sv = usv.singularValues(); // sv's are always sorted in decreasing order
					Eigen::DiagonalMatrix<float,2> S(sv(0), sv(1));
					Eigen::MatrixXf U = usv.matrixU(); // the m first columns of U are the left sv's
					Eigen::Matrix2f V = usv.matrixV(); //the m first columns of V are the right sv's
					new_tanphi = V(1,0) / V(0,0); // first right sv: the right sv's are in V's columns
					sv = regularizeCovmat(XY, sv);
					new_sma1 = sv(0);
					new_sma2 = sv(1);
					//printing Eigen matrices in gdb: 
					//stackoverflow.com/questions/25085465/using-gdb-with-eigen-c-library
				} else {
					new_sma1 = Atom::ra;
					new_sma2 = Atom::ra;
					new_tanphi = 0;
				}
				// exponential smoothing for viewing cluster dynamics
				c.sma1 = (1-w) * c.sma1 + w * new_sma1;
				c.sma2 = (1-w) * c.sma2 + w * new_sma2;
				c.tanphi = (1-w) * c.tanphi + w * new_tanphi;
			} else {
				new_sma1 = (vectorStdev(vorcel[i].X, c.x) + vectorStdev(vorcel[i].Y, c.y)) / 2;  
				c.sma1 = (1-w) * c.sma1 + w * new_sma1;
			}

			// reallocate members maybe
			if (!equalMultisets(c.memls, vorcel[i].M)) { // if cluster members have changed
				reallocated = true;
				c.memls = vorcel[i].M;
			} 
			// recompute member surprisals
			const Eigen::Matrix2f Cov = c.rebuildCovmat(); // because of reshape smoothing
								       
			const vector<float> new_msu = recomputeMemsu(l, i, Cov); 
			dssu += vectorSum(new_msu) - vectorSum(c.memsu);

			c.memsu = new_msu; //c.memsu.swap(new_msu);
			
if (std::isnan(c.tanphi) || std::isinf(c.tanphi))	
	try {throw c.tanphi;}
	catch (...) {cout << "\ntanphi is nan or inf: tan(phi = )" << c.tanphi << "\n";}

			std::cout << "level " << l << " clus/vorcel " << i << " of size " << nnc << " and (" << new_sma1 << ", " << new_sma2 << "): " << vorcel[i].M << "; dssu " << dssu << " = " << vectorSum(new_msu) << " - " << vectorSum(c.memsu) << endl;
		}
		return {dssu, reallocated}; 
	}

	void updatePostClusDispVel(unsigned int l, std::vector<vcs> vorcel, std::vector<std::vector<Cluster>>& olD) {
		for (unsigned int i = 0; i < D[l].size(); i++) {
			Cluster& c = D[l][i];
			Cluster& olc = olD[l][i];
			if (!c.alive)
				continue;
			const unsigned int nnc = vorcel[i].M.size();

			const float new_x = vectorSum(vorcel[i].X) / nnc;
			const float new_y = vectorSum(vorcel[i].Y) / nnc;
			// average member velocity
			c.mvx = vectorSum(vorcel[i].MVx) / nnc;
			c.mvy = vectorSum(vorcel[i].MVy) / nnc;
			// velocity estimated via displacement
			c.cvx = new_x - olc.x;
			c.cvy = new_y - olc.y;
		}
	}

	bool ekmMstepKill(unsigned int l, std::vector<vcs> vorcel) {
		bool killed = false;
		const float w = Cluster::csmr;
		for (unsigned int i = 0; i < D[l].size(); i++) {
			Cluster& c = D[l][i]; 
			if (!c.alive) // if cluster is dead
				continue; 

			if (vorcel[i].M.size() >= minClusMembCount) { // cluster i remains non-degenerate
				// update drawing parameters: only in JS version
				//const unsigned int pi = findParentCluster(l, i);
			} else {	// if degenerate: kill or recreate degenerate cluster

				if (vorcel[i].M.size() == 1) {  // cluster i has a single child
					c.sma1 = (1-w) * c.sma1 + w * 0; // + w*Atom::ra; 
					c.sma2 = (1-w) * c.sma2 + 0;
					// single-child clusters may not collapse if they move?
					c.tanphi = (1-w) * c.tanphi + 0;
					c.memls = vorcel[i].M;
					c.memsu = vorcel[i].S;
				} else if (vorcel[i].M.size() == 0) {
					// kill and bury only if cluster is childless
					// it cannot be the top cluster, and there must be at least 2 live clus in its level 
					killCluster(l, i);
					pruneParentCluster(l, i);
					killed = true; 
					ofLogNotice() << "Death by childlessness of cluster " << i << " from level " << l << endl; 
				}
			}
		}
		return killed;
	}

	std::tuple<unsigned int, float> findNearestCentroid(unsigned int l, float x, float y) {
		unsigned int ncid = UINT_MAX;
		float ncsu = FLT_MAX;
		for (unsigned int i = 0; i < D[l].size(); i++) {
			Cluster& c = D[l][i];
			if (!c.alive)
				continue;
			const float dx = x - c.x;
			const float dy = y - c.y;
			const Eigen::Matrix2f Cov = c.rebuildCovmat();
			float su = nlg(Eigen::Vector2f(dx, dy), Cov); // surprisal or Shannon info
			if (su < ncsu) {
				ncid = i;
				ncsu = su;
			}
		}
		return {ncid, ncsu};
	}

	bool ellipticalKmeans(unsigned int l) {
		bool reallocated = false, killed = false;
		const unsigned int maxnit = 100;
		std::vector<vcs> vorcel(D[l].size());  // Voronoi cells
		ofLogNotice("EM loop");

		// E-step
		std::vector<std::vector<Cluster>> olD = D;  // old cluster dendron
		MstepTranslocation(l);
		unsigned int it;
		for (it = 0; it < maxnit; it++) {
			vorcel = std::vector<vcs>(D[l].size());

			for (std::size_t i = 0; i < D[l-1].size(); i++) {
				Cluster& c = D[l-1][i];
				if (!c.alive)
					continue;
				const auto [nci, ncsu] = findNearestCentroid(l, c.x, c.y);
				vorcel[nci].X.push_back(c.x);
				vorcel[nci].Y.push_back(c.y);
				vorcel[nci].M.push_back(i);
				vorcel[nci].S.push_back(ncsu);
				vorcel[nci].CVx.push_back(c.cvx); vorcel[nci].CVy.push_back(c.cvy);
				vorcel[nci].AVx.push_back(c.avx); vorcel[nci].AVy.push_back(c.avy);
				vorcel[nci].MVx.push_back(c.mvx); vorcel[nci].MVy.push_back(c.mvy);

if (c.x > ofGetWidth() || c.x < 0 || c.y > ofGetHeight() || c.y < 0)
	throw std::invalid_argument("out of box");

			}
			std::cout << "it " << it << " ";
			const auto [dssu, isrealloc] = ekmMstepVoronoiTranslocateReshape(l, vorcel);
			reallocated = isrealloc || reallocated;

			if (std::abs(dssu) < .1) {
				ofLogNotice() << "break EM loop; it = " << it << ", dss = " << dssu << endl;
				updatePostClusDispVel(l, vorcel, olD);
				break;
			}
		}
		if (it == maxnit)
			ofLogNotice() << "EM loop reached " << maxnit << " iterations (level " << l << ")" << endl;

		killed = ekmMstepKill(l, vorcel);

		return reallocated || killed;
	}
	
	std::tuple<bool, unsigned int> trackClusters () {
//unsigned int lrkl = D.size() - 1; // lowest reallocation or kill level
unsigned int lrkl = D.size(); // lowest reallocation or kill level
		bool reallocatedOrDied = false;

		for (unsigned int l = 1; l <= topLiveClusLev(); l++) {
			const unsigned int isrk = ellipticalKmeans(l);
			if (isrk && l < lrkl)
				lrkl = l;
			reallocatedOrDied = isrk || reallocatedOrDied;  // there is no ||=		
		}

		const auto [splitOrMerged, lsl, lml] = splitMergeClusters();  
		// auto-unpacking only works with definitions, otherwise it's confused with lambda

		return {(reallocatedOrDied || splitOrMerged), std::min({lrkl, lsl, lml})};
	}


	// DRAWING
	void drawLevel(unsigned int l, bool viewSpokes) const {
		for (auto& c : D[l]) // D[l] is evaluated only once, at the start of the loop 
			if (c.alive) {
				//const float lg = M_PI * std::sqrt(c.sma1*c.sma1 + c.sma2*c.sma2) / c.memls.size();
				c.drawEllipse(l);
				//if (c.memls.size() == 3) c.drawTriangle(l, D);
				if (viewSpokes) c.drawSpokes(l, D);
			}
	}
	void drawAll(bool viewSpokes) const {
		ofNoFill();
		ofSetCircleResolution(50);  // default is 20
		for (unsigned int l = 1; l <= topLiveClusLev(); l++) // l=0 for drawing atom auras
			drawLevel(l, viewSpokes);
	}


	// TRANSCRIPTION TO ENTITIES
	std::vector<unsigned int> transcribeClusToEntMulset(unsigned int l, unsigned int ci, EntityDendron &entden) const;

};



// ENTITIES

class Entity {
public:
	std::vector<unsigned int> memids;
	std::vector<unsigned int> clids;
	std::vector<float> birthtime;
	std::vector<float> lifespan;

	
	Entity() {};

	Entity(unsigned int mis_) : memids(std::vector<unsigned int>{mis_}) {};
	Entity(std::vector<unsigned int> mis_, std::vector<unsigned int> cis_, std::vector<float> bt_, std::vector<float> ls_) : memids(mis_), clids(cis_), birthtime(bt_), lifespan(ls_) {};

	friend class EntityDendron;

	unsigned int nm() {
		return memids.size();
	}
	bool alive() {
		return vectorIncludes<float>(lifespan, 0.f);
	}
};


class EntityDendron {
public:
	std::vector<std::vector<Entity>> D;


	EntityDendron() : D{std::vector<Entity>()} {};

	//friend class ClusterDendron;


	// Compute ents

	template <typename T>
	unsigned int findLastIndex(const std::vector<T>& v, unsigned int el) const {
		//stackoverflow.com/questions/24997910/get-index-in-vector-from-reverse-iterator
		auto rit = std::find(v.crbegin(), v.crend(), el); // reverse iterator
		return std::distance(rit, v.crend())  - 1;
	}
	unsigned int findLiveClus(unsigned int l, unsigned int ei, unsigned int target_mi) const {
		return findLastIndex(D[l][ei].clids, target_mi);
	}

	EntityDendron& findAddAtomicEntities(ClusterDendron& clusden) {
		for (unsigned int ei = 0; ei < NC; ei++) {
			if (D[0].size() < ei+1)
				D[0].push_back(Entity(ei));
			for (unsigned int ai = 0; ai < clusden.D[0].size(); ai++) {
//const auto& edamil = D[0][ei].memids;	
//if (clusden.D[0][ai].memls[0] == ei && std::find(edamil.begin(), edamil.end(), ei) == edamil.end()) {
				// allocate clusters with color ei in entden level zero with id ei
				if (clusden.D[0][ai].memls[0] == ei && !vectorIncludes(D[0][ei].clids, ai)) {
					D[0][ei].clids.push_back(ai);
					D[0][ei].birthtime.push_back(ofGetFrameNum()); //ofGetElapsedTimef
					D[0][ei].lifespan.push_back(0.f);
					clusden.D[0][ai].entid = ei;
				}	
			}	
		}
		return *this;
	}

	std::tuple<unsigned int, bool> fileLiveClusInEntden(unsigned int l, unsigned int ci, ClusterDendron& clusden) {
		// find entity with id ei in level l corresponding to cluster id ci; if absent, create entity and append
		std::vector<unsigned int> mulset = clusden.transcribeClusToEntMulset(l, ci, *this);
		if (mulset.empty())
			ofLogNotice() << "Warning: the matching entities have not been added yet" << endl;

		bool newreg = false; // new ent registered?
		unsigned int ei;
		for (ei = 0; ei < D[l].size(); ei++) {
			Entity &e = D[l][ei];
			unsigned int lci = findLastIndex(e.clids, ci);
			if (equalMultisets(mulset, e.memids)) {  // if multiset is already registered
				if (!vectorIncludes(e.clids, ci) ||     // cluster object not recognized
				    (vectorIncludes(e.clids, ci) && e.lifespan[lci] > 0.f)) { // cluster object registered but dead
					e.clids.push_back(ci);
					e.birthtime.push_back(ofGetFrameNum()); //ofGetElapsedTimef
					e.lifespan.push_back(0.f);
					clusden.D[l][ci].entid = ei;
					newreg = true;
				}
				return {ei, newreg};   // cluster object registered and alive
			}	
		}
		if (ei == D[l].size()) { // multiset not registered, so add/file it
			D[l].push_back(Entity(mulset, std::vector<unsigned int>{ci}, std::vector<float>{ofGetFrameNum()}, std::vector<float>{0.f})); //ofGetElapsedTimef
			clusden.D[l][ci].entid = ei;
			newreg = true;    // new entity created: true
		}
		return {ei, newreg};
	}

	std::tuple<unsigned int, bool> fileDeadClusInEntden(unsigned int l, unsigned int ci) {
		for (unsigned int ei = 0; ei < D[l].size(); ei++) {
			Entity& e = D[l][ei];
			unsigned int lci = findLastIndex(e.clids, ci);
			if (vectorIncludes(D[l][ei].clids, ci) && D[l][ei].lifespan[lci] == 0.f) {
				D[l][ei].lifespan[lci] = ofGetFrameNum() - D[l][ei].birthtime[lci]; //ofGetElapsedTimef
				return {ei, true};
			}
		}
		return {UINT_MAX, false};
	}

	std::vector<unsigned int> cullDanglingClusInEnts(unsigned int l, unsigned int ei, ClusterDendron& clusden) {
		Entity& e = D[l][ei];
		std::vector<unsigned int> cis;
		for (unsigned int ci = 0; ci < clusden.D[l].size(); ci++) {
			std::vector<unsigned int>::iterator fcit = std::find(e.clids.begin(), e.clids.end(), ci);

			if (fcit == e.clids.end()) // ci not in e.clids (also with !vectorIncludes(e.clids,ci))
	      	              	continue;
			unsigned int lci = findLastIndex(e.clids, ci);
		    	unsigned int fci = std::distance(e.clids.begin(), fcit);

			// if e points to live cluster ci, and 
			// if cluster registered as alive and does not belong to entity anymore 
			// or the multisets of children entities aren't equal
			if (e.lifespan[lci] == 0.f) {
				// transcription cannot change &entden
 				std::vector<unsigned int> ems = clusden.transcribeClusToEntMulset(l, ci, *this);
 				if (clusden.D[l][ci].entid!=ei || !equalMultisets(ems, e.memids)) {
					e.lifespan[lci] = ofGetFrameNum() - e.birthtime[lci]; //ofGetElapsedTimef
					// lazy culling unsuitable: there may be multiple clus in each ent
					cis.push_back(ci);					
				
					// this block was absent; executed if lci!=fci, so more than identical liveclu
					// checks and fixes dangling pointers when there are more than two clids
					// plucks off only one (non-last) dangling ent-to-clu pointer
					if (fci != lci && e.lifespan[fci] == 0.f) 
						e.lifespan[fci] = ofGetFrameNum() - e.birthtime[fci];
				}
			}
		}
		return cis;
	}

	void scanUpdateEnts(ClusterDendron& clusden, unsigned int lesl) {
		// lesl is the lowest level for starting a bottom-up scan
//if (lesl == 0) findAddAtomicEntities(clusden);

		// discover new live and dead entities; delete dangling pointers
		// important: the sweep must be bottom-up and include dead levels for correctness
//const unsigned int l1 = std::max(int(lesl), 1);
		const unsigned int l1 = lesl;
		for (unsigned int l = l1; l < clusden.D.size(); l++) { // clusden.D.size() == entden.D.size()
			if (D.size() == l)
				D.push_back(std::vector<Entity>());

			// scan ent object for new live (new clus) and dead (clus tomb) instances
			for (unsigned int ci = 0; ci < clusden.D[l].size(); ci++)
				if (clusden.D[l][ci].alive)
					// new cluster born OR new cluster transformed: register as ent
					fileLiveClusInEntden(l, ci, clusden);
				else
					// cluster death: write off cluster from ent
					fileDeadClusInEntden(l, ci);

			// scan ent object to prune dangling pointers to deprecated clusters: write off cluster from ent
			// e.g. a cluster may transform and its former entid then keeps pointing to its clid 
			for (unsigned int ei = 0; ei < D[l].size(); ei++)
				cullDanglingClusInEnts(l, ei, clusden);
		}
	}


	// Ent stats
	
	std::array<vector<unsigned int>, 2> count() {
		std::vector<unsigned int> nl(D.size()), nd(D.size());
		for (std::size_t l = 1; l < D.size(); l++) {
			nl[l] = nd[l] =  0;
			for (std::size_t i = 0; i < D[l].size(); i++)
				if (D[l][i].alive()) nl[l]++;
				else                 nd[l]++;
		}
		return {nl, nd};
	}

	EntityDendron liveEntsDendron() {
		EntityDendron led;
		led.D[0] = D[0];
		for (std::size_t l = 1; l < D.size(); l++) { 
			led.D.push_back(std::vector<Entity>());
			for (unsigned int ei = 0; ei < D[l].size(); ei++)
				if (D[l][ei].alive())
					led.D[l].push_back(D[l][ei]);
		}
		return led;
	}

	std::vector<std::vector<float>> cumLifespanByLev() const {
		std::vector<std::vector<float>> lt(D.size());
		for (std::size_t l = 1; l < D.size(); l++) 
			for (const auto& e : D[l]) { 
				// cumulative lifespan across different "lives"
				float cumls = 0;
				for (std::size_t i = 0; i < e.clids.size(); i++)
					if (e.lifespan[i] > 0.f) 
						cumls += e.lifespan[i];
					else                
						//cumls += ofGetElapsedTimef() - e.birthtime[i];
						cumls += ofGetFrameNum() - e.birthtime[i]; // time in frames
				lt[l].push_back(cumls);
			}
		return lt;
	}
	std::vector<float> lifespans() const {
		std::vector<float> lt;
		const auto ltl = cumLifespanByLev();
		for (unsigned int l = 1; l < ltl.size(); l++)
			for (const auto& ls : ltl[l])
				lt.push_back(ls);
		return lt;
	}

	std::vector<std::vector<float>> ageByLev(bool iscum) {
		// this is just lifespans of living ents
		EntityDendron led = liveEntsDendron();
		std::vector<std::vector<float>> lt(led.D.size());
		for (std::size_t l = 1; l < led.D.size(); l++) 
			for (auto& e : led.D[l]) {
//if (!e.alive()) throw 1;
/*
				unsigned int i;
				for (i = 0; i < e.clids.size(); i++)
					if (e.lifespan[i] == 0)
						break;
				lt[l].push_back(ofGetFrameNumf() - e.birthtime[i]); //ofGetElapsedTimef
*/
				// cumulative lifespan across different "lives"
				float cumls = 0;
				// current life lifespan
				float curls = NAN;
				for (unsigned int i = 0; i < e.clids.size(); i++)
					if (e.lifespan[i] > 0.f) 
						cumls += e.lifespan[i];
					else {               
						cumls += ofGetFrameNum() - e.birthtime[i]; //ofGetElapsedTimef
						curls  = ofGetFrameNum() - e.birthtime[i]; //ofGetElapsedTimef
					}
				if (iscum) 
					lt[l].push_back(cumls);
				else
					lt[l].push_back(curls);
			}
		return lt;
	}
	std::vector<float> ages(bool iscum) {
		std::vector<float> la;
		const auto lal = ageByLev(iscum);
		for (unsigned int l = 1; l < lal.size(); l++)
			for (const auto& a : lal[l])
				la.push_back(a);
		return la;
	}

	// cumulative top-down cluster sizes
	unsigned int subcluSiz(unsigned int l, unsigned int i) {
		unsigned int s = 1;
		if (l == 0)
			return s;
		for (unsigned int mi : D[l][i].memids)
			s += subcluSiz(l - 1, mi); 
		return s;
	}
	std::vector<std::vector<unsigned int>> liveDendronSubcluSiz() {
		std::vector<std::vector<unsigned int>> sv;
		sv.push_back(std::vector<unsigned int>(D[0].size(), 0));
		for (unsigned int l = 1; l < count()[0].size(); l++) {
			sv.push_back(std::vector<unsigned int>());
			for (unsigned int ci = 0; ci < D[l].size(); ci++)
				if (D[l][ci].alive())
					sv[l].push_back(subcluSiz(l, ci));
		}
		return sv;
	}
	
	// recursive factorial utils
	float logMultinCoef(unsigned int n, std::vector<unsigned int> kv) {
		//en.cppreference.com/w/cpp/numeric/math/lgamma
		float lmc = 0; 
		lmc += lgamma(n+1);
		for (const auto k : kv)
			lmc -= lgamma(k+1); 
		return lmc;
	}
	unsigned int factorial(unsigned int n) {
		if (n == 0)
			return 1;
		else
			return n * factorial(n - 1); 
	}
	unsigned int fallingFactorial(unsigned int n, unsigned int k) {
		if (k == 1)
			return n;
		else
			return n * fallingFactorial(n - 1, k - 1);
	}
	unsigned int risingFactorial(unsigned int n, unsigned int k) {
		if (k == 1)
			return n;
		else
			return n * risingFactorial(n + 1, k - 1);
	}
	unsigned int BellNumber(unsigned int n) {
		// en.wikipedia.org/wiki/Bell_number
		unsigned int bell[n+1][n+1];
		bell[0][0] = 1;
		for (unsigned int i = 1; i <= n; i++) {
			bell[i][0] = bell[i-1][i-1];
				for (unsigned int j=1; j <= i; j++)
					bell[i][j] = bell[i-1][j-1] + bell[i][j-1];
   		}
		return bell[n][0];
	}

	// entity complexity --if all parameters are assumed to bear priors-- recursively computed 
	float entityComplexity(unsigned int l, unsigned int i) {
		// inspired in differential entropy: it is proportional to the dimensionality
		// proportional to the number of dof of the model
		// Calculate diffents of the Gaussian blobs
		//  to make comparable we take pixel as the measure unit 
		//  Number of ways to put objects into D[l].size() bins: multinomial coefficient
		// Use as reference the universal cluster 
		
		// information unit
		//float I1 = 10 * std::log(2); // set the max val of vars to 2^10~1024, like pixel number, so complexity is 3.01
		float I1 = 32 * std::log(2); // set the max val of vars to 2^32=4294967296, like pixel number, so complexity is 9.63

		if (l == 0)
			return 2 * I1;  // 2 coordinates, 1 color of 4

		// Blob parameters complexity
		float C = I1 * 5;  // 2 semiaxes, 1 angle, 2 coordinates; 2*ND-1 + ND
		
		// Blob member allocation complexity
		float nclu = count()[0][l]; // all live clusters at level l
		float nelm = count()[0][l-1]; // all live elements at level l-1
		
		//en.wikipedia.org/wiki/Multinomial_theorem#Sum_of_all_multinomial_coefficients
		//C += nelm * std::log(nclu) / nclu; // sum = nclu^nelm, divide by nclu because sum is for the whole level l
		//wrong: Counting n-combinations of X is equivalent to 
		//	 counting injective functions N → X up to permutations of N
		// see Twelvefold way: https://en.wikipedia.org/wiki/Twelvefold_way

		// en.wikipedia.org/wiki/Partition_of_a_set
		// Stirling number of the second kind
		// Counting partitions of the set N into x subsets is equivalent to 
		// counting all surjective functions N → X up to permutations of X
		// the sum of all these partitions for each x is the Bell number
		C += std::log(float(BellNumber((unsigned int)nelm))) / nclu; // divide by nclu because sum is for the whole level l

		for (unsigned mi : D[l][i].memids)
			C += entityComplexity(l - 1, mi); 

		return C;
	}
	std::vector<std::vector<float>> liveDendronComplexity() {
		std::vector<std::vector<float>> C;
		C.push_back(std::vector<float>(D[0].size(), 0));
		for (unsigned int l = 1; l < D.size(); l++) {
			C.push_back(std::vector<float>());
			for (unsigned int ci = 0; ci < D[l].size(); ci++)
				if (D[l][ci].alive())
					C[l].push_back(entityComplexity(l, ci));
		}
		return C;
	}
	std::vector<std::vector<float>> wholeDendronComplexity() {
		std::vector<std::vector<float>> C;
		C.push_back(std::vector<float>(D[0].size(), 0));
		for (unsigned int l = 1; l < D.size(); l++) {
			C.push_back(std::vector<float>());
			for (unsigned int ci = 0; ci < D[l].size(); ci++)
				C[l].push_back(entityComplexity(l, ci));
		}
		return C;
	}
};

// TRANSCRIPTION OF CLUSTERS TO ENTITIES
//compiler error without inline: stackoverflow.com/questions/39652884/one-definition-rule-multiple-definition-of-inline-functions
inline std::vector<unsigned int> ClusterDendron::transcribeClusToEntMulset(unsigned int l, unsigned int ci, EntityDendron &entden) const {
	const Cluster& c = D[l][ci];
	if (l == 0)
		return std::vector<unsigned int>{c.entid};
	
	std::vector<unsigned int> entmulset;
	//cplusplus.com/reference/cstdio/size_t/
	//stackoverflow.com/questions/22437175/difference-between-size-type-and-int
	for (unsigned int mi : c.memls)
		for (unsigned int k = 0; k < entden.D[l-1].size(); k++) {
			Entity &e = entden.D[l-1][k];
//const auto em = e.memids;
			const auto lastlci = entden.findLiveClus(l-1, k, mi);
			if (vectorIncludes<unsigned int>(e.clids, mi) && e.lifespan[lastlci] == 0.f) {
			// entity pointers to *live* clusters (and viceversa) at l-1 are correct 
			//because of scanUpdateEntities' bottom-up sweep
				entmulset.push_back(k);

				//but can other pointers at l-1 wrongly point after the bottom-up sweep?
				std::vector<unsigned int> ems = transcribeClusToEntMulset(l-1, mi, entden);

				// clus-ent member ids mismatch: this should not happen
				if (D[l-1][mi].entid != k || !equalMultisets(entden.D[l-1][k].memids, ems)) {
					ofLogNotice() << "clus-ent memid mismatch at level " << l << ", ent " << k << ", clu " << ci;
					std::cout << "\nent members\n";
					for (auto emi : entden.D[l-1][k].memids) 
						std::cout << emi << " ";
					std::cout << "\nclu members\n";
					for (auto cmi : D[l-1][mi].memls) 
						std::cout << cmi << " ";
					std::cout << "\n";
throw std::runtime_error(" clus-ent member ids mismatch");
					const auto lastlci = entden.findLiveClus(l-1, k, mi);
					e.lifespan[lastlci] = ofGetFrameNum() - e.birthtime[lastlci]; 
				}
			}	

		}
	if (entmulset.size() != c.memls.size()) {  
	// the entity ids do not match: tests the same as memberwise mismatch
		ofLogNotice() << "size mismatch at level " << l << ", cluster " << ci;
		std::cerr << "\n";
		std::cout << "\nent mems\n";
		for (auto emi : entmulset) 
			std::cout << emi << " ";	
		std::cout << "\nclu mems\n";
		for (auto cmi : c.memls) 
			std::cout << cmi << " ";	
		std::cout << endl;
throw std::runtime_error(" entity sizes mismatch "); // throw 'm';
		return std::vector<unsigned int>();  // or {}: emtpy vector
	} else
		return entmulset;
}



// ofApp class prototyping

class ofApp final : public ofBaseApp {
public:
	// World objects
	
	//stackoverflow.com/questions/59815927/error-x-is-not-a-type-where-x-is-constructor-argument
	//default member initializer (since C++11) only supports braced-list and equal-sign, but not parentheses initializer
	//AtomMash atoms = AtomMash(initCount); // or AtomMash atoms{initCount}
	AtomMash atoms{initCount}; 
	ClusterDendron clusters{&atoms};
	EntityDendron entities{};

	AtomMash atoms2 = AtomMash(atoms);   // copy for testing


	// Physical properties
	
	// dimensionality
	static constexpr float nd = 2;

	// Number of atom colors
	static constexpr unsigned int nc = NC; // constexpr or cons
	// numer of atoms of each color
	static constexpr unsigned int initCount = 64;
	
	// interaction force law
	float interactionLaw = -1;// 1 - nd;  // -2 for 3D; -1 for 2D, as most physics

	// interaction matrix coefficients
	float Xc[nc][nc];
	ofxFloatSlider* Sc[nc][nc];  
        void mat2ixc(float M[nc][nc]);
	static constexpr float initInteracCoef = 0.01;
	float initXc[NC][NC] {}; // {} initializes all elements to zero
	// interaction coefficient upper and negative lower bound
	float ixcULB = 1.F;  // 80.0f
	
	// interaction matrix ranges
	float Xr[nc][nc];
	ofxFloatSlider* Sr[nc][nc];  
        void mat2ixr(float M[nc][nc]);
	static constexpr float initInteracRange = 180; 
	float initXr[NC][NC] {};  // {number} only sets the first element
	// interaction range upper and lower bounds
	float rangeUB = 500.f; // 200.0 for random
	float rangeLB = 0.f;   // 10.0F
				 
	// atom count
	ofxIntSlider* Sn[nc];  // slider object pointers

	// interaction probability
	float interacLog10Prob100 = 2.f;

	// time stepsize
	float log10TimeStep = 0.f;
	float dt = std::pow(10, log10TimeStep); 
	ofxLabel forwardStepLabel;
	ofxLabel fpsLabel;
	
	// damping or friction
	float log10DampingCoef = -1.1; // dampingCoef = 0.7 = log10(-1.1)
	
	// vertical pull 
	float vertGravity = 0.F;
	
	// wall properties
	float wallThickness = 0.f; // 20.f
	float wallElasticity = 0.f; // 0.1F
	bool wrapAround = false; 
	
	// time series
	std::vector<unsigned int> stepts; // steps time series
	std::vector<float> ets; // time series
	float msv = 0;  // atoms mean square velocity
	//stackoverflow.com/questions/59815927/error-x-is-not-a-type-where-x-is-constructor-argument
	//default member initializer (since C++11) only supports braced-list and equal-sign, but not parentheses initializer
	std::vector<float> msvk = std::vector<float>(nc, 0);  // atoms mean square velocity by kind
	float volume = 0; // world volume 
	float atomdens = 0; // atom density
	float clusdens = 0; // entity density
	float pressure = 0;
	std::vector<float> cvNkT;  // temperature
	std::vector<std::vector<float>> cvNkTk;  // temperature by atom kind
	std::vector<float> boxVol;  // volume 
	std::vector<float> boxAtomDens;  // atom density 
	std::vector<float> boxClusDens;  // cluster density
	std::vector<float> boxPressure;  // pressure
	// suprisal 
	std::vector<float> supats, supcts, subats;
        // clu/ent cardinality	
	std::vector<std::vector<unsigned int>> lcnts, dcnts, lents, dents; 
	// entity dendron lifespans, complexity
	std::vector<std::vector<std::vector<float>>> wdTts{std::vector<std::vector<float>>()}, ldcumTts{std::vector<std::vector<float>>()}, ldcurTts{std::vector<std::vector<float>>()}, ldCts{std::vector<std::vector<float>>()}, wdCts{std::vector<std::vector<float>>()}; 
	std::vector<std::vector<std::vector<unsigned int>>> ldsts{std::vector<std::vector<unsigned int>>()};
	// live cluster level-wise
	std::vector<std::vector<std::vector<unsigned int>>> livclusizts{std::vector<std::vector<unsigned int>>()}; // level-wise sizes
	std::vector<std::vector<std::vector<float>>> csv{std::vector<std::vector<float>>()}; // cluster-wise squared velocities
	std::vector<std::vector<std::vector<float>>> csmv{std::vector<std::vector<float>>()}; // clwise sq member estimated velocities
	std::vector<std::vector<std::vector<float>>> csu{std::vector<std::vector<float>>()}; // cluster-wise surprisals


	// View
	// color channels
	static constexpr const unsigned char colCh[4][3] = {{250, 10, 100}, {100, 250, 10}, {10, 100, 250}, {250, 250, 250}};
	// canvas or box bounds
	unsigned int boxWidth = 800; //1600; 1024
	unsigned int boxHeight = 600; //900; 768
	// draw transparency in 0-255
	int canvasRedrawAlpha = 64; 
	int atomsAlpha = 111; 
	// rate parameters
	int frameCount = 0;
	clock_t nowDrawTime, lastDrawTime, deltaDrawTime;
	clock_t step_start, step_delta;


	// ofApp properties
	unsigned int step = 0;

	// ofApp methods
	void setup() override;
	void update() override;
	void draw() override;
	void keyPressed(int key) override;
	void exit() override;
	
	// Other methods and classes
	//void reatomize();
	void randomizeParameters(char symmetrize);
	void randomizeParameters();
	void saveParameters();
	void loadParameters();
	void interact(unsigned int ac1, unsigned int ac2, float G, float range);



	// GUI
	ofxPanel gui;

	// GUI groups
	ofxGuiGroup physicsGuig, viewGuig,countGuig;
	ofxGuiGroup redGuig, greenGuig, blueGuig, whiteGuig;
	ofxGuiGroup roveGuig;

	// buttons and toggles
	ofxButton doStir;
	//ofxButton selectButton;
	ofxButton doRandomizeReatomize;
	ofxToggle symmetrizeInteractionsToggle;
	ofxToggle skewsymmetrizeInteractionsToggle;
	ofxButton doSave;
	ofxButton doLoad;
	ofxToggle regularPotentialToggle;
	ofxToggle viscosityToggle;
	ofxToggle wrapAroundToggle;
	ofxToggle modelDiagramToggle;
	ofxToggle motionBlurToggle;
	ofxToggle roveToggle;
	ofxToggle infiniteRangeToggle;
	ofxToggle computeClustersToggle;
	ofxToggle viewSpokesToggle;


	// model diagrams
	static constexpr float md_xshift = 400;
	static constexpr float md_yshift = 80;
	static constexpr float anchor = 0;
	// model matrix
	static constexpr float mm_rectseg = 60; 
	// model graph
	static constexpr float md_sidelen = 70;
	float mdc[nc][int(nd)] = {};
	//assignment statements like array[0] = 0 cannot go into the struct definition
	//they need to go into an executable block of code like a function, a constructor or similar
	static constexpr float md_circrad = 8; 


	// Saving text files
	ofFile bugFile; // for some reason the first defined ofFile segfaults on opening
	ofFile parsFile, statsFile, wholeEntdenFile, liveEntdenFile, liveCludenFile;


	// Sliders

	//atom count
	ofxIntSlider redCountSlider, greenCountSlider, blueCountSlider, whiteCountSlider;

	// view
	ofxIntSlider canvasRedrawAlphaSlider;
	ofxIntSlider atomsAlphaSlider;

	// physics
	ofxFloatSlider interacProbSlider;
	ofxFloatSlider interactionLawSlider;
	ofxFloatSlider log10TimeStepSlider;
	ofxFloatSlider log10DampingCoefSlider;
	ofxFloatSlider vertGravitySlider;
	ofxFloatSlider wallThicknessSlider;
	ofxFloatSlider wallElasticitySlider;

	// evolution: roving in parameter space
	ofxFloatSlider roveProbSlider;
	ofxFloatSlider roveRatioSlider;

	// interaction coefficients
	ofxFloatSlider ixcSliderRR, ixcSliderRG, ixcSliderRB, ixcSliderRW;
	ofxFloatSlider ixcSliderGR, ixcSliderGG, ixcSliderGB, ixcSliderGW;
	ofxFloatSlider ixcSliderBR, ixcSliderBG, ixcSliderBB, ixcSliderBW;
	ofxFloatSlider ixcSliderWR, ixcSliderWG, ixcSliderWB, ixcSliderWW;
	// interaction ranges 
	ofxFloatSlider ixrSliderRR, ixrSliderRG, ixrSliderRB, ixrSliderRW;
	ofxFloatSlider ixrSliderGR, ixrSliderGG, ixrSliderGB, ixrSliderGW;
	ofxFloatSlider ixrSliderBR, ixrSliderBG, ixrSliderBB, ixrSliderBW;
	ofxFloatSlider ixrSliderWR, ixrSliderWG, ixrSliderWB, ixrSliderWW;
};
